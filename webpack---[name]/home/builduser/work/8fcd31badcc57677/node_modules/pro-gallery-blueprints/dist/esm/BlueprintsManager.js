import {
    __assign,
    __awaiter,
    __generator
} from "tslib";
/* eslint-disable prettier/prettier */
import blueprints from './Blueprints';
import {
    viewModeWrapper
} from 'pro-gallery-lib';
var BlueprintsManager = /** @class */ (function() {
    function BlueprintsManager(_a) {
        var id = _a.id;
        this.id = id + "'s blueprintsManager";
        this.currentState = {};
        this.existingBlueprint = {};
        this.cache = {};
        this.api = {};
        this.currentState.totalItemsCount = Infinity;
        this.onBlueprintReady = function() {};
        this.loopingItems = false;
    }
    BlueprintsManager.prototype.init = function(config) {
        this.api = config.api;
        this.currentState.totalItemsCount =
            (config && config.totalItemsCount) || this.currentState.totalItemsCount;
        viewModeWrapper.setDeviceType(config.deviceType);
    };
    BlueprintsManager.prototype.createBlueprint = function(params) {
        if (params === void 0) {
            params = {};
        }
        return __awaiter(this, void 0, void 0, function() {
            var _a, _createBlueprint, _b, blueprint, changedParams, blueprintChanged, blueprintCreated;
            var _this = this;
            return __generator(this, function(_c) {
                switch (_c.label) {
                    case 0:
                        this.currentState.totalItemsCount =
                            params.totalItemsCount ||
                            (this.api.getTotalItemsCount && this.api.getTotalItemsCount()) ||
                            this.currentState.totalItemsCount;
                        this.currentState.isUsingCustomInfoElements =
                            params.isUsingCustomInfoElements ||
                            (this.api.isUsingCustomInfoElements &&
                                this.api.isUsingCustomInfoElements()) ||
                            this.currentState.isUsingCustomInfoElements;
                        _a = [__assign({}, params)];
                        return [4 /*yield*/ , this.completeParams(params)];
                    case 1:
                        params = __assign.apply(void 0, _a.concat([(_c.sent())]));
                        _createBlueprint = function(args) {
                            return __awaiter(_this, void 0, void 0, function() {
                                return __generator(this, function(_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!this.api.createBlueprintImp) return [3 /*break*/ , 2];
                                            return [4 /*yield*/ , this.api.createBlueprintImp(args)];
                                        case 1:
                                            return [2 /*return*/ , _a.sent()];
                                        case 2:
                                            return [4 /*yield*/ , blueprints.createBlueprint(args)];
                                        case 3:
                                            return [2 /*return*/ , _a.sent()];
                                    }
                                });
                            });
                        };
                        return [4 /*yield*/ , _createBlueprint({
                            params: params,
                            lastParams: this.currentState,
                            existingBlueprint: this.existingBlueprint,
                            blueprintManagerId: this.id,
                            isUsingCustomInfoElements: this.currentState.isUsingCustomInfoElements,
                        })];
                    case 2:
                        _b = _c.sent(), blueprint = _b.blueprint, changedParams = _b.changedParams;
                        blueprintChanged = Object.values(changedParams).some(function(changedParam) {
                            return !!changedParam;
                        });
                        blueprintCreated = Object.keys(blueprint).length > 0;
                        this.updateLastParamsIfNeeded(params, changedParams, blueprintCreated);
                        blueprintCreated &&
                            this.api.onBlueprintReady &&
                            this.api.onBlueprintReady({
                                blueprint: blueprint,
                                blueprintChanged: blueprintChanged
                            });
                        return [2 /*return*/ , (this.cache[params] = this.existingBlueprint = blueprint)]; // still returning for awaits... event is !blueprintCreated
                }
            });
        });
    };
    BlueprintsManager.prototype.getMoreItems = function(currentItemLength) {
        return __awaiter(this, void 0, void 0, function() {
            var items;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        if (!(currentItemLength < this.currentState.totalItemsCount)) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , this.api.fetchMoreItems(currentItemLength)];
                    case 1:
                        // this.gettingMoreItems = true;
                        items = _a.sent();
                        if (items) {
                            this.createBlueprint({
                                items: items
                            });
                            // work with the new items...
                        }
                        return [3 /*break*/ , 3];
                    case 2:
                        if (this.existingBlueprint.options.slideshowLoop) {
                            this.duplicateGalleryItems();
                        }
                        _a.label = 3;
                    case 3:
                        return [2 /*return*/ ];
                }
            });
        });
    };
    BlueprintsManager.prototype.resetItemLooping = function() {
        this.loopingItems = false;
    };
    BlueprintsManager.prototype.createInitialBlueprint = function(params) {
        this.currentState.totalItemsCount =
            params.totalItemsCount ||
            (this.api.getTotalItemsCount && this.api.getTotalItemsCount()) ||
            this.currentState.totalItemsCount;
        this.currentState.isUsingCustomInfoElements =
            params.isUsingCustomInfoElements ||
            (this.api.isUsingCustomInfoElements &&
                this.api.isUsingCustomInfoElements()) ||
            this.currentState.isUsingCustomInfoElements;
        var _a = blueprints.createBlueprint({
                params: params,
                lastParams: this.currentState,
                existingBlueprint: this.existingBlueprint,
                blueprintManagerId: this.id,
                isUsingCustomInfoElements: this.currentState.isUsingCustomInfoElements,
            }),
            blueprint = _a.blueprint,
            changedParams = _a.changedParams;
        var blueprintChanged = Object.values(changedParams).some(function(changedParam) {
            return !!changedParam;
        });
        var blueprintCreated = Object.keys(blueprint).length > 0;
        this.updateLastParamsIfNeeded(params, changedParams, blueprintCreated);
        blueprintCreated &&
            this.api.onBlueprintReady &&
            this.api.onBlueprintReady({
                blueprint: blueprint,
                blueprintChanged: blueprintChanged,
                initialBlueprint: true,
            });
        return (blueprintCreated &&
            (this.cache[params] = this.existingBlueprint = blueprint));
    };
    BlueprintsManager.prototype.createSingleBlueprint = function(params) {
        if (params === void 0) {
            params = {};
        }
        var isUsingCustomInfoElements = params.isUsingCustomInfoElements;
        var blueprint = blueprints.createBlueprint({
            params: params,
            lastParams: {},
            existingBlueprint: {},
            blueprintManagerId: this.id + '_singleBlueprint',
            isUsingCustomInfoElements: isUsingCustomInfoElements,
        }).blueprint;
        return blueprint;
    };
    BlueprintsManager.prototype.duplicateGalleryItems = function() {
        var _a;
        var items = (_a = this.currentState.items).concat.apply(_a, this.currentState.items.slice(0, this.currentState.totalItemsCount));
        this.loopingItems = true;
        this.createBlueprint({
            items: items
        });
    };
    // ------------------ Get all the needed raw data ---------------------------- //
    BlueprintsManager.prototype.completeParams = function(params) {
        return __awaiter(this, void 0, void 0, function() {
            var _a, container, items, options, id;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        _a = params || {}, container = _a.container, items = _a.items, options = _a.options, id = _a.id;
                        return [4 /*yield*/ , this.fetchContainerIfNeeded(container)];
                    case 1:
                        container = _b.sent();
                        return [4 /*yield*/ , this.fetchItemsIfNeeded(items)];
                    case 2:
                        items = _b.sent();
                        return [4 /*yield*/ , this.fetchOptionsIfNeeded(options)];
                    case 3:
                        options = _b.sent(); // can be async... TODO
                        return [2 /*return*/ , {
                            container: container,
                            items: items,
                            options: options,
                            id: id
                        }];
                }
            });
        });
    };
    BlueprintsManager.prototype.fetchContainerIfNeeded = function(container) {
        return __awaiter(this, void 0, void 0, function() {
            var shouldFetchContainer, _a;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        shouldFetchContainer = function(_container) {
                            var should = true;
                            if (_container && Object.keys(_container).length > 0) {
                                should = false;
                            }
                            return should;
                        };
                        if (!shouldFetchContainer(container)) return [3 /*break*/ , 3];
                        _a = this.api.fetchContainer;
                        if (!_a) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , this.api.fetchContainer()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // dimensions = {yonatanFakeDimensions: true, width: "", height: ""} // TODO - is there something here???
                        container =
                            (_a) ||
                            this.currentState.container;
                        _b.label = 3;
                    case 3:
                        return [2 /*return*/ , container];
                }
            });
        });
    };
    BlueprintsManager.prototype.fetchItemsIfNeeded = function(items) {
        return __awaiter(this, void 0, void 0, function() {
            var shouldFetchItems, _a;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        shouldFetchItems = function(_items) {
                            var should = true;
                            if (_items && _items.length > 0) {
                                should = false;
                            }
                            return should;
                        };
                        if (!shouldFetchItems(items)) return [3 /*break*/ , 3];
                        _a = !this.loopingItems &&
                            this.api.fetchItems;
                        if (!_a) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , this.api.fetchItems()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // items = ['yonatan - fake items'] // getGalleryDataFromServer(); - worker code to be used here.
                        items =
                            (_a) ||
                            this.currentState.items;
                        _b.label = 3;
                    case 3:
                        // TODO - this.loadItemsDimensionsIfNeeded();
                        return [2 /*return*/ , items];
                }
            });
        });
    };
    BlueprintsManager.prototype.fetchOptionsIfNeeded = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            var shouldFetchOptions, _a;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        shouldFetchOptions = function(_options) {
                            var should = true;
                            if (_options && Object.keys(_options).length > 0) {
                                // TODO - should check if they are ready options and use ClientLib if not?
                                should = false;
                            }
                            return should;
                        };
                        if (!shouldFetchOptions(options)) return [3 /*break*/ , 3];
                        _a = this.api.fetchOptions;
                        if (!_a) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , this.api.fetchOptions()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // styles = ['yonatan - fake styles'] // get styles - from SA ; - worker code to be used here.
                        options =
                            (_a) ||
                            this.currentState.options;
                        _b.label = 3;
                    case 3:
                        return [2 /*return*/ , options];
                }
            });
        });
    };
    BlueprintsManager.prototype.updateLastParamsIfNeeded = function(_a, changedParams, blueprintCreated) {
        var items = _a.items,
            container = _a.container,
            options = _a.options;
        if (blueprintCreated) {
            this.currentState.items = changedParams.itemsChanged ?
                items :
                this.currentState.items;
            this.currentState.container = changedParams.containerChanged ?
                __assign({}, container) : this.currentState.container;
            this.currentState.options = changedParams.optionsChanged ?
                __assign({}, options) : this.currentState.options;
        }
    };
    BlueprintsManager.prototype.needMoreItems = function(currentItemLength) {
        this.getMoreItems(currentItemLength);
    };
    return BlueprintsManager;
}());
export default BlueprintsManager;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=BlueprintsManager.js.map