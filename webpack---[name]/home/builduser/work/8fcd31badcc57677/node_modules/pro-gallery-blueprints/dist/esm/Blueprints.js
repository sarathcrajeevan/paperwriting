import {
    Layouter,
    ItemsHelper
} from 'pro-layouts';
import {
    populateWithDefaultOptions,
    addPresetOptions,
    dimensionsHelper,
    processLayouts,
    GALLERY_CONSTS,
    extendNestedOptionsToIncludeOldAndNew,
} from 'pro-gallery-lib';
var Blueprints = /** @class */ (function() {
    function Blueprints() {}
    Blueprints.prototype.createBlueprint = function(_a) {
        // cacheBlocker
        // if (this.cache[params]) return this.cache[params];
        var params = _a.params,
            lastParams = _a.lastParams,
            existingBlueprint = _a.existingBlueprint,
            blueprintManagerId = _a.blueprintManagerId,
            isUsingCustomInfoElements = _a.isUsingCustomInfoElements;
        var changedParams = {};
        try {
            var newContainerParams = params.container,
                newItemsParams = params.items,
                newOptions = params.options;
            var oldContainerParams = lastParams.container,
                oldItemsParams = lastParams.items,
                oldOptions = lastParams.options;
            // getItems,options and dimesions if not supplied in params;
            var _b = this.formatItemsIfNeeded(newItemsParams, oldItemsParams),
                formattedItems = _b.formattedItems,
                itemsChanged = _b.changed;
            var _c = this.formatOptionsIfNeeded(newOptions, oldOptions, isUsingCustomInfoElements),
                formattedOptions = _c.formattedOptions,
                optionsChanged = _c.changed;
            var _d = this.formatContainerIfNeeded(newContainerParams, oldContainerParams, oldOptions, formattedOptions || existingBlueprint.options, optionsChanged),
                formattedContainer = _d.formattedContainer,
                containerChanged = _d.changed;
            var changed = itemsChanged || optionsChanged || containerChanged;
            changedParams = {
                itemsChanged: itemsChanged,
                optionsChanged: optionsChanged,
                containerChanged: containerChanged
            };
            if (changed || !existingBlueprint) {
                if (!existingBlueprint) {
                    existingBlueprint = {};
                }
                var structure = this.createStructure({
                    formattedContainer: formattedContainer || existingBlueprint.container,
                    formattedItems: formattedItems || existingBlueprint.items,
                    formattedOptions: formattedOptions || existingBlueprint.options,
                }, changed);
                // assign changed values w/o replacing the original object;
                if (formattedOptions) {
                    existingBlueprint.options = formattedOptions;
                }
                if (formattedItems) {
                    existingBlueprint.items = formattedItems;
                }
                if (formattedContainer) {
                    existingBlueprint.container = formattedContainer;
                }
                existingBlueprint.structure = structure;
                // if its an infinite gallery - let the container loose
                var isInfinite = existingBlueprint.options.scrollDirection ===
                    GALLERY_CONSTS.scrollDirection.VERTICAL &&
                    existingBlueprint.options.enableInfiniteScroll;
                if (isInfinite) {
                    existingBlueprint.container.height =
                        existingBlueprint.container.galleryHeight = structure.height;
                }
            }
        } catch (error) {
            console.error('Could not create blueprint, error:', error);
        }
        // return the existing or the modified existing object
        return {
            blueprint: existingBlueprint,
            changedParams: changedParams,
            blueprintManagerId: blueprintManagerId
        };
    };
    // ------------------ Raw data to Formated data (if needed) ---------------------------- //
    Blueprints.prototype.formatItemsIfNeeded = function(items, lastItems) {
        var reason = {
            items: '',
            itemsAdded: '',
        };
        var itemsWereAdded = function(newItemsParams, oldItemsParams) {
            if (newItemsParams === oldItemsParams) {
                reason.itemsAdded = 'items are the same object.';
                return false; // it is the exact same object
            }
            if (!newItemsParams) {
                reason.itemsAdded = 'new items do not exist.';
                return false; // new items do not exist (use old items)
            }
            if (!oldItemsParams || (oldItemsParams && oldItemsParams.length === 0)) {
                reason.itemsAdded = 'old items do not exist.';
                return false; // old items do not exist (it is not items addition)
            }
            if (oldItemsParams.length >= newItemsParams.length) {
                reason.itemsAdded = 'more old items than new items.';
                return false; // more old items than new items
            }
            var idsNotChanged = oldItemsParams.reduce(function(is, _item, idx) {
                // check that all the existing items exist in the new array
                return is && _item.id === newItemsParams[idx].itemId;
            }, true);
            if (!idsNotChanged) {
                reason.itemsAdded = 'items ids were changed. ';
            }
            return idsNotChanged;
        };
        var itemsHaveChanged = function(newItemsParams, oldItemsParams) {
            if (newItemsParams === oldItemsParams) {
                reason.items = 'items are the same object.';
                return false; // it is the exact same object
            }
            if (!newItemsParams) {
                reason.items = 'new items do not exist.';
                return false; // new items do not exist (use old items)
            }
            if (!oldItemsParams || (oldItemsParams && oldItemsParams.length === 0)) {
                reason.items = 'old items do not exist.';
                return true; // old items do not exist
            }
            if (oldItemsParams.length !== newItemsParams.length) {
                reason.items = 'more new items than old items (or vice versa).';
                return true; // more new items than old items (or vice versa)
            }
            return newItemsParams.some(function(newItem, idx) {
                // check that all the items are identical
                var existingItem = oldItemsParams[idx];
                try {
                    var itemsChanged = !newItem ||
                        !existingItem ||
                        newItem.itemId !== existingItem.itemId ||
                        newItem.mediaUrl !== existingItem.mediaUrl ||
                        newItem.measured !== existingItem.measured ||
                        (newItem.metaData &&
                            existingItem.metaData &&
                            (newItem.metaData.type !== existingItem.metaData.type ||
                                newItem.metaData.title !== existingItem.metaData.title ||
                                newItem.metaData.description !==
                                existingItem.metaData.description)) ||
                        (newItem.metaData &&
                            newItem.metaData.type === 'text' &&
                            existingItem.metaData &&
                            existingItem.metaData.type === 'text' &&
                            (newItem.metaData.width !== existingItem.metaData.width ||
                                newItem.metaData.height !== existingItem.metaData.height ||
                                newItem.metaData.html !== existingItem.metaData.html ||
                                newItem.metaData.textStyle !==
                                existingItem.metaData.textStyle ||
                                newItem.metaData.editorHtml !==
                                existingItem.metaData.editorHtml));
                    if (itemsChanged) {
                        reason.items = "items #" + idx + " id was changed.";
                    }
                    return itemsChanged;
                } catch (e) {
                    reason.items = 'an error occured';
                    return true;
                }
            }, false);
        };
        var oldItemsParams = lastItems;
        var changed = false;
        var formattedItems;
        if (itemsWereAdded(items, oldItemsParams)) {
            formattedItems = oldItemsParams.concat(items.slice(oldItemsParams.length).map(function(item) {
                return ItemsHelper.convertDtoToLayoutItem(item);
            }));
            this.gettingMoreItems = false; // probably finished getting more items       //TODO - what is this and how we keep it alive if needed?
            changed = true;
        } else if (itemsHaveChanged(items, oldItemsParams)) {
            formattedItems = items.map(function(item) {
                return Object.assign(ItemsHelper.convertDtoToLayoutItem(item));
            });
            this.gettingMoreItems = false; // probably finished getting more items
            changed = true;
        }
        return {
            formattedItems: formattedItems,
            changed: changed
        };
    };
    Blueprints.prototype.formatOptionsIfNeeded = function(options, lastOptions, isUsingCustomInfoElements) {
        var reason = {
            options: '',
        };
        var optionsHaveChanged = function(newOptions, oldOptions) {
            if (!newOptions) {
                reason.options = 'no new options.';
                return false; // no new options - use old options
            }
            if (!oldOptions) {
                reason.options = 'no old options.';
                return true; // no old options
            }
            try {
                var oldOptionsSorted_1 = {};
                Object.keys(oldOptions)
                    .sort() // sort by keys alphabetically
                    .forEach(function(key) {
                        return (oldOptionsSorted_1[key] = oldOptions[key]);
                    });
                var newOptionsSorted_1 = {};
                Object.keys(newOptions)
                    .sort() // sort by keys alphabetically
                    .forEach(function(key) {
                        return (newOptionsSorted_1[key] = newOptions[key]);
                    });
                var wasChanged = JSON.stringify(newOptionsSorted_1) !== JSON.stringify(oldOptionsSorted_1);
                if (wasChanged) {
                    reason.options = 'options were changed.';
                }
                return wasChanged;
            } catch (e) {
                console.error('Could not compare options', e);
                return false;
            }
        };
        var oldOptions = lastOptions;
        var changed = false;
        var formattedOptions;
        if (optionsHaveChanged(options, oldOptions)) {
            var mergedOldAndNewStyles = extendNestedOptionsToIncludeOldAndNew(options); //add both old and new options
            var fullOptionsOverDefualts = populateWithDefaultOptions(mergedOldAndNewStyles); //add default for any undefined option
            formattedOptions = extendNestedOptionsToIncludeOldAndNew(processLayouts(addPresetOptions(fullOptionsOverDefualts), isUsingCustomInfoElements)); // TODO make sure the processLayouts is up to date. delete addLayoutStyles from layoutsHelper when done with it...
            changed = true;
        }
        return {
            formattedOptions: formattedOptions,
            changed: changed
        };
    };
    Blueprints.prototype.formatContainerIfNeeded = function(container, lastContainer, lastOptions, formattedOptions, optionsChanged) {
        var reason = {
            container: '',
        };
        var containerHasChanged = function(_a) {
            var newContainerParams = _a.newContainerParams,
                oldContainerParams = _a.oldContainerParams,
                oldOptions = _a.oldOptions;
            if (!oldOptions || !oldContainerParams) {
                reason.container = 'no old container or options. ';
                return true; // no old container or options (style may change container)
            }
            if (!newContainerParams) {
                reason.container = 'no new container.';
                return false; // no new continainer
            }
            var containerHasChanged = {
                height: formattedOptions.scrollDirection ===
                    GALLERY_CONSTS.scrollDirection.VERTICAL &&
                    formattedOptions.enableInfiniteScroll // height doesnt matter if the new gallery is going to be vertical
                    ?
                    false :
                    !!newContainerParams.height &&
                    newContainerParams.height !== oldContainerParams.height,
                width: !oldContainerParams ||
                    (!!newContainerParams.width &&
                        newContainerParams.width !== oldContainerParams.width),
            };
            return Object.keys(containerHasChanged).reduce(function(is, key) {
                if (containerHasChanged[key]) {
                    reason.container += "container." + key + " has changed. ";
                }
                return is || containerHasChanged[key];
            }, false);
        };
        var oldContainerParams = lastContainer;
        var changed = false;
        var oldOptions = lastOptions;
        var formattedContainer;
        if (optionsChanged || // If options changed they could affect the container and a new container must be created (slideshow,thumbs,shadow,borders...etc)
            containerHasChanged({
                newContainerParams: container,
                oldContainerParams: oldContainerParams,
                oldOptions: oldOptions,
            })) {
            dimensionsHelper.updateParams({
                options: formattedOptions,
                container: container,
            });
            changed = true;
            formattedContainer = Object.assign({}, container, dimensionsHelper.getGalleryDimensions());
        }
        return {
            formattedContainer: formattedContainer,
            changed: changed
        };
    };
    Blueprints.prototype.createStructure = function(_a) {
        var formattedContainer = _a.formattedContainer,
            formattedOptions = _a.formattedOptions,
            formattedItems = _a.formattedItems;
        var layoutParams = {
            items: formattedItems,
            container: formattedContainer,
            styleParams: formattedOptions,
            options: {
                showAllItems: true,
                skipVisibilitiesCalc: true,
                useLayoutStore: false,
            },
        };
        // if (this.layouter && addingItems) {
        //   layoutParams.options.useExistingLayout = true;
        // } else {
        layoutParams.options.createLayoutOnInit = false; // TODO - what does this do?
        this.layouter = new Layouter(layoutParams); // TODO - no need for "this."
        // }
        return this.layouter.createLayout(layoutParams);
    };
    return Blueprints;
}());
var blueprints = new Blueprints();
export default blueprints;
//# sourceMappingURL=Blueprints.js.map