'use strict';

var _constants = require('../constants');

var _utils = require('../utils');

var _sendFactory = require('./send-factory');

var _sendFactory2 = _interopRequireDefault(_sendFactory);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}

function connect(scope) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$targetOrigin = options.targetOrigin,
        targetOrigin = _options$targetOrigin === undefined ? '*' : _options$targetOrigin,
        _options$connectionMa = options.connectionMaxTimeout,
        connectionMaxTimeout = _options$connectionMa === undefined ? _constants.deafultConnectionMaxTimeout : _options$connectionMa,
        _options$messageMaxTi = options.messageMaxTimeout,
        messageMaxTimeout = _options$messageMaxTi === undefined ? _constants.deafultMessageMaxTimeout : _options$messageMaxTi;


    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            reject(new Error('max timeout of ' + connectionMaxTimeout + 'ms exceeded'));
        }, connectionMaxTimeout);

        var channel = new window.MessageChannel();

        channel.port1.onmessage = function(e) {
            if (e.data === _constants.connectionSuccessMsg) {
                return resolve((0, _sendFactory2.default)(channel.port1, {
                    messageMaxTimeout: messageMaxTimeout
                }));
            } else {
                reject(new Error('connection could not establise'));
            }
        };

        var connectionMessage = (0, _utils.constructConnectionMessage)(scope);
        window.parent.postMessage(connectionMessage, targetOrigin, [channel.port2]);
    });
}

module.exports = connect;