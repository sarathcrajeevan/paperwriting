import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["exitDelay", "enterDelay", "children", "content", "size", "dataHook", "disabled", "className", "fluid"];

function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}

import PropTypes from 'prop-types';
import React from 'react';
import {
    Tooltip as CoreTooltip
} from "wix-ui-core/dist/es/src/components/tooltip";
import RawText from '../Text/RawText';
import {
    st,
    classes
} from './Tooltip.st.css';
import {
    dataHooks,
    TIMEOUT
} from './constants';
import {
    FontUpgradeContext
} from '../FontUpgrade/context';
import FontUpgrade from '../FontUpgrade';
import {
    ThemeProviderConsumerBackwardCompatible
} from '../ThemeProvider/ThemeProviderConsumerBackwardCompatible';
/**
 * Next Tooltip
 */

var Tooltip = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(Tooltip, _React$PureComponent);

    var _super = _createSuper(Tooltip);

    function Tooltip() {
        var _this;

        _classCallCheck(this, Tooltip);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(args));

        _defineProperty(_assertThisInitialized(_this), "state", {
            disabled: false
        });

        _defineProperty(_assertThisInitialized(_this), "_renderContent", function() {
            var _this$props = _this.props,
                content = _this$props.content,
                textAlign = _this$props.textAlign,
                size = _this$props.size;
            var textSize = size === 'small' ? 'tiny' : 'small';
            return /*#__PURE__*/ React.createElement(FontUpgradeContext.Consumer, null, function(_ref) {
                var isMadefor = _ref.active;
                var textWeight = size === 'small' ? 'normal' : isMadefor ? 'thin' : 'normal';
                return /*#__PURE__*/ React.createElement("div", {
                    style: {
                        textAlign: textAlign
                    }
                }, /*#__PURE__*/ React.createElement(FontUpgrade, {
                    active: !!isMadefor
                }, typeof content === 'string' ? /*#__PURE__*/ React.createElement(RawText, {
                    dataHook: dataHooks.tooltipText,
                    size: textSize,
                    weight: textWeight,
                    light: true
                }, content) : content));
            });
        });

        return _this;
    }

    _createClass(Tooltip, [{
        key: "render",
        value: function render() {
            var _this2 = this;

            var _this$props2 = this.props,
                exitDelay = _this$props2.exitDelay,
                enterDelay = _this$props2.enterDelay,
                children = _this$props2.children,
                content = _this$props2.content,
                size = _this$props2.size,
                dataHook = _this$props2.dataHook,
                disabled = _this$props2.disabled,
                className = _this$props2.className,
                fluid = _this$props2.fluid,
                rest = _objectWithoutProperties(_this$props2, _excluded);

            return /*#__PURE__*/ React.createElement(ThemeProviderConsumerBackwardCompatible, null, function(_ref2) {
                var themeClassName = _ref2.className;
                return /*#__PURE__*/ React.createElement(CoreTooltip, _extends({}, rest, {
                    "data-hook": dataHook,
                    "data-size": size,
                    className: st(classes.root, {
                        size: size
                    }, className, themeClassName),
                    content: _this2._renderContent(),
                    hideDelay: exitDelay,
                    showDelay: enterDelay,
                    disabled: disabled === undefined ? children.props && children.props.disabled : disabled,
                    showArrow: true,
                    timeout: TIMEOUT,
                    fluid: fluid
                }), children);
            });
        }
    }]);

    return Tooltip;
}(React.PureComponent);

_defineProperty(Tooltip, "displayName", 'Tooltip');

_defineProperty(Tooltip, "propTypes", {
    /** applied as data-hook HTML attribute that can be used to create driver in testing */
    dataHook: PropTypes.string,

    /** A css class to be applied to the component's root element */
    className: PropTypes.string,

    /** tooltip trigger element. Can be either string or renderable node */
    children: PropTypes.node.isRequired,

    /** tooltip content. Can be either string or renderable node */
    content: PropTypes.node,

    /** align tooltip content */
    textAlign: PropTypes.oneOf(['start', 'center']),

    /** time in milliseconds to wait before showing the tooltip */
    enterDelay: PropTypes.number,

    /**  time in milliseconds to wait before hiding the tooltip. Defaults to 0. */
    exitDelay: PropTypes.number,

    /** moves tooltip content relative to the parent by x or y */
    moveBy: PropTypes.shape({
        x: PropTypes.number,
        y: PropTypes.number
    }),

    /** Moves arrow by amount */
    moveArrowTo: PropTypes.number,

    /** tooltips content calculation relation to a dom element. Can be either:
     *  `'window', 'scrollParent', 'viewport', 'parent'`, `element` or
     * `function` based predicate i.e. (elm) =>
     *  elm.getAttribute('data-hook') === 'value'
     */
    appendTo: PropTypes.oneOfType([PropTypes.oneOf(['window', 'scrollParent', 'viewport', 'parent']), PropTypes.element, PropTypes.func]),

    /** whether to enable the flip behaviour. This behaviour is used to flip the Tooltips placement when it starts to overlap the target element. */
    flip: PropTypes.bool,

    /** whether to enable the fixed behaviour. This behaviour is used to keep the Tooltip at it's original placement even when it's being positioned outside the boundary. */
    fixed: PropTypes.bool,

    /** tooltip content container width in pixels */
    maxWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /** callback on tooltips content show event */
    onShow: PropTypes.func,

    /** callback on tooltips content hide event */
    onHide: PropTypes.func,

    /** tooltip content placement in relation to target element */
    placement: PropTypes.string,

    /** disables tooltip element trigger behaviour. If not specified, `disabled` prop of the `children` element will be used. */
    disabled: PropTypes.bool,

    /** sets size of the tooltip */
    size: PropTypes.oneOf(['small', 'medium']),

    /** establishes a relationship between tooltip element and tooltip content for a11y purposes */
    'aria-describedby': PropTypes.string,

    /** tooltips content zindex */
    zIndex: PropTypes.number,

    /** stretch root element to the width of its container. */
    fluid: PropTypes.bool
});

_defineProperty(Tooltip, "defaultProps", {
    content: '',
    appendTo: 'window',
    placement: 'top',
    enterDelay: 0,
    exitDelay: 0,
    maxWidth: 204,
    flip: true,
    fixed: false,
    textAlign: 'start',
    size: 'medium',
    zIndex: 6000
});

export default Tooltip;