import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["dataHook", "animate", "theme", "className"];

function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}

import React from 'react';
import {
    Popover as CorePopover
} from "wix-ui-core/dist/es/src/components/popover";
import {
    buildChildrenObject
} from "wix-ui-core/dist/es/src/utils";
import requestAnimationFramePolyfill from '../utils/request-animation-frame';
import PropTypes from 'prop-types';
import {
    st,
    classes
} from './Popover.st.css';
import {
    FontUpgradeContext
} from '../FontUpgrade/context';
import FontUpgrade from '../FontUpgrade';
import {
    ThemeProviderConsumerBackwardCompatible
} from '../ThemeProvider/ThemeProviderConsumerBackwardCompatible';
import {
    placements
} from './constants';
export {
    placements
};
/**
 *  This has been added in order to fix jsdom not having requestAnimation frame
 *  installed. Jest by default has this polyfilled, but mocha fails on it.
 *  Decided with Shlomi to get rid of this on next major version 7, where we will support
 *  only jest.
 */

if (process.env.NODE_ENV === 'test') {
    requestAnimationFramePolyfill.install();
}

var ANIMATION_ENTER = 150;
var ANIMATION_EXIT = 100;

var ContentElement = function ContentElement(_ref) {
    var children = _ref.children;
    return /*#__PURE__*/ React.createElement(FontUpgradeContext.Consumer, null, function(_ref2) {
        var active = _ref2.active;
        return /*#__PURE__*/ React.createElement(FontUpgrade, {
            active: !!active
        }, /*#__PURE__*/ React.createElement(CorePopover.Content, {
            children: children
        }));
    });
};

ContentElement.displayName = 'Popover.Content';

var Popover = /*#__PURE__*/ function(_React$Component) {
    _inherits(Popover, _React$Component);

    var _super = _createSuper(Popover);

    function Popover() {
        _classCallCheck(this, Popover);

        return _super.apply(this, arguments);
    }

    _createClass(Popover, [{
        key: "render",
        value: function render() {
            var _this$props = this.props,
                dataHook = _this$props.dataHook,
                animate = _this$props.animate,
                theme = _this$props.theme,
                className = _this$props.className,
                rest = _objectWithoutProperties(_this$props, _excluded);

            var timeout = animate ? {
                enter: ANIMATION_ENTER,
                exit: ANIMATION_EXIT
            } : undefined;
            return /*#__PURE__*/ React.createElement(ThemeProviderConsumerBackwardCompatible, null, function(_ref3) {
                var themeClassName = _ref3.className;
                return /*#__PURE__*/ React.createElement(CorePopover, _extends({
                    disableClickOutsideWhenClosed: true,
                    timeout: timeout,
                    "data-hook": dataHook
                }, rest, {
                    className: st(classes.root, {
                        theme: theme
                    }, className, themeClassName)
                }));
            });
        }
    }]);

    return Popover;
}(React.Component);

_defineProperty(Popover, "displayName", 'Popover');

_defineProperty(Popover, "Element", CorePopover.Element);

_defineProperty(Popover, "Content", ContentElement);

_defineProperty(Popover, "propTypes", {
    /** The Popover's placement:
     *  * auto-start
     *  * auto
     *  * auto-end
     *  * top-start
     *  * top
     *  * top-end
     *  * right-start
     *  * right
     *  * right-end
     *  * bottom-end
     *  * bottom
     *  * bottom-start
     *  * left-end
     *  * left
     *  * left-start
     */
    placement: PropTypes.oneOf(placements),

    /** Is the content shown or not */
    shown: PropTypes.bool,

    /** Enables calculations in relation to a dom element */
    appendTo: PropTypes.oneOf(['window', 'scrollParent', 'parent', 'viewport']),

    /** custom classname */
    className: PropTypes.string,

    /** the classname to be passed to the popover's content container */
    contentClassName: PropTypes.string,

    /** Custom arrow element */
    customArrow: PropTypes.func,

    /** Breaking change: When true - onClickOutside will be called only when popover content is shown */
    disableClickOutsideWhenClosed: PropTypes.bool,

    /** popovers content is set to minnimum width of trigger element, but it can expand up to the value of maxWidth. */
    dynamicWidth: PropTypes.bool,

    /** Clicking on elements with this excluded class will will not trigger onClickOutside callback */
    excludeClass: PropTypes.string,

    /**
     * Whether to enable the fixed behaviour. This behaviour is used to keep the `<Popover/>` at it's
     * original placement even when it's being positioned outside the boundary.
     */
    fixed: PropTypes.bool,

    /**
     * Whether to enable the flip behaviour. This behaviour is used to flip the `<Popover/>`'s placement
     * when it starts to overlap the target element (`<Popover.Element/>`).
     */
    flip: PropTypes.bool,

    /* stretch trigger element to the width of its container. */
    fluid: PropTypes.bool,

    /** Hide Delay in ms */
    hideDelay: PropTypes.number,

    /** Id */
    id: PropTypes.string,

    /**
     * popover content maxWidth value
     * - `number` value which converts to css with `px`
     * - `string` value that contains `px`
     */
    maxWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * popover content minWidth value
     * - `number` value which converts to css with `px`
     * - `string` value that contains `px`
     */
    minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /** Moves arrow by amount */
    moveArrowTo: PropTypes.number,

    /** Moves popover relative to the parent */
    moveBy: PropTypes.shape({
        x: PropTypes.number,
        y: PropTypes.number
    }),

    /** onClick on the component */
    onClick: PropTypes.func,

    /** Provides callback to invoke when clicked outside of the popover */
    onClickOutside: PropTypes.func,

    /** onKeyDown on the target component */
    onKeyDown: PropTypes.func,

    /** onMouseEnter on the component */
    onMouseEnter: PropTypes.func,

    /** onMouseLeave on the component */
    onMouseLeave: PropTypes.func,

    /** target element role value */
    role: PropTypes.string,

    /** Show show arrow from the content */
    showArrow: PropTypes.bool,

    /** Show Delay in ms */
    showDelay: PropTypes.number,

    /** Inline style */
    style: PropTypes.object,

    /** Animation timer */
    timeout: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
        enter: PropTypes.number,
        exit: PropTypes.number
    })]),

    /**
     * popover content width value
     * - `number` value which converts to css with `px`
     * - `string` value that contains `px`
     */
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /** popover z-index */
    zIndex: PropTypes.number,

    /** Applied as data-hook HTML attribute that can be used in the tests */
    dataHook: PropTypes.string,

    /** Adds enter and exit animation */
    animate: PropTypes.bool,

    /** The theme of the popover */
    theme: PropTypes.oneOf(['dark', 'light']),
    children: function children(props, propName) {
        var childrenArr = React.Children.toArray(props[propName]);
        var childrenObj = buildChildrenObject(childrenArr, {
            Element: null,
            Content: null
        });

        if (!childrenObj.Element) {
            return new Error('Invalid children provided, <Popover.Element/> must be provided');
        }

        if (!childrenObj.Content) {
            return new Error('Invalid children provided, <Popover.Content/> must be provided');
        }

        return childrenArr.reduce(function(err, child) {
            if (!err && child.type.displayName !== 'Popover.Element' && child.type.displayName !== 'Popover.Content') {
                return new Error("Invalid children provided, unknown child <".concat(child.type.displayName || child.type, "/> supplied"));
            }

            return err;
        }, false);
    }
});

_defineProperty(Popover, "defaultProps", {
    appendTo: 'parent',
    animate: false
});

export default Popover;