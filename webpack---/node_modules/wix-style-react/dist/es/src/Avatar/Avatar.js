import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["size", "presence", "indication", "color", "customIndication", "onIndicationClick", "dataHook", "className", "shape", "text", "placeholder", "name", "onClick", "showIndicationOnHover", "loading"];

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}

function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}

function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}

import React from 'react';
import PropTypes from 'prop-types';
import IconButton from '../IconButton';
import {
    avatarShapes,
    dataHooks
} from './constants';
import {
    Avatar as CoreAvatar
} from "wix-ui-core/dist/es/src/components/avatar";
import Loader from '../Loader';
import {
    placeholderSVGs
} from './assets';
import {
    st,
    classes
} from './Avatar.st.css';
import {
    capitalize
} from '../utils/cssClassUtils';
import stringToColor from './string-to-color';
import {
    FontUpgradeContext
} from '../FontUpgrade/context';

var getSizeNumber = function getSizeNumber(size) {
    return Number(size.substring(4));
};

var defaultSize = 48;
var minSmallIconButton = 60;
/**
 * Avatar is a type of element that visually represents a user, either as an image, name initials or placeholder icon.
 */

var Avatar = /*#__PURE__*/ function(_React$PureComponent) {
    _inherits(Avatar, _React$PureComponent);

    var _super = _createSuper(Avatar);

    function Avatar(props) {
        var _this;

        _classCallCheck(this, Avatar);

        _this = _super.call(this, props);

        _defineProperty(_assertThisInitialized(_this), "_onMouseEnter", function() {
            if (_this.props.showIndicationOnHover) {
                _this.setState({
                    showIndication: true
                });
            }
        });

        _defineProperty(_assertThisInitialized(_this), "_onMouseLeave", function() {
            if (_this.props.showIndicationOnHover) {
                _this.setState({
                    fadeIndication: true
                });

                setTimeout(function() {
                    return _this.setState({
                        fadeIndication: false,
                        showIndication: false
                    });
                }, 150);
            }
        });

        _this.state = {
            fadeIndication: false,
            showIndication: false
        };
        return _this;
    }

    _createClass(Avatar, [{
        key: "render",
        value: function render() {
            var _this2 = this;

            var _this$props = this.props,
                size = _this$props.size,
                presence = _this$props.presence,
                indication = _this$props.indication,
                color = _this$props.color,
                customIndication = _this$props.customIndication,
                onIndicationClick = _this$props.onIndicationClick,
                dataHook = _this$props.dataHook,
                className = _this$props.className,
                shape = _this$props.shape,
                text = _this$props.text,
                placeholder = _this$props.placeholder,
                name = _this$props.name,
                onClick = _this$props.onClick,
                showIndicationOnHover = _this$props.showIndicationOnHover,
                loading = _this$props.loading,
                rest = _objectWithoutProperties(_this$props, _excluded);

            var _this$state = this.state,
                fadeIndication = _this$state.fadeIndication,
                showIndication = _this$state.showIndication;
            var calculatedColor = color || stringToColor(text || name); // if color is provided as a prop use it, otherwise, generate a color based on the text

            var sizeNumber = getSizeNumber(size);
            var renderOnHover = !showIndicationOnHover || showIndication;
            var indicationConstraints = renderOnHover && sizeNumber >= defaultSize;
            var renderIndication = indicationConstraints && !customIndication && indication;
            var renderCustomIndication = indicationConstraints && customIndication;
            var renderLoader = loading && sizeNumber >= defaultSize;
            return /*#__PURE__*/ React.createElement("div", {
                "data-hook": dataHook,
                className: st(className, classes.root)
            }, /*#__PURE__*/ React.createElement(FontUpgradeContext.Consumer, null, function(_ref) {
                var active = _ref.active;
                return /*#__PURE__*/ React.createElement("div", {
                    "data-hook": dataHooks.avatarWSR,
                    onMouseEnter: _this2._onMouseEnter,
                    onMouseLeave: _this2._onMouseLeave,
                    className: st(classes.avatarContainer, {
                        shape: shape,
                        size: size,
                        indication: Boolean(customIndication || indication),
                        presence: Boolean(presence),
                        presenceType: presence,
                        clickable: !!onClick,
                        fade: fadeIndication,
                        hasText: !!text
                    }),
                    "data-madefor": active
                }, /*#__PURE__*/ React.createElement("div", {
                    className: classes.coreAvatar
                }, /*#__PURE__*/ React.createElement(CoreAvatar, _extends({}, _objectSpread(_objectSpread({}, rest), {}, {
                    placeholder: placeholder ? placeholder : /*#__PURE__*/ React.createElement(AvatarDefaultPlaceholder, {
                        shape: shape,
                        size: size
                    }),
                    text: text,
                    name: name,
                    onClick: onClick,
                    initialsLimit: sizeNumber < 30 ? 1 : undefined,
                    'data-hook': dataHooks.avatarCore
                }), {
                    className: st(classes.avatar, classes["color".concat(capitalize(calculatedColor))])
                }))), renderLoader && [ /*#__PURE__*/ React.createElement("div", {
                    key: "overlay",
                    className: st(classes.loaderContainer, classes.overlay)
                }), /*#__PURE__*/ React.createElement("div", {
                    key: "loader",
                    className: st(classes.loaderContainer, classes.loader)
                }, /*#__PURE__*/ React.createElement(Loader, {
                    dataHook: dataHooks.loader,
                    size: "tiny"
                }))], presence && /*#__PURE__*/ React.createElement("div", {
                    className: classes.presence
                }), renderIndication && /*#__PURE__*/ React.createElement("div", {
                    className: classes.indication
                }, /*#__PURE__*/ React.createElement(IconButton, {
                    className: classes.iconButtonShadow,
                    dataHook: dataHooks.indication,
                    onClick: onIndicationClick,
                    skin: "inverted",
                    shape: shape,
                    size: sizeNumber > minSmallIconButton ? 'small' : 'tiny'
                }, indication)), renderCustomIndication && /*#__PURE__*/ React.createElement("div", {
                    className: classes.indication,
                    "data-hook": dataHooks.customIndication,
                    onClick: onIndicationClick
                }, customIndication));
            }));
        }
    }]);

    return Avatar;
}(React.PureComponent);

var AvatarDefaultPlaceholder = function AvatarDefaultPlaceholder(_ref2) {
    var shape = _ref2.shape,
        size = _ref2.size;
    return shape !== avatarShapes.square ? placeholderSVGs[size][avatarShapes.circle] : placeholderSVGs[size][avatarShapes.square];
};

var CoreAvatarPropTypes = {
    /**
     * Defines a name of the avatar user. Text initials will be generated from the name.
     * The name value will be used as default value for HTML title and `aria-label` attributes.
     * And also as default value for the image's alt attribute if `imgProps` is provided.
     */
    name: PropTypes.string,

    /** Defines a text to render as a content instead of a given `name`. */
    text: PropTypes.string,

    /**
     * Accept any content to render as a content placeholder. This placeholder will be displayed if no text, name or imgProps are provided.<br>
     * By default use a generic avatar user icon.
     */
    placeholder: PropTypes.node,

    /** Accept all common `<img>` tag properties. */
    imgProps: PropTypes.object,

    /** Defines a string that labels the current element in case where text label is not visible on the screen. */
    ariaLabel: PropTypes.string,

    /** Defines a standard HTML title attribute value. Applies it to the root element. */
    title: PropTypes.string,

    /** Defines a click event handler. When defined, component will be clickable and will have a pointer cursor on hover. */
    onClick: PropTypes.func
};
Avatar.displayName = 'Avatar';
Avatar.propTypes = _objectSpread(_objectSpread({}, CoreAvatarPropTypes), {}, {
    /** Controls the size of an avatar. */
    size: PropTypes.oneOf(['size90', 'size72', 'size60', 'size48', 'size36', 'size30', 'size24', 'size18']),

    /**
     * Controls the background color of the avatar. If not provided,
     * color is determined by the provided text or name so that each name will receive a different color.
     */
    color: PropTypes.oneOf(['A1', 'A2', 'A3', 'A4', 'A5', 'A6']),

    /** Controls the shape of the image. */
    shape: PropTypes.oneOf(['circle', 'square']),

    /** Specifies a CSS class name to be appended to the component’s root element. */
    className: PropTypes.string,

    /** Applies a data-hook HTML attribute that can be used in the tests. */
    dataHook: PropTypes.string,

    /** Sets the presence status of an avatar. */
    presence: PropTypes.oneOf(['online', 'offline', 'busy']),

    /** Accept any content to render as an indication item. */
    indication: PropTypes.node,

    /**
     * Accept any content to render as a custom indication item. This indication element will not be wrapped by an IconButton.
     * It could be rendered in other shapes (such as square).
     * */
    customIndication: PropTypes.node,

    /** Defines a callback function which is called every time indication element is clicked. */
    onIndicationClick: PropTypes.func,

    /** Shows indication element on hover. */
    showIndicationOnHover: PropTypes.bool,

    /** Shows a loader on top of an avatar. */
    loading: PropTypes.bool
});
Avatar.defaultProps = {
    size: 'size48',
    shape: 'circle',
    showIndicationOnHover: false
};
export default Avatar;