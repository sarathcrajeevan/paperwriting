import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["skin", "underline", "weight", "size", "children", "className", "dataHook", "fluid", "ellipsis", "showTooltip", "tooltipProps", "ariaLabel", "ariaLabelledBy", "ariaHaspopup", "ariaExpanded"];

function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}

import React, {
    PureComponent
} from 'react';
import {
    ButtonNext
} from "wix-ui-core/dist/es/src/components/button-next";
import Ellipsis from '../common/Ellipsis';
import {
    TooltipCommonProps
} from '../common/PropTypes/TooltipCommon';
import PropTypes from 'prop-types';
import {
    generateDataAttr
} from '../utils/generateDataAttr';
import {
    st,
    classes
} from './TextButton.st.css';

var TextButton = /*#__PURE__*/ function(_PureComponent) {
    _inherits(TextButton, _PureComponent);

    var _super = _createSuper(TextButton);

    function TextButton() {
        _classCallCheck(this, TextButton);

        return _super.apply(this, arguments);
    }

    _createClass(TextButton, [{
        key: "render",
        value: function render() {
            var _this = this;

            var _this$props = this.props,
                skin = _this$props.skin,
                underline = _this$props.underline,
                weight = _this$props.weight,
                size = _this$props.size,
                children = _this$props.children,
                className = _this$props.className,
                dataHook = _this$props.dataHook,
                fluid = _this$props.fluid,
                ellipsis = _this$props.ellipsis,
                showTooltip = _this$props.showTooltip,
                tooltipProps = _this$props.tooltipProps,
                ariaLabel = _this$props.ariaLabel,
                ariaLabelledBy = _this$props.ariaLabelledBy,
                ariaHaspopup = _this$props.ariaHaspopup,
                ariaExpanded = _this$props.ariaExpanded,
                rest = _objectWithoutProperties(_this$props, _excluded);

            return /*#__PURE__*/ React.createElement(Ellipsis, _extends({
                ellipsis: ellipsis,
                showTooltip: showTooltip
            }, tooltipProps, {
                render: function render(_ref) {
                    var ref = _ref.ref,
                        ellipsisClasses = _ref.ellipsisClasses;
                    return /*#__PURE__*/ React.createElement(ButtonNext, _extends({}, rest, generateDataAttr(_this.props, ['skin', 'size', 'weight', 'underline']), {
                        className: st(classes.root, {
                            skin: skin,
                            underline: underline,
                            weight: weight,
                            size: size,
                            fluid: fluid,
                            ellipsis: ellipsis
                        }, className),
                        "data-hook": dataHook,
                        contentClassName: ellipsisClasses(),
                        contentRef: ref,
                        "aria-label": ariaLabel,
                        "aria-labelledby": ariaLabelledBy,
                        "aria-haspopup": ariaHaspopup,
                        "aria-expanded": ariaExpanded
                    }), children);
                }
            }));
        }
    }]);

    return TextButton;
}(PureComponent);

_defineProperty(TextButton, "displayName", 'TextButton');

_defineProperty(TextButton, "propTypes", {
    /** render as some other component or DOM tag */
    as: PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.string]),

    /** Additional classes */
    className: PropTypes.string,

    /** Skins of TextButton content */
    skin: PropTypes.oneOf(['standard', 'light', 'premium', 'dark', 'destructive']),

    /** Underline of TextButton content */
    underline: PropTypes.oneOf(['none', 'onHover', 'always']),

    /** Weight of TextButton content */
    weight: PropTypes.oneOf(['thin', 'normal']),

    /** Size of TextButton content */
    size: PropTypes.oneOf(['tiny', 'small', 'medium']),

    /** Click event handler  */
    onClick: PropTypes.func,

    /** Element based icon (svg, image etc.) */
    suffixIcon: PropTypes.element,

    /** Element based icon (svg, image etc.) */
    prefixIcon: PropTypes.element,

    /** Applies disabled styles */
    disabled: PropTypes.bool,

    /** String based node */
    children: PropTypes.node,

    /** String based data hook */
    dataHook: PropTypes.string,

    /** Stretches text button to its container width */
    fluid: PropTypes.bool,

    /** should the text get ellipsized with tooltip, or should it get broken into lines when it reaches the end of its container */
    ellipsis: PropTypes.bool,

    /** True by default, set it to false in order to show ellipsis without a tooltip. */
    showTooltip: PropTypes.bool,

    /** Props that modify the Tooltip created from text ellipsis */
    tooltipProps: PropTypes.shape(TooltipCommonProps),

    /** Defines a string value that labels the button element */
    ariaLabel: PropTypes.string,

    /** Identifies the element that labels the button element */
    ariaLabelledBy: PropTypes.string,

    /** Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element. */
    ariaHaspopup: PropTypes.string,

    /** Indicates to screen reader users whether the collapsable content below is in the expanded or in the collapsed state */
    ariaExpanded: PropTypes.bool
});

_defineProperty(TextButton, "defaultProps", {
    skin: 'standard',
    underline: 'none',
    weight: 'thin',
    size: 'medium',
    disabled: false,
    fluid: false,
    tooltipProps: {}
});

export default TextButton;