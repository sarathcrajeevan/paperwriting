"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createModifiers = void 0;
var tslib_1 = require("tslib");
var getUnit = function(value) {
    if (typeof value === 'string') {
        return value;
    }
    return value + "px";
};
var calculateOffset = function(_a) {
    var moveBy = _a.moveBy,
        _b = _a.placement,
        placement = _b === void 0 ? '' : _b;
    /*
     * For `right` and `left` placements, we need to flip the `x` and `y` values as Popper.JS will use
     * the first value for the main axis. As per Popper.js docs:
     *
     *   if the placement is top or bottom, the length will be the width. In case of left or right, it
     *   will be the height.
     *
     */
    if (placement.includes('right') || placement.includes('left')) {
        return (moveBy ? moveBy.y : 0) + "px, " + (moveBy ? moveBy.x : 0) + "px";
    }
    return (moveBy ? moveBy.x : 0) + "px, " + (moveBy ? moveBy.y : 0) + "px";
};
var resolveWidth = function(_a) {
    var width = _a.width,
        minWidth = _a.minWidth,
        dynamicWidth = _a.dynamicWidth,
        referenceWidth = _a.referenceWidth;
    return {
        minWidth: dynamicWidth ? referenceWidth + "px" : getUnit(minWidth),
        width: width || 'auto',
    };
};
exports.createModifiers = function(_a) {
    var width = _a.width,
        moveBy = _a.moveBy,
        appendTo = _a.appendTo,
        shouldAnimate = _a.shouldAnimate,
        flip = _a.flip,
        fixed = _a.fixed,
        placement = _a.placement,
        isTestEnv = _a.isTestEnv,
        minWidth = _a.minWidth,
        dynamicWidth = _a.dynamicWidth;
    var preventOverflow = !fixed;
    var modifiers = {
        offset: {
            offset: calculateOffset({
                moveBy: moveBy,
                placement: placement
            }),
        },
        computeStyle: {
            gpuAcceleration: !shouldAnimate,
        },
        flip: {
            enabled: typeof flip !== 'undefined' ? flip : !moveBy,
        },
        preventOverflow: {
            enabled: preventOverflow,
        },
        hide: {
            enabled: preventOverflow,
        },
    };
    if (dynamicWidth || minWidth || width) {
        modifiers.setPopperWidth = {
            enabled: true,
            order: 840,
            fn: function(data) {
                var referenceWidth = data.offsets.reference.width;
                data.styles = tslib_1.__assign(tslib_1.__assign({}, data.styles), resolveWidth({
                    width: width,
                    referenceWidth: referenceWidth,
                    minWidth: minWidth,
                    dynamicWidth: dynamicWidth,
                }));
                return data;
            },
        };
    }
    if (isTestEnv) {
        modifiers.computeStyle = {
            enabled: false
        };
    }
    if (appendTo) {
        modifiers.preventOverflow = tslib_1.__assign(tslib_1.__assign({}, modifiers.preventOverflow), {
            boundariesElement: appendTo
        });
    }
    return modifiers;
};
//# sourceMappingURL=modifiers.js.map