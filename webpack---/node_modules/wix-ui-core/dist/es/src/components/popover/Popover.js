import {
    __assign,
    __extends,
    __spreadArrays
} from "tslib";
import * as React from 'react';
import {
    ClickOutside
} from '../click-outside';
import {
    Manager,
    Reference,
    Popper
} from 'react-popper';
import {
    CSSTransition
} from 'react-transition-group';
import {
    Portal
} from 'react-portal';
import {
    st,
    classes
} from './Popover.st.css';
import {
    createModifiers
} from './modifiers';
import {
    filterDataProps
} from '../../utils/filter-data-props';
var uniqueId = require('lodash/uniqueId');
import {
    buildChildrenObject,
    createComponentThatRendersItsChildren,
} from '../../utils';
import {
    PopoverContext
} from './PopoverContext';
import {
    popoverTestUtils
} from './helpers';
import {
    getAppendToElement
} from './utils/getAppendToElement';
import classNames from 'classnames';
// This is here and not in the test setup because we don't want consumers to need to run it as well
var testId;
var isTestEnv = process.env.NODE_ENV === 'test';
if (isTestEnv && typeof document !== 'undefined' && !document.createRange) {
    popoverTestUtils.createRange();
}
var attachClasses = function(node, classnames) {
    var _a;
    return node && (_a = node.classList).add.apply(_a, classnames.split(' '));
};
var detachClasses = function(node, classnames) {
    var _a;
    return node && (_a = node.classList).remove.apply(_a, classnames.split(' '));
};
var shouldAnimatePopover = function(_a) {
    var timeout = _a.timeout;
    if (typeof timeout === 'object') {
        var enter = timeout.enter,
            exit = timeout.exit;
        return (typeof enter !== 'undefined' &&
            typeof exit !== 'undefined' &&
            (enter > 0 || exit > 0));
    }
    return !!timeout;
};
var getArrowShift = function(shift, direction) {
    if (!shift && !isTestEnv) {
        return {};
    }
    if (direction.startsWith('top') || direction.startsWith('bottom')) {
        return {
            left: shift + "px"
        };
    }
    if (direction.startsWith('left') || direction.startsWith('right')) {
        return {
            top: shift + "px"
        };
    }
    // Arrow can't be shifted when using automatic positioning
    return {};
};
/**
 * Popover
 */
var Popover = /** @class */ (function(_super) {
    __extends(Popover, _super);

    function Popover(props) {
        var _this = _super.call(this, props) || this;
        _this.targetRef = null;
        _this.portalNode = null;
        _this.appendToNode = null;
        _this.clickOutsideRef = null;
        _this.popperScheduleUpdate = null;
        // Timer instances for the show/hide delays
        _this._hideTimeout = null;
        _this._showTimeout = null;
        _this._handleClickOutside = function(event) {
            var _a = _this.props,
                onClickOutsideCallback = _a.onClickOutside,
                shown = _a.shown,
                disableClickOutsideWhenClosed = _a.disableClickOutsideWhenClosed;
            if (onClickOutsideCallback && !(disableClickOutsideWhenClosed && !shown)) {
                onClickOutsideCallback(event);
            }
        };
        _this._onKeyDown = function(e) {
            var onEscPress = _this.props.onEscPress;
            if (onEscPress && e.key === 'Escape') {
                onEscPress(e);
            }
        };
        /**
         * Checks to see if the focused element is outside the Popover content
         */
        _this._onDocumentKeyUp = function(e) {
            var onTabOut = _this.props.onTabOut;
            if (typeof document !== 'undefined' &&
                _this.popoverContentRef.current &&
                !_this.popoverContentRef.current.contains(document.activeElement)) {
                onTabOut(e);
            }
        };
        _this.state = {
            isMounted: false,
            shown: props.shown || false,
        };
        if (isTestEnv) {
            testId = popoverTestUtils.generateId();
        }
        _this.clickOutsideRef = React.createRef();
        _this.popoverContentRef = React.createRef();
        _this.clickOutsideClass = uniqueId('clickOutside');
        _this.contentHook = "popover-content-" + (props['data-hook'] || '') + "-" + testId;
        return _this;
    }
    Popover.prototype.focus = function() {
        if (this.popoverContentRef.current) {
            this.popoverContentRef.current.focus();
        }
    };
    Popover.prototype.getPopperContentStructure = function(childrenObject) {
        var _this = this;
        var shown = this.state.shown;
        var _a = this.props,
            moveBy = _a.moveBy,
            appendTo = _a.appendTo,
            placement = _a.placement,
            showArrow = _a.showArrow,
            moveArrowTo = _a.moveArrowTo,
            flip = _a.flip,
            fixed = _a.fixed,
            customArrow = _a.customArrow,
            role = _a.role,
            id = _a.id,
            zIndex = _a.zIndex,
            minWidth = _a.minWidth,
            maxWidth = _a.maxWidth,
            width = _a.width,
            dynamicWidth = _a.dynamicWidth,
            _b = _a.excludeClass,
            excludeClass = _b === void 0 ? this.clickOutsideClass : _b,
            contentClassName = _a.contentClassName,
            onEscPress = _a.onEscPress,
            tabIndex = _a.tabIndex,
            ariaLabel = _a["aria-label"],
            ariaLabelledby = _a["aria-labelledby"],
            ariaDescribedBy = _a["aria-describedby"];
        var shouldAnimate = shouldAnimatePopover(this.props);
        var modifiers = createModifiers({
            minWidth: minWidth,
            width: width,
            dynamicWidth: dynamicWidth,
            moveBy: moveBy,
            appendTo: appendTo,
            shouldAnimate: shouldAnimate,
            flip: flip,
            placement: placement,
            fixed: fixed,
            isTestEnv: isTestEnv,
        });
        var popper = (React.createElement(Popper, {
            modifiers: modifiers,
            placement: placement
        }, function(_a) {
            var ref = _a.ref,
                popperStyles = _a.style,
                popperPlacement = _a.placement,
                arrowProps = _a.arrowProps,
                scheduleUpdate = _a.scheduleUpdate;
            _this.popperScheduleUpdate = scheduleUpdate;
            return (React.createElement(PopoverContext.Consumer, null, function(_a) {
                var _b;
                var excludeClickOutsideClasses = _a.excludeClickOutsideClasses;
                return (React.createElement("div", {
                        ref: ref,
                        "data-hook": "popover-content",
                        "data-content-element": _this.contentHook,
                        style: __assign(__assign({}, popperStyles), {
                            zIndex: zIndex,
                            maxWidth: maxWidth
                        }),
                        "data-placement": popperPlacement || placement,
                        className: classNames.apply(void 0, __spreadArrays([classes.popover,
                            _this.clickOutsideClass,
                            contentClassName, (_b = {},
                                _b[classes.withArrow] = showArrow,
                                _b[classes.popoverContent] = !showArrow,
                                _b)
                        ], excludeClickOutsideClasses))
                    },
                    showArrow &&
                    _this.renderArrow(arrowProps, moveArrowTo, popperPlacement || placement, customArrow),
                    React.createElement("div", {
                            key: "popover-content",
                            id: id,
                            role: role,
                            tabIndex: tabIndex,
                            ref: _this.popoverContentRef,
                            className: showArrow ? classes.popoverContent : '',
                            onKeyDown: shown && onEscPress ? _this._onKeyDown : undefined,
                            "aria-label": ariaLabel,
                            "aria-labelledby": ariaLabelledby,
                            "aria-describedby": ariaDescribedBy
                        },
                        React.createElement(PopoverContext.Provider, {
                            value: {
                                excludeClickOutsideClasses: __spreadArrays([
                                    excludeClass
                                ], excludeClickOutsideClasses),
                            }
                        }, childrenObject.Content))));
            }));
        }));
        return this.wrapWithAnimations(popper);
    };
    Popover.prototype.applyStylesToPortaledNode = function() {
        var shown = this.state.shown;
        var shouldAnimate = shouldAnimatePopover(this.props);
        if (shouldAnimate || shown) {
            attachClasses(this.portalNode, this.portalClasses);
        } else {
            detachClasses(this.portalNode, this.portalClasses);
        }
    };
    Popover.prototype.wrapWithAnimations = function(popper) {
        var _this = this;
        var timeout = this.props.timeout;
        var shown = this.state.shown;
        var shouldAnimate = shouldAnimatePopover(this.props);
        return shouldAnimate ? (React.createElement(CSSTransition, { in: shown,
            timeout: timeout,
            unmountOnExit: true,
            classNames: {
                enter: classes['popoverAnimation-enter'],
                enterActive: classes['popoverAnimation-enter-active'],
                exit: classes['popoverAnimation-exit'],
                exitActive: classes['popoverAnimation-exit-active'],
            },
            onExited: function() {
                return detachClasses(_this.portalNode, _this.portalClasses);
            }
        }, popper)) : (popper);
    };
    Popover.prototype.renderPopperContent = function(childrenObject) {
        var popper = this.getPopperContentStructure(childrenObject);
        return this.portalNode ? (React.createElement(Portal, {
            node: this.portalNode
        }, popper)) : (popper);
    };
    Popover.prototype.renderArrow = function(arrowProps, moveArrowTo, placement, customArrow) {
        var commonProps = {
            ref: arrowProps.ref,
            key: 'popover-arrow',
            'data-hook': 'popover-arrow',
            style: __assign(__assign({}, arrowProps.style), getArrowShift(moveArrowTo, placement)),
        };
        if (customArrow) {
            return customArrow(placement, commonProps);
        }
        return React.createElement("div", __assign({}, commonProps, {
            className: classes.arrow
        }));
    };
    Popover.prototype.componentDidMount = function() {
        var _a = this.props,
            shown = _a.shown,
            onTabOut = _a.onTabOut;
        this.initAppendToNode();
        if (onTabOut && shown) {
            this._setBlurByKeyboardListener();
        }
        this.setState({
            isMounted: true
        });
    };
    Popover.prototype._setBlurByKeyboardListener = function() {
        if (typeof document !== 'undefined') {
            document.addEventListener('keyup', this._onDocumentKeyUp, true);
        }
    };
    Popover.prototype._removeBlurListener = function() {
        if (typeof document !== 'undefined') {
            document.removeEventListener('keyup', this._onDocumentKeyUp, true);
        }
    };
    Popover.prototype.initAppendToNode = function() {
        var appendTo = this.props.appendTo;
        this.appendToNode = getAppendToElement(appendTo, this.targetRef);
        if (this.appendToNode) {
            this.portalNode = document.createElement('div');
            this.portalNode.setAttribute('data-hook', 'popover-portal');
            /**
             * reset overlay wrapping layer
             * so that styles from copied classnames
             * won't break the overlay:
             * - content is position relative to body
             * - overlay layer is hidden
             */
            Object.assign(this.portalNode.style, {
                position: 'static',
                top: 0,
                left: 0,
                width: 0,
                height: 0,
            });
            this.appendToNode.appendChild(this.portalNode);
        }
    };
    Popover.prototype.hidePopover = function() {
        var _this = this;
        var isMounted = this.state.isMounted;
        var _a = this.props,
            hideDelay = _a.hideDelay,
            onTabOut = _a.onTabOut;
        if (!isMounted || this._hideTimeout) {
            return;
        }
        if (this._showTimeout) {
            clearTimeout(this._showTimeout);
            this._showTimeout = null;
        }
        if (onTabOut) {
            this._removeBlurListener();
        }
        if (hideDelay) {
            this._hideTimeout = setTimeout(function() {
                _this.setState({
                    shown: false
                });
            }, hideDelay);
        } else {
            this.setState({
                shown: false
            });
        }
    };
    Popover.prototype.showPopover = function() {
        var _this = this;
        var isMounted = this.state.isMounted;
        var _a = this.props,
            showDelay = _a.showDelay,
            onTabOut = _a.onTabOut;
        if (!isMounted || this._showTimeout) {
            return;
        }
        if (this._hideTimeout) {
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }
        if (onTabOut) {
            this._setBlurByKeyboardListener();
        }
        if (showDelay) {
            this._showTimeout = setTimeout(function() {
                _this.setState({
                    shown: true
                });
            }, showDelay);
        } else {
            this.setState({
                shown: true
            });
        }
    };
    Popover.prototype.componentWillUnmount = function() {
        if (this.portalNode && this.appendToNode.children.length) {
            // FIXME: What if component is updated with a different appendTo? It is a far-fetched use-case,
            // but we would need to remove the portaled node, and created another one.
            this.appendToNode.removeChild(this.portalNode);
        }
        this.portalNode = null;
        if (this._hideTimeout) {
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }
        if (this._showTimeout) {
            clearTimeout(this._showTimeout);
            this._showTimeout = null;
        }
    };
    Popover.prototype.updatePosition = function() {
        if (this.popperScheduleUpdate) {
            this.popperScheduleUpdate();
        }
    };
    Popover.prototype.componentDidUpdate = function(prevProps) {
        var shown = this.props.shown;
        if (this.portalNode) {
            // Re-calculate the portal's styles
            this.portalClasses = st(classes.root, this.props.className);
            // Apply the styles to the portal
            this.applyStylesToPortaledNode();
        }
        // Update popover visibility
        if (prevProps.shown !== shown) {
            if (shown) {
                this.showPopover();
            } else {
                this.hidePopover();
            }
        } else {
            // Update popper's position
            this.updatePosition();
        }
    };
    Popover.prototype.render = function() {
        var _this = this;
        var _a = this.props,
            onMouseEnter = _a.onMouseEnter,
            onMouseLeave = _a.onMouseLeave,
            onKeyDown = _a.onKeyDown,
            onClick = _a.onClick,
            children = _a.children,
            style = _a.style,
            id = _a.id,
            excludeClass = _a.excludeClass,
            fluid = _a.fluid;
        var _b = this.state,
            isMounted = _b.isMounted,
            shown = _b.shown;
        var childrenObject = buildChildrenObject(children, {
            Element: null,
            Content: null,
        });
        var shouldAnimate = shouldAnimatePopover(this.props);
        var shouldRenderPopper = isMounted && (shouldAnimate || shown);
        return (React.createElement(Manager, null,
            React.createElement(ClickOutside, {
                    rootRef: this.clickOutsideRef,
                    onClickOutside: shown ? this._handleClickOutside : undefined,
                    excludeClass: [this.clickOutsideClass, excludeClass]
                },
                React.createElement("div", __assign({
                        ref: this.clickOutsideRef,
                        style: style,
                        "data-content-hook": this.contentHook,
                        className: st(classes.root, {
                            fluid: fluid
                        }, this.props.className),
                        onMouseEnter: onMouseEnter,
                        onMouseLeave: onMouseLeave,
                        id: id
                    }, filterDataProps(this.props)),
                    React.createElement(Reference, {
                        innerRef: function(r) {
                            return (_this.targetRef = r);
                        }
                    }, function(_a) {
                        var ref = _a.ref;
                        return (React.createElement("div", {
                            ref: ref,
                            className: classes.popoverElement,
                            "data-hook": "popover-element",
                            onClick: onClick,
                            onKeyDown: onKeyDown
                        }, childrenObject.Element));
                    }),
                    shouldRenderPopper && this.renderPopperContent(childrenObject)))));
    };
    Popover.displayName = 'Popover';
    Popover.defaultProps = {
        flip: true,
        fixed: false,
        zIndex: 1000,
    };
    Popover.Element = createComponentThatRendersItsChildren('Popover.Element');
    Popover.Content = createComponentThatRendersItsChildren('Popover.Content');
    return Popover;
}(React.Component));
export {
    Popover
};
//# sourceMappingURL=Popover.js.map