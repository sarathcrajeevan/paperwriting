import {
    __assign,
    __extends,
    __rest
} from "tslib";
import * as React from 'react';
import classNames from 'classnames';
import {
    withFocusable
} from '../../hocs/Focusable/FocusableHOC';
import {
    st,
    classes
} from './avatar.st.css';
import {
    nameToInitials
} from './util';
import {
    filterDataProps
} from '../../utils/filter-data-props';
var DEFAULT_CONTENT_TYPE = 'placeholder';
/**
 * Avatar is a type of element that visually represents a user, either as an image, placeholder or text.
 *
 * <p>There are 3 props for corresponding content types: `text`, `placeholder` and `imgProps`.
 * If more than one of these props is supplied (with `name` prop giving default value to the `text` prop),
 * then the resolved content type for display goes according to this priority: image -> text -> placeholder.
 */
var AvatarComponent = /** @class */ (function(_super) {
    __extends(AvatarComponent, _super);

    function AvatarComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            imgLoaded: false
        };
        _this.loadImg = function() {
            _this.img = new Image();
            _this.img.onload = function() {
                // don't set state after unmount
                _this.img && _this.setState({
                    imgLoaded: true
                });
            };
            _this.img.src = _this.props.imgProps.src;
        };
        _this.unloadImg = function() {
            // TODO: Is this necessary? It is taken from https://github.com/mbrevda/react-image/blob/c402ed3f5d54b88e51eca3326a1e81d964995795/src/index.js#L146
            delete _this.img.onload;
            try {
                delete _this.img.src;
            } catch (e) {
                // On Safari in Strict mode this will throw an exception,
                //  - https://github.com/mbrevda/react-image/issues/187
                // We don't need to do anything about it.
            }
            delete _this.img;
        };
        _this._handleKeyDown = function(event) {
            if (event.key === ' ' || event.key === 'Enter' || event.key === 'Space') {
                event.preventDefault();
                _this.props.onClick();
            }
        };
        return _this;
    }
    /** This is the resolved content type the consumer wants to display */
    AvatarComponent.prototype.getRequestedContentType = function(props) {
        var name = props.name,
            text = props.text,
            placeholder = props.placeholder,
            imgProps = props.imgProps;
        return imgProps && imgProps.src ?
            'image' :
            text || name ?
            'text' :
            placeholder ?
            'placeholder' :
            DEFAULT_CONTENT_TYPE;
    };
    /** This is content type that will be displayed. (If img is loading then this will be the fallback) */
    AvatarComponent.prototype.getCurrentContentType = function() {
        var requestedType = this.getRequestedContentType(this.props);
        if (requestedType === 'image' && !this.state.imgLoaded) {
            var _a = this.props,
                name_1 = _a.name,
                text = _a.text,
                placeholder = _a.placeholder;
            return text || name_1 ?
                'text' :
                placeholder ?
                'placeholder' :
                DEFAULT_CONTENT_TYPE;
        }
        return requestedType;
    };
    AvatarComponent.prototype.componentDidMount = function() {
        this.getRequestedContentType(this.props) === 'image' &&
            !this.state.imgLoaded &&
            this.loadImg();
    };
    AvatarComponent.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
        if (!nextProps.imgProps ||
            !this.props.imgProps ||
            nextProps.imgProps.src !== this.props.imgProps.src) {
            this.setState({
                imgLoaded: false
            });
            this.img && this.unloadImg();
        }
    };
    AvatarComponent.prototype.componentDidUpdate = function() {
        this.getRequestedContentType(this.props) === 'image' &&
            !this.img &&
            !this.state.imgLoaded &&
            this.loadImg();
    };
    AvatarComponent.prototype.componentWillUnmount = function() {
        this.img && this.unloadImg();
    };
    AvatarComponent.prototype.render = function() {
        var _a = this.props,
            name = _a.name,
            title = _a.title,
            ariaLabel = _a.ariaLabel,
            onClick = _a.onClick,
            focusableOnFocus = _a.focusableOnFocus,
            focusableOnBlur = _a.focusableOnBlur;
        var contentType = this.getCurrentContentType();
        var focusProps = !!onClick && {
            role: 'button',
            onFocus: focusableOnFocus,
            onBlur: focusableOnBlur,
            onKeyDown: this._handleKeyDown,
            tabIndex: 0,
        };
        return (React.createElement("div", __assign({
            "data-content-type": contentType,
            "data-img-loaded": this.state.imgLoaded,
            title: title || name,
            "aria-label": ariaLabel || name,
            onClick: onClick
        }, focusProps, {
            className: st(classes.root, {
                imgLoaded: this.state.imgLoaded,
                contentType: contentType,
            }, this.props.className)
        }, filterDataProps(this.props)), this.getContent(contentType)));
    };
    AvatarComponent.prototype.getContent = function(contentType) {
        switch (contentType) {
            case 'text':
                {
                    var _a = this.props,
                        name_2 = _a.name,
                        text = _a.text;
                    var textContent = text || nameToInitials(name_2, this.props.initialsLimit);
                    return (React.createElement("div", {
                        className: classes.content,
                        "data-hook": "text-container"
                    }, textContent));
                }
            case 'placeholder':
                {
                    var placeholder = this.props.placeholder;
                    return placeholder === null ?
                        null :
                        React.cloneElement(placeholder, {
                            className: classNames(placeholder.props.className, classes.content),
                        });
                }
            case 'image':
                {
                    var _b = this.props.imgProps,
                        alt = _b.alt,
                        className = _b.className,
                        rest = __rest(_b, ["alt", "className"]);
                    return (React.createElement("img", __assign({
                        className: classNames(classes.content, className),
                        alt: alt ? alt : this.props.name
                    }, rest)));
                }
            default:
                {
                    return null;
                }
        }
    };
    AvatarComponent.displayName = 'Avatar';
    AvatarComponent.defaultProps = {
        placeholder: null,
    };
    return AvatarComponent;
}(React.Component));
export {
    AvatarComponent
};
export var Avatar = withFocusable(AvatarComponent);
//# sourceMappingURL=avatar.js.map