import {
    __assign,
    __extends
} from "tslib";
import * as React from 'react';
import hoistNonReactMethods from 'hoist-non-react-methods';
import {
    getDisplayName
} from '../utils';
import {
    st,
    classes
} from './Focusable.st.css';
import {
    isStatelessComponent
} from '../../utils';
/**
 * Assigned the given propTypes to the given class.
 *
 * This is a hack because since Yoshi3, with babel-preset-yoshi,
 * the babel-plugin-transform-react-remove-prop-types is enabled and removes propTypes.
 *
 * So if we simply do FocusableHOC.propTypes = Component.propTypes, it is being stripped away.
 *
 * This later becomes a problem if another component defines:
 * <code>
 * Comp.propTypes = {
 *   prop1: SomeFocusableComp.propTypes.prop1
 * }
 * </code>
 */
var assignPropTypesHack = function(targetClass, propTypes) {
    targetClass.propTypes = propTypes;
};
/**
 * Singleton for managing current input method (keyboard or mouse).
 */
var inputMethod = new( /** @class */ (function() {
    function class_1() {
        var _this = this;
        // Default is keyboard in case an element is focused programmatically.
        this.method = 'keyboard';
        this.subscribers = new Map();
        this.subscribe = function(target, callback) {
            return _this.subscribers.set(target, callback);
        };
        this.unsubscribe = function(target) {
            return _this.subscribers.delete(target);
        };
        /**
         * Is the current input method `keyboard`. if `false` is means it is `mouse`
         */
        this.isKeyboard = function() {
            return _this.method === 'keyboard';
        };
        if (typeof window !== 'undefined') {
            window.addEventListener('mousedown', function() {
                return _this.setMethod('mouse');
            });
            window.addEventListener('keydown', function() {
                return _this.setMethod('keyboard');
            });
            // We need to listen on keyUp, in case a TAB is made from the browser's address-bar,
            // so the keyDown is not fired, only the keyUp.
            window.addEventListener('keyup', function() {
                return _this.setMethod('keyboard');
            });
        }
    }
    class_1.prototype.setMethod = function(method) {
        if (method !== this.method) {
            this.method = method;
            this.subscribers.forEach(function(f) {
                return f();
            });
        }
    };
    return class_1;
}()))();
/*
 * TODO: Consider adding 'disabled' state to this HOC, since:
 * - When component is focused and then it becomes disabled, then the focus needs to be blured.
 *
 * TODO: Consider using [Recompose](https://github.com/acdlite/recompose/tree/master/src/packages/recompose) to do:
 *  - the static hoisting
 *  - set displayName
 */
export var withFocusable = function(Component) {
    var FocusableHOC = /** @class */ (function(_super) {
        __extends(FocusableHOC, _super);

        function FocusableHOC() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.focusedByMouse = false;
            _this.wrappedComponentRef = null;
            _this.state = {
                focus: false,
                focusVisible: false,
            };
            _this.focus = function() {
                if (_this.wrappedComponentRef && _this.wrappedComponentRef.focus) {
                    _this.wrappedComponentRef.focus();
                }
            };
            _this.markAsFocused = function() {
                _this.setState({
                    focus: true,
                    focusVisible: inputMethod.isKeyboard()
                });
                inputMethod.subscribe(_this, function() {
                    if (inputMethod.isKeyboard()) {
                        _this.setState({
                            focusVisible: true
                        });
                    }
                });
            };
            _this.markAsBlurred = function() {
                inputMethod.unsubscribe(_this);
                _this.setState({
                    focus: false,
                    focusVisible: false
                });
            };
            _this.onFocus = function(event) {
                var onFocus = _this.props.onFocus;
                onFocus
                    ?
                    onFocus(event, {
                        blur: _this.markAsBlurred,
                        focus: _this.markAsFocused,
                    }) :
                    _this.markAsFocused();
            };
            _this.onBlur = function(event) {
                var onBlur = _this.props.onBlur;
                onBlur
                    ?
                    onBlur(event, {
                        blur: _this.markAsBlurred,
                        focus: _this.markAsFocused
                    }) :
                    _this.markAsBlurred();
            };
            return _this;
        }
        FocusableHOC.prototype.componentWillUnmount = function() {
            inputMethod.unsubscribe(this);
        };
        FocusableHOC.prototype.componentDidUpdate = function(prevProps) {
            /*
              in case when button was focused and then become disabled,
              we need to trigger blur logic and remove all listers, as disabled button
              do not trigger onFocus and onBlur events
            */
            var isFocused = this.state.focus || this.state.focusVisible;
            var isBecomeDisabled = !prevProps.disabled && this.props.disabled;
            if (isFocused && isBecomeDisabled) {
                this.onBlur({});
            }
        };
        FocusableHOC.prototype.render = function() {
            var _this = this;
            var reference = isStatelessComponent(Component) ?
                undefined :
                function(ref) {
                    return (_this.wrappedComponentRef = ref);
                };
            return (React.createElement(Component, __assign({}, this.props, {
                ref: reference,
                focusableOnFocus: this.onFocus,
                focusableOnBlur: this.onBlur,
                className: st(classes.root, {
                    focus: this.state.focus,
                    'focus-visible': this.state.focusVisible,
                }, this.props.className)
            })));
        };
        FocusableHOC.displayName = getDisplayName(Component);
        FocusableHOC.defaultProps = Component.defaultProps;
        return FocusableHOC;
    }(React.Component));
    assignPropTypesHack(FocusableHOC, Component.propTypes);
    return isStatelessComponent(Component) ?
        FocusableHOC :
        hoistNonReactMethods(FocusableHOC, Component, {
            delegateTo: function(c) {
                return c.wrappedComponentRef;
            },
            hoistStatics: true,
        });
};
//# sourceMappingURL=FocusableHOC.js.map