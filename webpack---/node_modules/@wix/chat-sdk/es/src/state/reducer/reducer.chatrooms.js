import {
    __assign,
    __spreadArrays
} from "tslib";
import {
    default_lastReadMessageSequence,
    default_lastSeenMessageSequence,
    default_unreadCount,
} from '../../defaults/defaults';
import {
    combineReducers
} from 'redux';
import _get from 'lodash/get';
import _omit from 'lodash/omit';
import _isEmpty from 'lodash/isEmpty';
import _without from 'lodash/without';
import EVENT_TYPES from '../../realtime/event-types.constants';
import {
    error,
    pending,
    success
} from '../../utils/promise-middleware-utils';
import {
    areAllMessagesNew
} from '../helpers/messages.helper';
import types from '../types';
var initialState = {};
var initialFiltersBySubscriberIdState = {};
var EmptyTypingStatus = [];
var mergeSequences = function(newLastReadMessageSequence, currentLastReadMessageSequence, forceUpdate) {
    if (forceUpdate === void 0) {
        forceUpdate = false;
    }
    if (forceUpdate) {
        return newLastReadMessageSequence;
    }
    //The || default_lastSeenMessageSequence are here until we make all of the reducer function go trough mergeRoom which sets defaults value
    // so that no field will be undefined (causing this function to return 'NaN')
    return Math.max(newLastReadMessageSequence || default_lastReadMessageSequence, currentLastReadMessageSequence || default_lastReadMessageSequence);
};
var mergeUnreads = function(newUnreadCount, currentUnreadCount, newLastReadMessageSequence, currentLastReadMessageSequence, forceUpdate) {
    if (forceUpdate === void 0) {
        forceUpdate = false;
    }
    if (forceUpdate) {
        return newUnreadCount;
    }
    //The || default_lastSeenMessageSequence are here until we make all of the reducer function go trough mergeRoom which sets defaults value
    // so that no field will be undefined (causing this function to return 'NaN')
    return (currentLastReadMessageSequence || default_lastReadMessageSequence) >
        (newLastReadMessageSequence || default_lastReadMessageSequence) ?
        currentUnreadCount :
        newUnreadCount;
};
var stateValueOrDefault = function(state, chatroomId, fieldName, defaultValue) {
    if (!state[chatroomId]) {
        return defaultValue;
    }
    if (typeof state[chatroomId][fieldName] === 'undefined') {
        return defaultValue;
    }
    return state[chatroomId][fieldName];
};
var removeKeysIfEmpty = function(mergedRoom, keys) {
    return keys.forEach(function(key) {
        return mergedRoom[key] === undefined && delete mergedRoom[key];
    });
};
var MergeRoomOptionsDefault = {
    enrichedChatroomLoaded: false,
    typingEvent: {},
    overrideRegardlessOfSequenceComparison: false,
};
var mergeRoom = function(state, dto, participants, mergeRoomOptions) {
    var _a;
    if (participants === void 0) {
        participants = [];
    }
    if (mergeRoomOptions === void 0) {
        mergeRoomOptions = MergeRoomOptionsDefault;
    }
    var chatroomId = dto.id;
    var _b = __assign(__assign({}, MergeRoomOptionsDefault), mergeRoomOptions),
        enrichedChatroomLoaded = _b.enrichedChatroomLoaded,
        typingEvent = _b.typingEvent,
        overrideRegardlessOfSequenceComparison = _b.overrideRegardlessOfSequenceComparison;
    var participantId = dto.participantId,
        lastMessage = dto.lastMessage,
        _c = dto.unreadCount,
        unreadCount = _c === void 0 ? stateValueOrDefault(state, chatroomId, 'unreadCount', default_unreadCount) : _c,
        _d = dto.lastReadMessageSequence,
        lastReadMessageSequence = _d === void 0 ? stateValueOrDefault(state, chatroomId, 'lastReadMessageSequence', default_lastReadMessageSequence) : _d,
        _e = dto.lastSeenMessageSequence,
        lastSeenMessageSequence = _e === void 0 ? stateValueOrDefault(state, chatroomId, 'lastSeenMessageSequence', default_lastSeenMessageSequence) : _e,
        displayData = dto.displayData,
        isPrivate = dto.isPrivate,
        offlineChannels = dto.offlineChannels,
        clientReferenceType = dto.clientReferenceType,
        clientReference = dto.clientReference,
        participantCount = dto.participantCount,
        isArchived = dto.isArchived,
        isTemporary = dto.isTemporary,
        createdBy = dto.createdBy,
        createdAt = dto.createdAt,
        businessContext = dto.businessContext,
        pluginName = dto.pluginName,
        sortRank = dto.sortRank,
        labelIds = dto.labelIds,
        lastMessages = dto.lastMessages;
    var currentRooms = state;
    var roomBeforeMerge = currentRooms[chatroomId] || {
        unreadCount: unreadCount,
        lastReadMessageSequence: lastReadMessageSequence,
        lastSeenMessageSequence: lastSeenMessageSequence,
    };
    var currentTypingStatus = roomBeforeMerge.typingStatus || EmptyTypingStatus;
    var newTypingStatus = mergeTypingEventIntoTypingStatus(currentTypingStatus, typingEvent);
    var isNewParticipantExists = participants && participants.length > 0;
    var isOldParticipantExists = roomBeforeMerge.participants !== undefined;
    var mergedRoom = {
        displayData: displayData ? __assign(__assign({}, roomBeforeMerge.displayData), displayData) : roomBeforeMerge.displayData,
        id: chatroomId,
        cursor: roomBeforeMerge.cursor,
        lastMessage: lastMessage || roomBeforeMerge.lastMessage,
        lastMessages: lastMessages || roomBeforeMerge.lastMessages,
        lastReadMessageSequence: mergeSequences(lastReadMessageSequence, roomBeforeMerge.lastReadMessageSequence, overrideRegardlessOfSequenceComparison),
        lastSeenMessageSequence: mergeSequences(lastSeenMessageSequence, roomBeforeMerge.lastSeenMessageSequence),
        unreadCount: mergeUnreads(unreadCount, roomBeforeMerge.unreadCount, lastReadMessageSequence, roomBeforeMerge.lastReadMessageSequence, overrideRegardlessOfSequenceComparison),
        typingStatus: newTypingStatus,
        isPrivate: isPrivate !== undefined ? isPrivate : roomBeforeMerge.isPrivate,
        clientReferenceType: clientReferenceType || roomBeforeMerge.clientReferenceType,
        clientReference: clientReference || roomBeforeMerge.clientReference,
        offlineChannels: offlineChannels || roomBeforeMerge.offlineChannels,
        participantCount: typeof participantCount !== 'undefined' ? participantCount : roomBeforeMerge.participantCount,
        isArchived: isArchived !== undefined ? isArchived : roomBeforeMerge.isArchived,
        participantId: participantId !== undefined ? participantId : roomBeforeMerge.participantId,
        isTemporary: isTemporary !== undefined ? isTemporary : roomBeforeMerge.isTemporary,
        createdBy: typeof createdBy !== 'undefined' ? createdBy : roomBeforeMerge.createdBy,
        createdAt: typeof createdAt !== 'undefined' ? createdAt : roomBeforeMerge.createdAt,
        businessContext: businessContext || roomBeforeMerge.businessContext,
        enrichedChatroomLoaded: enrichedChatroomLoaded || roomBeforeMerge.enrichedChatroomLoaded,
        pluginName: pluginName || roomBeforeMerge.pluginName,
        sortRank: sortRank || roomBeforeMerge.sortRank,
        participants: isNewParticipantExists || !isOldParticipantExists ? participants : roomBeforeMerge.participants,
        labelIds: labelIds || roomBeforeMerge.labelIds,
        messageDeliveryError: roomBeforeMerge.messageDeliveryError,
    };
    removeKeysIfEmpty(mergedRoom, ['image', 'enrichedChatroomLoaded', 'messageDeliveryError']);
    var updatedCurrentRooms = __assign(__assign({}, currentRooms), (_a = {}, _a[chatroomId] = __assign(__assign({}, roomBeforeMerge), mergedRoom), _a));
    return __assign(__assign({}, state), updatedCurrentRooms);
};
var addOrRemoveToArray = function(arr, item, remove) {
    if (arr === void 0) {
        arr = [];
    }
    if (remove === void 0) {
        remove = false;
    }
    return remove ? _without(arr, item) : arr.concat(item);
};
var mergeLabelsToChatrooms = function(state, payload, remove) {
    if (remove === void 0) {
        remove = false;
    }
    var updatedRooms = payload.reduce(function(acc, _a) {
        var _b;
        var chatroomId = _a.chatroomId,
            labelId = _a.labelId;
        var currentChatroom = __assign(__assign({}, state[chatroomId]), (acc[chatroomId] || {}));
        return currentChatroom ?
            __assign(__assign({}, acc), (_b = {}, _b[chatroomId] = __assign(__assign({}, currentChatroom), {
                labelIds: addOrRemoveToArray(currentChatroom.labelIds, labelId, remove)
            }), _b)) : acc;
    }, {});
    return __assign(__assign({}, state), updatedRooms);
};
var fetchRooms = function(state, action, overwriteExisting) {
    if (_isEmpty(action.payload)) {
        // this can happen when cache is empty or if we got en error while fetching from cache
        return state;
    }
    var chatroomData = action.payload.chatrooms;
    var rooms = chatroomData.items;
    var newState = state;
    rooms.forEach(function(room) {
        var roomAlreadyExistInState = !!state[room.id];
        if (!roomAlreadyExistInState || overwriteExisting) {
            newState = mergeRoom(newState, room);
        }
    });
    return newState;
};
var addRooms = function(state, rooms) {
    var newState = state;
    rooms.forEach(function(room) {
        newState = mergeRoom(newState, room);
    });
    return newState;
};
var unarchiveRoom = function(state, chatroomId) {
    return setArchiveState(state, chatroomId, false);
};
var archiveRoom = function(state, chatroomId) {
    return setArchiveState(state, chatroomId, true);
};
var setArchiveState = function(state, chatroomId, isArchived) {
    return mergeRoom(state, {
        id: chatroomId,
        isArchived: isArchived,
    });
};
var addMessage = function(state, action) {
    var message = action.message;
    var isSilent = message.isSilent;
    var stateChatroom = state[message.chatroomId];
    if (!stateChatroom || isSilent) {
        return state;
    }
    var isNewerMessage = message.sequence > _get(stateChatroom, 'lastMessage.sequence', 0);
    var stateWithUpdatedLastMessage = updateLastMessage(state, message);
    if (action.messageSentByCurrentUser) {
        if (isNewerMessage) {
            return setRoomRead(stateWithUpdatedLastMessage, message.chatroomId);
        }
        return stateWithUpdatedLastMessage;
    } else if (isNewerMessage) {
        return incrementUnreadCount(stateWithUpdatedLastMessage, message.chatroomId);
    } else {
        return state;
    }
};
var incrementUnreadCount = function(state, chatroomId) {
    return mergeRoom(state, {
        id: chatroomId,
        unreadCount: (state[chatroomId].unreadCount || default_unreadCount) + 1,
        lastReadMessageSequence: state[chatroomId].lastReadMessageSequence,
    });
};
var updateLastMessage = function(state, lastMessage) {
    return mergeRoom(state, {
        id: lastMessage.chatroomId,
        lastMessage: lastMessage,
    });
};

function isStaleRoomLastMessage(fetchedRoom, state) {
    var currentRoom = state[fetchedRoom.id];
    return _get(fetchedRoom, 'lastMessages.0.sequence') < _get(currentRoom, 'lastMessages.0.sequence');
}

function fetchRoomMessagesSuccess(state, action) {
    if (_isEmpty(action.payload)) {
        return state;
    }
    var cursor = action.payload.next ? action.payload.next.before : null;
    var id = action.meta.chatroomId;
    var allMessagesAreNew = areAllMessagesNew(action.payload.items);
    var currCursor = (state[id] || {}).cursor;
    var hasCursor = currCursor !== null && currCursor !== undefined;
    return allMessagesAreNew || !hasCursor ? updateCursorAndResetError(state, cursor, id) : resetError(state, id);
}

function fetchMoreRoomMessagesSuccess(state, action) {
    var cursor = action.payload.next ? action.payload.next.before : null;
    var id = action.meta.chatroomId;
    return updateCursorAndResetError(state, cursor, id);
}
var updateCursorAndResetError = function(state, cursor, id) {
    var _a;
    return (__assign(__assign({}, state), (_a = {}, _a[id] = __assign(__assign({}, (state[id] || {})), {
        cursor: cursor,
        error: undefined
    }), _a)));
};
var resetError = function(state, id) {
    var _a;
    return (__assign(__assign({}, state), (_a = {}, _a[id] = __assign(__assign({}, state[id]), {
        error: undefined
    }), _a)));
};
var mergeTypingEventIntoTypingStatus = function(currentTypingStatus, typingEvent) {
    if (typingEvent.type === EVENT_TYPES.TYPING_STARTED) {
        return addTypingEventToTypingStatuses(currentTypingStatus, typingEvent);
    } else {
        return removeUserFromTypingStatuses(currentTypingStatus, typingEvent);
    }
};
var removeUserFromTypingStatuses = function(typingStatuses, typingEvent) {
    return !_isEmpty(typingStatuses) ?
        typingStatuses.filter(function(_a) {
            var userId = _a.userId;
            return userId !== typingEvent.userId;
        }) :
        EmptyTypingStatus;
};
var addTypingEventToTypingStatuses = function(typingStatuses, typingEvent) {
    var result;
    if (!typingEvent.isCurrentUser && !isUserIdAlreadyTyping(typingStatuses, typingEvent)) {
        result = __spreadArrays(typingStatuses);
        result.push({
            userId: typingEvent.userId,
            displayData: typingEvent.displayData,
        });
    } else {
        result = typingStatuses;
    }
    return result;
};
var isUserIdAlreadyTyping = function(typingStatuses, typingEvent) {
    return typingStatuses.some(function(_a) {
        var userId = _a.userId;
        return userId === typingEvent.userId;
    });
};

function setRoomRead(state, chatroomId) {
    var _a;
    var lastReadMessageSequence = (_a = state[chatroomId].lastMessage) === null || _a === void 0 ? void 0 : _a.sequence;
    return mergeRoom(state, {
        unreadCount: 0,
        id: chatroomId,
        lastReadMessageSequence: lastReadMessageSequence,
    });
}

function setRoomSeen(state, chatroomId) {
    var lastSeenMessageSequence = _get(state[chatroomId], 'lastMessage.sequence');
    return mergeRoom(state, {
        id: chatroomId,
        lastSeenMessageSequence: lastSeenMessageSequence,
    });
}

function archiveRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function(chatroomId) {
        return (updatedState = archiveRoom(updatedState, chatroomId));
    });
    return updatedState;
}

function unarchiveRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function(chatroomId) {
        return (updatedState = unarchiveRoom(updatedState, chatroomId));
    });
    return updatedState;
}

function deleteRoom(state, chatroomId) {
    return __assign({}, _omit(state, chatroomId));
}

function deleteRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function(chatroomId) {
        return (updatedState = deleteRoom(updatedState, chatroomId));
    });
    return updatedState;
}

function byId(state, action) {
    var _a, _b, _c;
    if (state === void 0) {
        state = initialState;
    }
    var id;
    switch (action.type) {
        case types.TYPING_STATUS_CHANGE:
            return mergeRoom(state, {
                id: action.payload.chatroomId
            }, [], {
                typingEvent: action.payload
            });
        case success(types.FETCH_ROOM):
            if (isStaleRoomLastMessage(action.payload, state)) {
                return state;
            }
            return mergeRoom(state, action.payload);
        case success(types.FETCH_ENRICHED_ROOM):
            if (isStaleRoomLastMessage(action.payload.chatroom, state)) {
                return state;
            }
            return mergeRoom(state, action.payload.chatroom, action.payload.participants.items, {
                enrichedChatroomLoaded: true,
            });
        case types.UPDATE_ROOM_LABELS:
            return mergeLabelsToChatrooms(state, action.payload.chatroomParticipantLabel);
        case pending(types.UPDATE_ROOM_LABEL):
            return mergeLabelsToChatrooms(state, [action.meta.updateLabel]);
        case types.REMOVE_ROOM_LABELS:
            return mergeLabelsToChatrooms(state, action.payload, true);
        case success(types.FETCH_ROOMS):
            return fetchRooms(state, action, true);
        case types.ADD_ROOMS:
            return addRooms(state, action.rooms);
        case pending(types.SEND_MESSAGE):
            {
                var sentMessage = action.meta.message;
                return updateLastMessage(state, sentMessage);
            }
        case types.ADD_MESSAGE:
            return addMessage(state, action);
        case types.HANDLE_ROOM_ARCHIVED:
        case pending(types.ARCHIVE_ROOM):
            return archiveRoom(state, action.meta.chatroomId);
        case success(types.ARCHIVE_ROOMS):
            return archiveRooms(state, action);
        case success(types.UNARCHIVE_ROOMS):
            return unarchiveRooms(state, action);
        case success(types.DELETE_ROOMS):
            return deleteRooms(state, action);
        case types.HANDLE_ROOM_UNARCHIVED:
        case pending(types.UNARCHIVE_ROOM):
            return unarchiveRoom(state, action.meta.chatroomId);
        case pending(types.DELETE_ROOM):
        case types.REMOVE_ROOM:
            return deleteRoom(state, action.meta.chatroomId);
        case types.SET_MESSAGES_READ_FOR_SELF:
        case pending(types.SET_MESSAGES_READ):
            {
                var _d = action.meta,
                    lastReadMessageSequence = _d.lastReadMessageSequence,
                    chatroomId = _d.chatroomId;
                return mergeRoom(state, {
                    unreadCount: 0,
                    lastReadMessageSequence: lastReadMessageSequence,
                    id: chatroomId
                });
            }
        case pending(types.SET_ROOMS_MESSAGES_READ):
            {
                var updatedState_1 = __assign({}, state);
                var chatroomIds = action.meta.chatroomIds;
                chatroomIds.forEach(function(chatroomId) {
                    updatedState_1 = setRoomRead(updatedState_1, chatroomId);
                });
                return updatedState_1;
            }
        case pending(types.SET_LAST_MESSAGE_UNREAD):
            {
                var _e = action.meta,
                    lastReadMessageSequence = _e.lastReadMessageSequence,
                    chatroomId = _e.chatroomId;
                return mergeRoom(state, {
                    unreadCount: 1,
                    lastReadMessageSequence: lastReadMessageSequence,
                    id: chatroomId
                }, [], {
                    overrideRegardlessOfSequenceComparison: true,
                });
            }
        case success(types.FETCH_ROOM_MESSAGES):
            return action.meta.isFetchMore ?
                fetchMoreRoomMessagesSuccess(state, action) :
                fetchRoomMessagesSuccess(state, action);
        case error(types.FETCH_ROOM_MESSAGES):
            if (!action.payload.is401Error) {
                //skip ChatSdkErrors that are 401 errors, they shouldn't be shown to users
                id = action.meta.chatroomId;
                var newState = __assign(__assign({}, state), (_a = {}, _a[id] = __assign(__assign({}, state[id]), {
                    error: action.payload
                }), _a));
                return newState;
            } else {
                return state;
            }
        case error(types.SEND_MESSAGE):
            id = action.meta.message.chatroomId;
            return __assign(__assign({}, state), (_b = {}, _b[id] = __assign(__assign({}, state[id]), {
                messageDeliveryError: true
            }), _b));
        case success(types.SEND_MESSAGE):
            id = action.meta.message.chatroomId;
            return __assign(__assign({}, state), (_c = {}, _c[id] = __assign(__assign({}, state[id]), {
                messageDeliveryError: undefined
            }), _c));
        case success(types.SET_UNSEEN_CHATROOMS):
            {
                var unseenChatrooms = action.payload;
                return unseenChatrooms.reduce(function(prev, _a) {
                    var chatroomId = _a.chatroomId,
                        lastSeenMessageSequence = _a.lastSeenMessageSequence;
                    var chatroom = state[chatroomId];
                    if (!chatroom) {
                        return prev;
                    }
                    return mergeRoom(prev, {
                        id: chatroomId,
                        lastSeenMessageSequence: Math.max(lastSeenMessageSequence, chatroom.lastSeenMessageSequence || default_lastSeenMessageSequence),
                    });
                }, state);
            }
        case pending(types.MARK_CHATROOMS_SEEN):
            {
                var filteredChatrooms = action.meta.filteredChatrooms;
                return filteredChatrooms.reduce(function(prev, chatroom) {
                    return setRoomSeen(prev, chatroom.id);
                }, state);
            }
        default:
            return state;
    }
}
var statusInitialState = {
    isFetchingRooms: false,
    isFetchingMoreRooms: false,
    isFetchingRoom: false,
};

function status(state, action) {
    if (state === void 0) {
        state = statusInitialState;
    }
    switch (action.type) {
        case success(types.FETCH_ROOM):
        case error(types.FETCH_ROOM):
            return __assign(__assign({}, state), {
                isFetchingRoom: false
            });
        case pending(types.FETCH_ROOM):
            return __assign(__assign({}, state), {
                isFetchingRoom: true
            });
        case success(types.FETCH_ROOMS):
            return __assign(__assign({}, state), {
                isFetchingRooms: false,
                isFetchingMoreRooms: false,
                error: null
            });
        case error(types.FETCH_ROOMS):
            {
                var errorPayload = action.payload.is401Error ? null : action.payload;
                return __assign(__assign({}, state), {
                    isFetchingRooms: false,
                    isFetchingMoreRooms: false,
                    error: errorPayload
                });
            }
        case pending(types.FETCH_ROOMS):
            {
                var isSilent = _get(action, 'meta.isSilent');
                var isFetchingMoreRooms = _get(action, 'meta.isFetchMore') && !isSilent;
                return __assign(__assign({}, state), {
                    isFetchingRooms: !isSilent,
                    isFetchingMoreRooms: isFetchingMoreRooms,
                    error: null
                });
            }
        default:
            return state;
    }
}

function filter(state, action) {
    var _a, _b;
    var _c;
    if (state === void 0) {
        state = initialFiltersBySubscriberIdState;
    }
    switch (action.type) {
        case types.SET_CURRENT_FILTER:
            {
                var _d = action.meta,
                    filter_1 = _d.filter,
                    subscriberId = _d.subscriberId;
                return __assign(__assign({}, state), (_a = {}, _a[subscriberId] = __assign(__assign({}, (state[subscriberId] || {})), {
                    currentFilter: filter_1 ? __assign({}, filter_1) : {}
                }), _a));
            }
        case types.SET_FILTERED_ROOMS_IDS:
            {
                var _e = action.meta,
                    shouldOverride = _e.shouldOverride,
                    filteredRoomsIds = _e.filteredRoomsIds,
                    subscriberId = _e.subscriberId;
                var currentFilteredRoomsIds = ((_c = state[subscriberId]) === null || _c === void 0 ? void 0 : _c.filteredRoomsIds) || [];
                var updatedFilteredRoomsIds = shouldOverride ?
                    __spreadArrays(filteredRoomsIds) : __spreadArrays(currentFilteredRoomsIds, filteredRoomsIds);
                return __assign(__assign({}, state), (_b = {}, _b[subscriberId] = __assign(__assign({}, (state[subscriberId] || {})), {
                    filteredRoomsIds: updatedFilteredRoomsIds
                }), _b));
            }
        default:
            return state;
    }
}
var chatroomsReducer = combineReducers({
    status: status,
    byId: byId,
    filter: filter
});
export {
    chatroomsReducer,
    byId,
    status
};