import {
    __assign
} from "tslib";
import types from '../types';
import {
    MessageSendStatus
} from '../../constants/constants';
import _isEmpty from 'lodash/isEmpty';
import _omit from 'lodash/omit';
import {
    success,
    pending,
    error,
    toStateObj
} from '../../utils/utils.index';
import {
    combineReducers
} from 'redux';
import * as Constants from '../../constants/constants';
import {
    areAllMessagesNew
} from '../helpers/messages.helper';
var initialState = {};

function byId(state, action) {
    if (state === void 0) {
        state = initialState;
    }
    switch (action.type) {
        case success(types.FETCH_ROOM_MESSAGES):
            return handleFetchRoomMessages(state, action, action.meta.isFetchMore);
        case types.ADD_MESSAGE:
            return handleAddMessage(state, action.message);
        case success(types.SEND_MESSAGE):
            return handleSentMessage(state, action.meta.message);
        case pending(types.SEND_MESSAGE):
            return handleSendingMessage(state, action.meta.message);
        case error(types.SEND_MESSAGE):
            return handleSendMessageError(state, action.meta.message, action.payload);
        case types.RESEND_MESSAGE:
            return handleResendMessage(state, action.meta.messageId);
        case types.DELETE_MESSAGE:
            return handleDeleteMessage(state, action.meta.messageId);
        case success(types.DELETE_ROOM):
            return removeChatroomMessages(state, action.meta.chatroomId);
        case success(types.DELETE_ROOMS):
            return deleteRooms(state, action);
        case success(types.FETCH_ROOMS):
            return handleFetchRoomSuccess(state, action.payload);
        default:
            return state;
    }
}
var handleFetchRoomMessages = function(state, action, isFetchMore) {
    if (_isEmpty(action.payload)) {
        // this can happen when cache is empty or if we got en error while fetching from cache
        return state;
    }
    var messages = action.payload.items;
    var overrides = {
        transit: {
            sendStatus: MessageSendStatus.SENT
        }
    };
    var fetchedMessages = toStateObj(messages, 'id', overrides);
    var shouldDiscardOldMessagesInRoom = !isFetchMore && !!Object.keys(fetchedMessages).length && areAllMessagesNew(messages);
    return __assign(__assign({}, existingMessages(state, action.meta.chatroomId, shouldDiscardOldMessagesInRoom)), fetchedMessages);
};
var existingMessages = function(state, chatroomId, shouldDiscardOldMessagesInRoom) {
    return shouldDiscardOldMessagesInRoom ? allMessagesExceptChatroom(state, chatroomId) : state;
};
var allMessagesExceptChatroom = function(state, chatroomId) {
    return Object.values(state).reduce(function(acc, message) {
        if (message.chatroomId !== chatroomId) {
            acc[message.id] = message;
        }
        return acc;
    }, []);
};
var handleAddMessage = function(state, item) {
    return mergeNewItem(state, item);
};
var handleSentMessage = function(state, item) {
    var newTransit = {
        sendStatus: Constants.MessageSendStatus.SENT
    };
    var transit = _omit(mergeTransits(state, item, newTransit), ['sendError']);
    return mergeNewItem(state, item, {
        transit: transit
    });
};
var handleSendingMessage = function(state, item) {
    var newTransit = {
        sendStatus: Constants.MessageSendStatus.SENDING
    };
    var transit = _omit(mergeTransits(state, item, newTransit), ['sendError']);
    return mergeNewItem(state, item, {
        transit: transit
    });
};
var handleSendMessageError = function(state, item, sdkError) {
    var newTransit = {
        sendStatus: Constants.MessageSendStatus.FAILED,
        sendError: sdkError,
    };
    var transit = mergeTransits(state, item, newTransit);
    return mergeNewItem(state, item, {
        transit: transit
    });
};
var mergeTransits = function(state, item, newTransit) {
    var itemTransit = item ? item.transit : {};
    var previousStateTransit = item && state[item.id] ? state[item.id].transit : {};
    return __assign(__assign(__assign({}, previousStateTransit), itemTransit), newTransit);
};
var sequenceValueToOverride = function(currentSequence, newSequence) {
    return !newSequence && !!currentSequence ? currentSequence : newSequence;
};
var mergeNewItem = function(state, item, overrides) {
    if (overrides === void 0) {
        overrides = {};
    }
    var newState = __assign({}, state);
    var existingItem = newState[item.id] || {};
    newState[item.id] = __assign(__assign(__assign(__assign({}, existingItem), item), {
        sequence: sequenceValueToOverride(existingItem.sequence, item.sequence)
    }), overrides);
    return newState;
};
var handleDeleteMessage = function(state, messageId) {
    var newState = __assign({}, state);
    delete newState[messageId];
    return newState;
};
var handleResendMessage = function(state, messageId) {
    return handleDeleteMessage(state, messageId);
};
var handleFetchRoomSuccess = function(state, payload) {
    if (!payload) {
        return state;
    }
    var items = payload.chatrooms.items;
    var newMessages = items.reduce(function(acc, room) {
        return Object.assign(acc, toStateObj(room.lastMessages || [], 'id', {
            transit: {
                sendStatus: MessageSendStatus.SENT
            }
        }));
    }, {});
    return __assign(__assign({}, state), newMessages);
};

function removeChatroomMessages(messages, chatroomId) {
    var result = {};
    Object.keys(messages).forEach(function(messageId) {
        if (messages[messageId].chatroomId !== chatroomId) {
            result[messageId] = messages[messageId];
        }
    });
    return result;
}

function deleteRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function(chatroomId) {
        updatedState = removeChatroomMessages(updatedState, chatroomId);
    });
    return updatedState;
}
var messagesReducer = combineReducers({
    byId: byId
});
export {
    byId,
    messagesReducer
};