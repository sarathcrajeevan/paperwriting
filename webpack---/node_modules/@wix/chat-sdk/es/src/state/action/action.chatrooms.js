import {
    __assign,
    __awaiter,
    __generator,
    __spreadArrays
} from "tslib";
import types from '../types';
import * as chatEventEmitter from '../../services/chat-event-emitter.service';
import {
    FetchChatroomsPageSizeDefaultValue,
    FetchRoomMessagesPageSize,
    experiments as experimentsConstants,
} from '../../constants/constants';
import {
    getLastReadMessageSequence
} from '../reducer/selector.chatrooms';
import {
    createSortedMessagesSelector,
    sortMessagesBySequence
} from '../reducer/selector.messages';
import {
    getExperimentValue,
    isExperimentOn
} from '../../utils/experiments-utils';
import {
    CHAT_EVENTS
} from '../../services/chat-event-emitter.service';
import {
    EVENTS
} from '../../constants/bi-logger.config';
import appService from '../../services/app-service';
import uuidV4 from 'uuid/v4';
import _first from 'lodash/first';
import _last from 'lodash/last';
var ChatRoomsActions = /** @class */ (function() {
    function ChatRoomsActions(serverApi, persistenceService, eventHooks, unseenChatroomCountActions, unreadChatroomCountActions, experiments) {
        this.serverApi = serverApi;
        this.persistence = persistenceService;
        this.eventHooks = eventHooks;
        this.unseenChatroomCountActions = unseenChatroomCountActions;
        this.unreadChatroomCountActions = unreadChatroomCountActions;
        this.experiments = experiments;
    }
    ChatRoomsActions.prototype.action$resetStore = function() {
        return {
            type: types.RESET_STORE,
        };
    };
    ChatRoomsActions.prototype.fetchRoomMessages = function(chatroomId, cursor) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                var fetchParams, serverPromise, action;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            fetchParams = {
                                chatroomId: chatroomId,
                                cursor: cursor,
                                pageSize: FetchRoomMessagesPageSize
                            };
                            serverPromise = this.serverApi.http$fetchRoomMessages(fetchParams);
                            action = {
                                type: types.FETCH_ROOM_MESSAGES,
                                payload: serverPromise,
                                meta: {
                                    chatroomId: chatroomId,
                                    isFetchMore: !!cursor,
                                },
                            };
                            return [4 /*yield*/ , dispatch(action)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.fetchMessageErrorIndications = function(chatroomId) {
        var _this = this;
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                var state, messages, from, to, serverPromise, action;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            if (!isExperimentOn(this.experiments, experimentsConstants.InboxErrorIndications)) {
                                return [2 /*return*/ , null];
                            }
                            state = getState();
                            messages = createSortedMessagesSelector(chatroomId, sortMessagesBySequence)(state);
                            if (!messages || !messages.length) {
                                return [2 /*return*/ , null];
                            }
                            from = _first(messages).sequence;
                            to = _last(messages).sequence;
                            serverPromise = this.serverApi.http$fetchMessagesErrorIndications({
                                chatroomId: chatroomId,
                                from: from,
                                to: to
                            });
                            action = {
                                type: types.FETCH_MESSAGES_ERRORS_INDICATIONS,
                                payload: serverPromise,
                                meta: {
                                    chatroomId: chatroomId,
                                },
                            };
                            return [4 /*yield*/ , dispatch(action)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$fetchRoom = function(chatroomId, enrichedChatroom, force) {
        if (enrichedChatroom === void 0) {
            enrichedChatroom = false;
        }
        if (force === void 0) {
            force = false;
        }
        if (!chatroomId) {
            //this is hopefully temporary code, we need to hunt down the source
            //of these errors: https://rpm.newrelic.com/accounts/23428/applications/37820036/traced_errors/bb98a11d-205a-11e8-ba9c-0242ac110006_10172_23269
            //we can look in user explorer to see what users did before they got this error
            //to try to figure out causes someone to try to fetch an undefined chatroom
            //if the quantity of these BI events don't match the NR errors, then
            //there's a chat-sdk client that isn't supplying a proper reportMonitoringBi
            //function.
            var event = {
                tag: 'error',
                description: "Attempting to fetch chatroom with undefined chatroomId.",
            };
            chatEventEmitter.emit(CHAT_EVENTS.MONITORING_BI, event);
            this.eventHooks.reportMonitoringBi(event);
            // TODO: remove when error is resolved: https://sentry.io/wix_o/wix-one-app/issues/718628954/events/36573747091/
            console.error('[Troubleshoot] called fetchRoom w/o chatroomId', new Error());
        }
        return enrichedChatroom ?
            {
                type: types.FETCH_ENRICHED_ROOM,
                payload: this.serverApi.http$fetchEnrichedChatroom({
                    chatroomId: chatroomId,
                    force: force
                }).then(function(enrichedRoom) {
                    chatEventEmitter.emit(chatEventEmitter.CHAT_INTERNAL_EVENTS.FETCH_ENRICHED_CHATROOM_COMPLETED, enrichedRoom);
                    return enrichedRoom;
                }),
            } :
            {
                type: types.FETCH_ROOM,
                payload: this.serverApi.http$fetchRoom({
                    chatroomId: chatroomId
                }),
            };
    };
    ChatRoomsActions.prototype.action$deleteRoom = function(chatroomId) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , this.decrementCounters(dispatch, chatroomId)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/ , dispatch({
                                type: types.DELETE_ROOM,
                                payload: this.serverApi.http$deleteChatroom({
                                    chatroomId: chatroomId
                                }),
                                meta: {
                                    chatroomId: chatroomId,
                                },
                            })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$removeRoom = function(chatroomId) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , this.decrementCounters(dispatch, chatroomId)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ , dispatch({
                                type: types.REMOVE_ROOM,
                                meta: {
                                    chatroomId: chatroomId,
                                },
                            })];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$updateRoomLabels = function(payload) {
        return {
            type: types.UPDATE_ROOM_LABELS,
            payload: payload,
        };
    };
    ChatRoomsActions.prototype.action$updateRoomLabel = function(updateLabel) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    return [2 /*return*/ , dispatch({
                        type: types.UPDATE_ROOM_LABEL,
                        payload: this.serverApi.http$updateLabel(updateLabel),
                        meta: {
                            updateLabel: updateLabel,
                        },
                    })];
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$removeRoomLabels = function(payload, persist) {
        var _this = this;
        if (persist === void 0) {
            persist = false;
        }
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                var _this = this;
                return __generator(this, function(_a) {
                    if (persist) {
                        payload.map(function(_a) {
                            var _b;
                            var chatroomId = _a.chatroomId,
                                labelId = _a.labelId;
                            var chatroom = getState().chatrooms.byId[chatroomId];
                            return ((_b = chatroom === null || chatroom === void 0 ? void 0 : chatroom.labelIds) === null || _b === void 0 ? void 0 : _b.includes(labelId)) ? _this.serverApi.http$deleteLabel({
                                    chatroomId: chatroomId,
                                    labelId: labelId
                                }) :
                                Promise.resolve();
                        });
                    }
                    dispatch({
                        type: types.REMOVE_ROOM_LABELS,
                        payload: payload,
                    });
                    return [2 /*return*/ ];
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$handleRoomArchived = function(chatroomId) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , this.decrementCounters(dispatch, chatroomId)];
                        case 1:
                            _a.sent();
                            dispatch({
                                type: types.HANDLE_ROOM_ARCHIVED,
                                meta: {
                                    chatroomId: chatroomId,
                                },
                            });
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$handleRoomUnarchived = function(chatroomId) {
        var _this = this;
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    dispatch({
                        type: types.HANDLE_ROOM_UNARCHIVED,
                        meta: {
                            chatroomId: chatroomId,
                            chatroom: getState().chatrooms.byId[chatroomId],
                        },
                    });
                    return [2 /*return*/ ];
                });
            });
        };
    };
    ChatRoomsActions.prototype.archiveRoom = function(chatroomId) {
        var _this = this;
        return function(dispatch) {
            return Promise.all([
                _this.decrementCounters(dispatch, chatroomId),
                dispatch({
                    type: types.ARCHIVE_ROOM,
                    payload: _this.serverApi.http$archiveChatroom({
                        chatroomId: chatroomId
                    }),
                    meta: {
                        chatroomId: chatroomId,
                    },
                }),
            ]);
        };
    };
    ChatRoomsActions.prototype.unarchiveRoom = function(chatroomId) {
        var _this = this;
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , dispatch({
                                type: types.UNARCHIVE_ROOM,
                                payload: this.serverApi.http$unarchiveChatroom({
                                    chatroomId: chatroomId
                                }),
                                meta: {
                                    chatroomId: chatroomId,
                                    chatroom: getState().chatrooms.byId[chatroomId],
                                },
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.fetchRooms = function(_a) {
        var _this = this;
        var _b = _a === void 0 ? {
                filter: {},
                cursor: undefined,
                isSilent: false
            } : _a,
            filter = _b.filter,
            cursor = _b.cursor,
            _c = _b.isSilent,
            isSilent = _c === void 0 ? false : _c;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                var pageSize, fetchParams, serverPromise, actionClusterId, serverAction;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            pageSize = this.getPageSize(this.experiments, experimentsConstants.FetchChatroomsPageSize, FetchChatroomsPageSizeDefaultValue);
                            fetchParams = {
                                nextPointer: cursor,
                                filter: filter,
                                pageSize: pageSize
                            };
                            serverPromise = this.serverApi.http$fetchChatrooms(fetchParams);
                            actionClusterId = uuidV4();
                            serverAction = {
                                type: types.FETCH_ROOMS,
                                payload: serverPromise,
                                meta: {
                                    filter: filter,
                                    isSilent: isSilent,
                                    isFetchMore: !!cursor,
                                    actionClusterId: actionClusterId,
                                },
                            };
                            return [4 /*yield*/ , dispatch(serverAction)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.addRooms = function(rooms) {
        return {
            type: types.ADD_ROOMS,
            rooms: rooms,
        };
    };
    ChatRoomsActions.prototype.action$addMessage = function(message, messageSentByCurrentUser, chatroom) {
        return function(dispatch) {
            dispatch({
                type: types.ADD_MESSAGE,
                message: message,
                messageSentByCurrentUser: messageSentByCurrentUser,
                meta: {
                    chatroom: chatroom,
                },
            });
        };
    };
    ChatRoomsActions.prototype.action$sendMessage = function(message) {
        this.serverApi.http$notifyTyping(message.chatroomId, 'stop');
        return {
            type: types.SEND_MESSAGE,
            payload: this.serverApi.http$sendMessage(message.chatroomId, message),
            meta: {
                message: message.dto,
            },
        };
    };
    ChatRoomsActions.prototype.action$sendPostbackMessage = function(message, options) {
        message.createdAt = message.createdAt || Date.now();
        var type = message.type,
            sender = message.sender,
            id = message.id;
        chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.MESSAGE_SENT, message);
        chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.BI, __assign(__assign({}, EVENTS.sendMessage), {
            messageId: id,
            chatRoomId: message.chatroomId,
            messageType: type,
            uuid: sender === null || sender === void 0 ? void 0 : sender.userId,
            mimeType: message.mimeTypes,
            hostName: appService.appName
        }));
        var requestPromise = this.serverApi.http$sendMessageV2(message, options).catch(function(error) {
            chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.BI_ERROR, {
                tag: 'send-message',
                description: 'failed to send message',
                errorName: error,
            });
            throw error;
        });
        return {
            type: types.SEND_MESSAGE,
            payload: requestPromise,
            meta: {
                message: message.dto,
            },
        };
    };
    ChatRoomsActions.prototype.action$deleteMessage = function(messageId, persist) {
        var _this = this;
        if (persist === void 0) {
            persist = false;
        }
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                var message, messageSequenceToDelete, chatroomId;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            if (persist) {
                                message = getState().messages.byId[messageId];
                                if (message) {
                                    messageSequenceToDelete = message.sequence;
                                    chatroomId = message.chatroomId;
                                    this.serverApi.http$deleteMessage({
                                        chatroomId: chatroomId,
                                        messageSequenceToDelete: messageSequenceToDelete
                                    });
                                }
                            }
                            return [4 /*yield*/ , dispatch({
                                type: types.DELETE_MESSAGE,
                                meta: {
                                    messageId: messageId,
                                },
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$resendMessage = function(messageId) {
        var _this = this;
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                var message, messageSequenceToReSend, chatroomId;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            message = getState().messages.byId[messageId];
                            if (message) {
                                messageSequenceToReSend = message.sequence;
                                chatroomId = message.chatroomId;
                                this.serverApi.http$resendMessage({
                                    chatroomId: chatroomId,
                                    messageSequenceToReSend: messageSequenceToReSend
                                });
                            }
                            return [4 /*yield*/ , dispatch({
                                type: types.RESEND_MESSAGE,
                                meta: {
                                    messageId: messageId,
                                },
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$setMessagesRead = function(chatroomId, lastReadMessageSequence) {
        var _this = this;
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , dispatch({
                                type: types.SET_MESSAGES_READ,
                                payload: this.serverApi.http$setMessagesRead({
                                    chatroomId: chatroomId,
                                    lastReadMessageSequence: lastReadMessageSequence
                                }),
                                meta: {
                                    chatroomId: chatroomId,
                                    lastReadMessageSequence: lastReadMessageSequence,
                                    chatroom: getState().chatrooms.byId[chatroomId],
                                },
                            })];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/ , this.decrementUnseenCounter(dispatch, chatroomId)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$setMessagesReadForSelf = function(chatroomId, sequenceToMarkAsRead) {
        var _this = this;
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                var lastReadMessageSequence;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            lastReadMessageSequence = getLastReadMessageSequence(getState(), chatroomId);
                            if (!(!lastReadMessageSequence || sequenceToMarkAsRead > lastReadMessageSequence)) return [3 /*break*/ , 3];
                            return [4 /*yield*/ , dispatch({
                                type: types.SET_MESSAGES_READ_FOR_SELF,
                                meta: {
                                    chatroomId: chatroomId,
                                    lastReadMessageSequence: sequenceToMarkAsRead,
                                },
                            })];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/ , this.decrementCounters(dispatch, chatroomId)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$setRoomsMessagesRead = function(chatroomIds, mostRecentKnownMessageSequence) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                var _this = this;
                return __generator(this, function(_a) {
                    return [2 /*return*/ , Promise.all(__spreadArrays([
                        dispatch({
                            type: types.SET_ROOMS_MESSAGES_READ,
                            payload: this.serverApi.http$markRoomsAsRead(chatroomIds, mostRecentKnownMessageSequence),
                            meta: {
                                chatroomIds: chatroomIds,
                            },
                        })
                    ], chatroomIds.map(function(chatroomId) {
                        return __awaiter(_this, void 0, void 0, function() {
                            return __generator(this, function(_a) {
                                switch (_a.label) {
                                    case 0:
                                        return [4 /*yield*/ , this.decrementUnseenCounter(dispatch, chatroomId)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/ ];
                                }
                            });
                        });
                    })))];
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$setLastMessageUnread = function(chatroomId, lastReadMessageSequence, updateServer) {
        var _this = this;
        if (updateServer === void 0) {
            updateServer = true;
        }
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , dispatch({
                                type: types.SET_LAST_MESSAGE_UNREAD,
                                payload: updateServer ?
                                    this.serverApi.http$setMessagesUnread({
                                        chatroomId: chatroomId,
                                        lastReadMessageSequence: lastReadMessageSequence
                                    }) :
                                    Promise.resolve(true),
                                meta: {
                                    chatroomId: chatroomId,
                                    lastReadMessageSequence: lastReadMessageSequence,
                                    chatroom: getState().chatrooms.byId[chatroomId],
                                },
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.typing = function(chatroomId, text) {
        return {
            type: types.TYPING,
            text: text,
            meta: {
                chatroomId: chatroomId,
            },
        };
    };
    ChatRoomsActions.prototype.fetchMessageDrafts = function() {
        return {
            type: types.FETCH_MESSAGE_DRAFTS,
            payload: this.persistence.loadMessageDrafts(),
        };
    };
    ChatRoomsActions.prototype.action$changeTypingStatus = function(payload) {
        return {
            type: types.TYPING_STATUS_CHANGE,
            payload: payload,
        };
    };
    ChatRoomsActions.prototype.action$fetchRoomParticipantsDisplayData = function(chatroomId, participantIds) {
        return {
            type: types.FETCH_PARTICIPANTS_DISPLAY_DATA,
            payload: this.serverApi.http$fetchParticipantsDisplayData({
                chatroomId: chatroomId,
                participantIds: participantIds
            }),
        };
    };
    ChatRoomsActions.prototype.decrementCounters = function(dispatch, chatroomId) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        return [4 /*yield*/ , this.decrementUnseenCounter(dispatch, chatroomId)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/ ];
                }
            });
        });
    };
    ChatRoomsActions.prototype.decrementUnseenCounter = function(dispatch, chatroomId) {
        dispatch(this.unreadChatroomCountActions.markChatroomAsRead(chatroomId));
        return dispatch(this.unseenChatroomCountActions.markChatroomAsSeen(chatroomId));
    };
    ChatRoomsActions.prototype.action$deleteRooms = function(chatroomIds) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                var _this = this;
                return __generator(this, function(_a) {
                    return [2 /*return*/ , Promise.all(__spreadArrays([
                        dispatch({
                            type: types.DELETE_ROOMS,
                            payload: this.serverApi.http$deleteChatrooms(chatroomIds),
                            meta: {
                                chatroomIds: chatroomIds,
                            },
                        })
                    ], chatroomIds.map(function(id) {
                        return _this.decrementCounters(dispatch, id);
                    })))];
                });
            });
        };
    };
    ChatRoomsActions.prototype.archiveRooms = function(chatroomIds) {
        var _this = this;
        return function(dispatch) {
            return __awaiter(_this, void 0, void 0, function() {
                var _this = this;
                return __generator(this, function(_a) {
                    return [2 /*return*/ , Promise.all(__spreadArrays([
                        dispatch({
                            type: types.ARCHIVE_ROOMS,
                            payload: this.serverApi.http$archiveChatrooms(chatroomIds),
                            meta: {
                                chatroomIds: chatroomIds,
                            },
                        })
                    ], chatroomIds.map(function(id) {
                        return _this.decrementCounters(dispatch, id);
                    })))];
                });
            });
        };
    };
    ChatRoomsActions.prototype.unarchiveRooms = function(chatroomIds) {
        var _this = this;
        return function(dispatch, getState) {
            return __awaiter(_this, void 0, void 0, function() {
                var promises;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , dispatch({
                                type: types.UNARCHIVE_ROOMS,
                                payload: this.serverApi.http$unarchiveChatrooms(chatroomIds),
                                meta: {
                                    chatroomIds: chatroomIds,
                                    chatrooms: chatroomIds.map(function(id) {
                                        return getState().chatrooms.byId[id];
                                    }),
                                },
                            })];
                        case 1:
                            _a.sent();
                            promises = [];
                            return [4 /*yield*/ , Promise.all(promises)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
    };
    ChatRoomsActions.prototype.action$handleFilterChanged = function(subscriberId, filter, filteredRoomsIds) {
        var _this = this;
        return function(dispatch) {
            dispatch(_this.action$setCurrentFilter(subscriberId, filter));
            dispatch(_this.action$setFilteredRoomsIds(subscriberId, true, filteredRoomsIds));
        };
    };
    ChatRoomsActions.prototype.action$setCurrentFilter = function(subscriberId, filter) {
        return {
            type: types.SET_CURRENT_FILTER,
            meta: {
                subscriberId: subscriberId,
                filter: filter,
            },
        };
    };
    ChatRoomsActions.prototype.action$setFilteredRoomsIds = function(subscriberId, shouldOverride, filteredRoomsIds) {
        return {
            type: types.SET_FILTERED_ROOMS_IDS,
            meta: {
                subscriberId: subscriberId,
                filteredRoomsIds: filteredRoomsIds,
                shouldOverride: shouldOverride,
            },
        };
    };
    ChatRoomsActions.prototype.getPageSize = function(experiments, experimentName, defaultValue) {
        var result = parseInt(getExperimentValue(experiments, experimentName, defaultValue));
        return isNaN(result) ? parseInt(defaultValue) : result;
    };
    return ChatRoomsActions;
}());
export {
    ChatRoomsActions
};
var chatroomsActionsFactory = function(serverApi, persistenceService, eventHooks, unseenChatroomCountActions, unreadChatroomCountActions, experiments) {
    return new ChatRoomsActions(serverApi, persistenceService, eventHooks, unseenChatroomCountActions, unreadChatroomCountActions, experiments);
};
export default chatroomsActionsFactory;