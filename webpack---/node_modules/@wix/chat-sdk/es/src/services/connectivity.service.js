import {
    __spreadArrays
} from "tslib";
var ConnectivityService = /** @class */ (function() {
    function ConnectivityService() {}
    ConnectivityService.setConnectivityProvider = function(connectivityProvider) {
        this.connectivityProvider = connectivityProvider;
        connectivityProvider.addEventListener(this.listener.bind(this));
    };
    /**
     * Executes callback every time that network becomes available.
     * Useful for refreshing subscribed data
     * Will never be called if Connectivity Provider not supplied
     *
     * @param callback callback to execute
     */
    ConnectivityService.executeEveryTimeOnBackToOnline = function(callback) {
        var _this = this;
        if (!this.connectivityProvider) {
            return;
        }
        this.networkResumeCallbacks.push(callback);
        return function() {
            return _this.removeFromBackToOnline(callback);
        };
    };
    Object.defineProperty(ConnectivityService, "online", {
        /**
         * Returns whether or not internet is available
         * Always returns true if connectivityProvider not available
         * @returns {boolean} true if internet is available, false otherwise
         */
        get: function() {
            var _a, _b;
            return (_b = (_a = this.connectivityProvider) === null || _a === void 0 ? void 0 : _a.fetch()) !== null && _b !== void 0 ? _b : true;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Executes callback every time that network becomes unavailable.
     * Useful for disconnecting realtime services
     * Will never be called if Connectivity Provider not supplied
     *
     * @param callback callback to execute
     */
    ConnectivityService.executeEveryTimeOnOffline = function(callback) {
        var _this = this;
        if (!this.connectivityProvider) {
            return;
        }
        this.networkPauseCallbacks.push(callback);
        return function() {
            return _this.removeFromOnOffline(callback);
        };
    };
    Object.defineProperty(ConnectivityService, "waitForOnline", {
        /**
         * Returns a promise that will be resolved once network is available
         * Will be resolved immediatly if no Connectivity Provider or network already available
         *
         * @returns Promise that will be resolved when network is available
         */
        get: function() {
            var _this = this;
            if (!this.connectivityProvider || this.connectivityProvider.fetch()) {
                return Promise.resolve();
            } else {
                return new Promise(function(resolve) {
                    return _this.resolveOnOnline.push(resolve);
                });
            }
        },
        enumerable: false,
        configurable: true
    });
    ConnectivityService.removeFromBackToOnline = function(callback) {
        this.networkResumeCallbacks.splice(this.networkResumeCallbacks.indexOf(callback), 1);
    };
    ConnectivityService.removeFromOnOffline = function(callback) {
        this.networkPauseCallbacks.splice(this.networkResumeCallbacks.indexOf(callback), 1);
    };
    ConnectivityService.listener = function(isConnected) {
        var _this = this;
        var call = function(fn) {
            return fn();
        };
        if (isConnected) {
            return Promise.all(__spreadArrays(this.resolveOnOnline.map(call), this.networkResumeCallbacks.map(call))).then(function() {
                return (_this.resolveOnOnline = []);
            });
        } else {
            return Promise.all(this.networkPauseCallbacks.map(call));
        }
    };
    ConnectivityService.resolveOnOnline = [];
    ConnectivityService.networkResumeCallbacks = [];
    ConnectivityService.networkPauseCallbacks = [];
    return ConnectivityService;
}());
export default ConnectivityService;