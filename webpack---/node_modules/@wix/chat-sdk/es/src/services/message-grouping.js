import {
    MessagePositionInGroup
} from '../constants/constants';
import memoize from 'lru-memoize';
import Message from '../domain/message';
var LRU_CACHE_SIZE = 500;
var createMessage = function(_a) {
    var message = _a.message,
        groupPosition = _a.groupPosition,
        showSentTime = _a.showSentTime;
    var dtoCopy = Object.assign({}, message.dto);
    var transitCopy = Object.assign({}, message.transit);
    return new Message(dtoCopy, transitCopy, message.indications, groupPosition, showSentTime);
};
var equals = function(keyA, keyB) {
    return (keyA.message === keyB.message &&
        keyA.groupPosition === keyB.groupPosition &&
        keyA.showSentTime === keyB.showSentTime);
};
createMessage = memoize(LRU_CACHE_SIZE, equals)(createMessage);
var MessageGroupingService = /** @class */ (function() {
    function MessageGroupingService(thresholdMinuets, lastReadSequence) {
        var defaultThresholdMinuets = 180;
        this._thresholdMillis = (thresholdMinuets || defaultThresholdMinuets) * 60 * 1000;
        this._lastReadSequence = lastReadSequence;
    }
    MessageGroupingService.prototype.setLastReadSequence = function(lastReadSeq) {
        this._lastReadSequence = lastReadSeq;
    };
    MessageGroupingService.prototype.addGroups = function(messages) {
        var _this = this;
        return messages.map(function(message, i) {
            var _a = _this._strategy(messages[i - 1], message, messages[i + 1]),
                groupPosition = _a.groupPosition,
                showSentTime = _a.showSentTime;
            return createMessage({
                message: message,
                groupPosition: groupPosition,
                showSentTime: showSentTime
            });
        });
    };
    MessageGroupingService.prototype.getPartsGrouping = function(groupedMessage) {
        var _this = this;
        var partsCount = groupedMessage.messageParts.length;
        var parentTag = groupedMessage.groupPosition;
        var parentShowSentTime = groupedMessage.showSentTime;
        return groupedMessage.messageParts.map(function(_, index) {
            var groupPosition = _this._classifyPart(parentTag, index, partsCount);
            var showSentTime = _this._showPartSentTime(parentShowSentTime, index);
            return {
                groupPosition: groupPosition,
                showSentTime: showSentTime
            };
        });
    };
    MessageGroupingService.prototype.isFirstMessage = function(message) {
        return (message.groupPosition === MessagePositionInGroup.SINGLE || message.groupPosition === MessagePositionInGroup.START);
    };
    MessageGroupingService.prototype._classifyPart = function(parentTag, partIndex, partsCount) {
        if (partsCount === 1) {
            return parentTag;
        } else if (this._isFirstPartOfStartingMessage(partIndex, parentTag)) {
            return MessagePositionInGroup.START;
        } else if (this._isLastPartOfClosingMessage(partIndex, partsCount, parentTag)) {
            return MessagePositionInGroup.END;
        } else {
            return MessagePositionInGroup.MIDDLE;
        }
    };
    MessageGroupingService.prototype._isLastPartOfClosingMessage = function(partIndex, partsCount, parentTag) {
        return (partIndex === partsCount - 1 &&
            (parentTag === MessagePositionInGroup.END || parentTag === MessagePositionInGroup.SINGLE));
    };
    MessageGroupingService.prototype._isFirstPartOfStartingMessage = function(partIndex, parentTag) {
        return (partIndex === 0 && (parentTag === MessagePositionInGroup.START || parentTag === MessagePositionInGroup.SINGLE));
    };
    MessageGroupingService.prototype._isBreakingMessage = function(message) {
        return this._lastReadSequence && message.sequence === this._lastReadSequence;
    };
    MessageGroupingService.prototype._strategy = function(olderMessage, currentMessage, newerMessage) {
        var groupPosition = this._position({
            olderMessage: olderMessage,
            currentMessage: currentMessage,
            newerMessage: newerMessage
        });
        var showSentTime = this._showSentTime(olderMessage, currentMessage);
        return {
            groupPosition: groupPosition,
            showSentTime: showSentTime
        };
    };
    MessageGroupingService.prototype._isSameTimeWindow = function(message1, message2) {
        var date1 = new Date(message1.createdAt);
        var date2 = new Date(message2.createdAt);
        var timeDiff = Math.abs(date2.getTime() - date1.getTime());
        return timeDiff < this._thresholdMillis;
    };
    MessageGroupingService.prototype._isSameSender = function(message1, message2) {
        var _a, _b;
        var sender1 = (_a = message1.sender) === null || _a === void 0 ? void 0 : _a.userId;
        var sender2 = (_b = message2.sender) === null || _b === void 0 ? void 0 : _b.userId;
        return sender1 === sender2;
    };
    MessageGroupingService.prototype._position = function(_a) {
        var olderMessage = _a.olderMessage,
            currentMessage = _a.currentMessage,
            newerMessage = _a.newerMessage;
        var isStart = !this._isInSameGroup(currentMessage, olderMessage) || this._isBreakingMessage(olderMessage);
        var isEnd = !this._isInSameGroup(currentMessage, newerMessage) || this._isBreakingMessage(currentMessage);
        var position = MessagePositionInGroup.MIDDLE;
        if (isStart && isEnd) {
            position = MessagePositionInGroup.SINGLE;
        } else if (isEnd) {
            position = MessagePositionInGroup.END;
        } else if (isStart) {
            position = MessagePositionInGroup.START;
        }
        return position;
    };
    MessageGroupingService.prototype._isInSameGroup = function(message1, message2) {
        var noOtherMessage = !message1 || !message2;
        if (noOtherMessage) {
            return false;
        }
        var isSameSender = this._isSameSender(message1, message2);
        var isSameTimeWindow = this._isSameTimeWindow(message1, message2);
        return isSameSender && isSameTimeWindow;
    };
    MessageGroupingService.prototype._showSentTime = function(olderMessage, message) {
        var isSameTimeWindow = olderMessage && message && this._isSameTimeWindow(olderMessage, message);
        return isSameTimeWindow ? 'on-click' : 'always';
    };
    MessageGroupingService.prototype._showPartSentTime = function(parentShowSentTime, index) {
        if (index === 0) {
            return parentShowSentTime;
        } else {
            return 'on-click';
        }
    };
    return MessageGroupingService;
}());
export {
    MessageGroupingService
};