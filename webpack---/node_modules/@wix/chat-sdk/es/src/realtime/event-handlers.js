import {
    __assign,
    __awaiter,
    __generator
} from "tslib";
import * as chatEventEmitter from '../services/chat-event-emitter.service';
import EVENT_TYPES from './event-types.constants';
import * as constants from '../constants/constants';
import presenceActions from '../presence/action.presence';
import {
    chatSdk
} from '../api/chat-sdk';
var chatroomHasBeenLoaded = function(chatroomsById, chatroomId) {
    var _a, _b;
    return (_b = (_a = chatroomsById[chatroomId]) === null || _a === void 0 ? void 0 : _a.displayData) === null || _b === void 0 ? void 0 : _b.name;
};
var onAddRealtimeMessage = function(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        data = _a.data,
        currentUser = _a.currentUser;
    return __awaiter(void 0, void 0, void 0, function() {
        var chatroomId, message, connectionEstablishedTimestamp, timestamp, chatrooms, chatroomsById, isEnrichedChatroom, fetchPromise, messageSentByCurrentUser, messageWithSendStatusSent, didConnectionEstablishFewSecondBeforeSendingMessage;
        return __generator(this, function(_b) {
            switch (_b.label) {
                case 0:
                    chatroomId = data.chatroomId, message = data.message, connectionEstablishedTimestamp = data.connectionEstablishedTimestamp, timestamp = data.timestamp;
                    chatrooms = store.getState().chatrooms;
                    chatroomsById = chatrooms.byId;
                    if (!!chatroomHasBeenLoaded(chatroomsById, chatroomId)) return [3 /*break*/ , 2];
                    if (!chatroomId) {
                        console.error('[Troubleshoot] onAddRealtimeMessage calling fetchRoom w/o chatroomId' + JSON.stringify(data));
                    }
                    isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
                    fetchPromise = store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom));
                    return [4 /*yield*/ , fetchPromise];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    chatroomsById = store.getState().chatrooms.byId;
                    messageSentByCurrentUser = currentUser.userId === message.sender.userId;
                    messageWithSendStatusSent = __assign(__assign({}, message), {
                        transit: __assign(__assign({}, message.transit), {
                            sendStatus: constants.MessageSendStatus.SENT
                        })
                    });
                    store.dispatch(chatroomsActions.action$addMessage(messageWithSendStatusSent, messageSentByCurrentUser, chatroomsById[chatroomId]));
                    didConnectionEstablishFewSecondBeforeSendingMessage = timestamp + constants.HistorySinceRealtimeConnectionWasEstablished >= connectionEstablishedTimestamp;
                    if (!messageSentByCurrentUser && didConnectionEstablishFewSecondBeforeSendingMessage) {
                        _postOnRealtimeMessageEvent(message);
                    }
                    return [2 /*return*/ ];
            }
        });
    });
};
var deleteChatroom = function(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        data = _a.data;
    return store.dispatch(chatroomsActions.action$removeRoom(data.chatroomId));
};
var handlePresenceEvent = function(store, data) {
    return store.dispatch(presenceActions.action$updatePresence(data));
};
var refreshChatroom = function(_a, force) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        chatroomId = _a.chatroomId,
        dataForDebug = _a.dataForDebug;
    if (force === void 0) {
        force = false;
    }
    if (!chatroomId) {
        // TODO: remove when error is resolved: https://sentry.io/wix_o/wix-one-app/issues/718628954/events/36573747091/
        console.error('[Troubleshoot] refreshChatroom: ' + JSON.stringify(dataForDebug));
    }
    var isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
    return store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom, force));
};
var refreshChatrooms = function(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        data = _a.data;
    return data.chatroomIds.forEach(function(chatroomId) {
        return refreshChatroom({
            store: store,
            chatroomsActions: chatroomsActions,
            chatroomId: chatroomId,
            dataForDebug: data
        });
    });
};
var changeTypingStatus = function(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        data = _a.data,
        currentUser = _a.currentUser;
    var chatroomId = data.chatroomId,
        userId = data.userId,
        type = data.type,
        displayDataDto = data.displayData,
        timestamp = data.timestamp,
        connectionEstablishedTimestamp = data.connectionEstablishedTimestamp;
    if (connectionEstablishedTimestamp > timestamp) {
        return;
    }
    var displayData = null;
    if (type === EVENT_TYPES.TYPING_STARTED && displayDataDto) {
        displayData = {
            imageUrl: displayDataDto.content.image ? displayDataDto.content.image.url : undefined,
            initials: displayDataDto.content.initials,
            id: displayDataDto.content.id,
            name: displayDataDto.content.name,
            type: displayDataDto.content.type,
        };
    }
    var isCurrentUser = userId === currentUser.userId;
    store.dispatch(chatroomsActions.action$changeTypingStatus({
        chatroomId: chatroomId,
        userId: userId,
        type: type,
        displayData: displayData,
        isCurrentUser: isCurrentUser
    }));
};
var _stopTypingTimers = {};
var stopTypingAfterInterval = function(_a) {
    var data = _a.data,
        store = _a.store,
        chatroomsActions = _a.chatroomsActions;
    var userId = data.userId,
        chatroomId = data.chatroomId,
        expiryDuration = data.expiryDuration;
    if (expiryDuration) {
        var timerId = userId + "|" + chatroomId;
        if (_stopTypingTimers[timerId]) {
            clearTimeout(_stopTypingTimers[timerId]);
        }
        _stopTypingTimers[timerId] = setTimeout(function() {
            store.dispatch(chatroomsActions.action$changeTypingStatus({
                chatroomId: chatroomId,
                userId: userId,
                type: EVENT_TYPES.TYPING_STOPPED
            }));
        }, expiryDuration);
    }
};
var changeRoomArchivalStatus = function(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        chatroomId = _a.chatroomId,
        isArchived = _a.isArchived;
    var byId = store.getState().chatrooms.byId;
    if (!chatroomHasBeenLoaded(byId, chatroomId)) {
        var isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
        store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom));
        return;
    }
    store.dispatch(isArchived ?
        chatroomsActions.action$handleRoomArchived(chatroomId) :
        chatroomsActions.action$handleRoomUnarchived(chatroomId));
};
var onChatroomReadForSelf = function(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        chatroomId = _a.chatroomId,
        userId = _a.userId,
        sequenceToMarkAsRead = _a.sequenceToMarkAsRead;
    if (chatSdk.getUserId() === userId) {
        store.dispatch(chatroomsActions.action$setMessagesReadForSelf(chatroomId, sequenceToMarkAsRead));
    }
};
var updateMessagesIndications = function(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        messagesActions = _a.messagesActions,
        data = _a.data;
    var participants = store.getState().participants;
    if (!participants.byId[data.participantId]) {
        store.dispatch(chatroomsActions.action$fetchRoomParticipantsDisplayData(data.chatroomId, [data.participantId]));
    }
    store.dispatch(messagesActions.action$updateMessagesIndications({
        chatroomId: data.chatroomId,
        messageIds: data.messageIds,
        participantId: data.participantId,
        indication: data.indication,
    }));
};

function onRealtimeEvent(_a) {
    var store = _a.store,
        chatroomsActions = _a.chatroomsActions,
        messagesActions = _a.messagesActions,
        data = _a.data,
        currentUser = _a.currentUser;
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_b) {
            // See https://github.com/wix-private/chat-server/tree/master/chat/chat-api#events for payloads
            switch (data.type) {
                case EVENT_TYPES.MESSAGE_SENT:
                    return [2 /*return*/ , onAddRealtimeMessage({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        data: data,
                        currentUser: currentUser
                    })];
                case EVENT_TYPES.MESSAGE_DELETED:
                    return [2 /*return*/ , store.dispatch(chatroomsActions.action$deleteMessage(data.messageId))];
                case EVENT_TYPES.CHATROOM_DELETED:
                    return [2 /*return*/ , deleteChatroom({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        data: data
                    })];
                case EVENT_TYPES.CHATROOOM_DISPLAY_DATA_UPDATED:
                    return [2 /*return*/ , refreshChatrooms({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        data: data
                    })];
                case EVENT_TYPES.LABEL_ADDED:
                    return [2 /*return*/ , store.dispatch(chatroomsActions.action$updateRoomLabels(data))];
                case EVENT_TYPES.LABEL_REMOVED:
                    return [2 /*return*/ , store.dispatch(chatroomsActions.action$removeRoomLabels(data.chatroomParticipantLabel))];
                case EVENT_TYPES.CHATROOM_CREATED:
                    return [2 /*return*/ , refreshChatroom({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        chatroomId: data.chatroomId,
                        dataForDebug: data
                    })];
                case EVENT_TYPES.OFFLINE_CHANNEL_UPDATED:
                    chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.OFFLINE_CHANNEL_UPDATED, data);
                    return [2 /*return*/ , refreshChatroom({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        chatroomId: data.chatroomId,
                        dataForDebug: data
                    })];
                case EVENT_TYPES.CHATROOM_MERGED:
                    return [2 /*return*/ , refreshChatroom({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        chatroomId: data.toChatroomId,
                        dataForDebug: data
                    }, true)];
                case EVENT_TYPES.TYPING_STARTED:
                    stopTypingAfterInterval({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        data: data
                    }); //do not break! intentionally fall through to typing stopped
                case EVENT_TYPES.TYPING_STOPPED:
                    return [2 /*return*/ , changeTypingStatus({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        data: data,
                        currentUser: currentUser
                    })];
                case EVENT_TYPES.CHATROOM_ARCHIVED:
                    return [2 /*return*/ , changeRoomArchivalStatus({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        chatroomId: data.chatroomId,
                        isArchived: true
                    })];
                case EVENT_TYPES.CHATROOM_UNARCHIVED:
                    return [2 /*return*/ , changeRoomArchivalStatus({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        chatroomId: data.chatroomId,
                        isArchived: false
                    })];
                case EVENT_TYPES.CHATROOM_READ:
                    return [2 /*return*/ , onChatroomReadForSelf({
                        store: store,
                        chatroomsActions: chatroomsActions,
                        chatroomId: data.chatroomId,
                        userId: data.userId,
                        sequenceToMarkAsRead: data.lastReadMessageSequence,
                    })];
                case EVENT_TYPES.CHATROOMS_ALL_READ:
                    return [2 /*return*/ , chatSdk.setAllRoomsAsRead({
                        participantIds: data.participantIds
                    }, false)];
                case EVENT_TYPES.CHATROOM_UNREAD:
                    return [2 /*return*/ , store.dispatch(chatroomsActions.action$setLastMessageUnread(data.chatroomId, data.lastReadMessageSequence, false))];
                case EVENT_TYPES.MESSAGE_INDICATION_UPDATE:
                    chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.MESSAGE_INDICATION_UPDATE, data);
                    if (chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom)) {
                        return [2 /*return*/ , updateMessagesIndications({
                            store: store,
                            chatroomsActions: chatroomsActions,
                            messagesActions: messagesActions,
                            data: data
                        })];
                    }
                    break;
                case EVENT_TYPES.PRESENCE_EVENT:
                    return [2 /*return*/ , handlePresenceEvent(store, data)];
                case EVENT_TYPES.EXTERNAL_HOST:
                    chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.EXTERNAL_HOST, data);
                    break;
                default:
                    return [2 /*return*/ ];
            }
            return [2 /*return*/ ];
        });
    });
}
var _postOnRealtimeMessageEvent = function(message) {
    chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.NEW_REALTIME_MESSAGE, message);
};
export {
    onRealtimeEvent,
    EVENT_TYPES
};