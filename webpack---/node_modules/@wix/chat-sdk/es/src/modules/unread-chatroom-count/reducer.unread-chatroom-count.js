import {
    __assign
} from "tslib";
import {
    combineReducers
} from 'redux';
import types from '../../state/types';
import {
    success
} from '../../utils/promise-middleware-utils';
var normalize = function(chatroomIds) {
    if (!chatroomIds) {
        return {};
    }
    return chatroomIds.reduce(function(acc, chatroomId) {
        acc[chatroomId] = true;
        return acc;
    }, {});
};
var setUnreadChatrooms = function(state, action) {
    var chatroomsForParticipant = action.payload.chatroomsForParticipant;
    var participantIds = action.meta.filter.participantIds || Object.keys(chatroomsForParticipant);
    return participantIds.reduce(function(acc, participantId) {
        var chatrooms = normalize(chatroomsForParticipant[participantId]);
        acc[participantId] = {
            chatrooms: chatrooms
        };
        return acc;
    }, state);
};
var setChatroomReadState = function(state, chatroom) {
    if (!chatroom) {
        return state;
    }
    var newState = __assign({}, state);
    var currentFilter = state[chatroom.participantId];
    if (currentFilter) {
        var chatrooms = currentFilter.chatrooms;
        if (chatrooms[chatroom.id]) {
            delete chatrooms[chatroom.id];
        }
    }
    return newState;
};
var setChatroomUnreadStateIfUnread = function(state, chatroom) {
    var _a, _b;
    var roomIsUnread = ((_a = chatroom.lastMessage) === null || _a === void 0 ? void 0 : _a.sequence) && ((_b = chatroom.lastMessage) === null || _b === void 0 ? void 0 : _b.sequence) > chatroom.lastReadMessageSequence;
    if (roomIsUnread) {
        return setChatroomUnreadState(state, chatroom);
    } else {
        return state;
    }
};
var setChatroomUnreadState = function(state, chatroom) {
    var _a;
    if (!chatroom) {
        return state;
    }
    var newState = __assign({}, state);
    var currentFilter = state[chatroom.participantId];
    newState[chatroom.participantId] = __assign(__assign({}, currentFilter), {
        chatrooms: __assign(__assign({}, currentFilter === null || currentFilter === void 0 ? void 0 : currentFilter.chatrooms), (_a = {}, _a[chatroom.id] = true, _a))
    });
    return newState;
};
var byFilter = function(state, action) {
    if (state === void 0) {
        state = {};
    }
    switch (action.type) {
        case success(types.SET_UNREAD_CHATROOMS_MAP):
            return setUnreadChatrooms(state, action);
        case types.ADD_MESSAGE:
            {
                var _a = action.meta.chatroom,
                    _b = (_a === void 0 ? {} : _a).lastReadMessageSequence,
                    lastReadMessageSequence = _b === void 0 ? 0 : _b;
                return action.messageSentByCurrentUser ||
                    action.message.isSilent ||
                    action.message.sequence <= lastReadMessageSequence ?
                    state :
                    setChatroomUnreadState(state, action.meta.chatroom);
            }
        case types.HANDLE_ROOM_UNARCHIVED:
            return setChatroomUnreadStateIfUnread(state, action.meta.chatroom);
        case success(types.SET_LAST_MESSAGE_UNREAD):
            return setChatroomUnreadState(state, action.meta.chatroom);
        case success(types.UNARCHIVE_ROOM):
            return setChatroomUnreadStateIfUnread(state, unarchive(action.meta.chatroom));
        case success(types.UNARCHIVE_ROOMS):
            return action.meta.chatrooms.reduce(function(prev, chatroom) {
                return setChatroomUnreadStateIfUnread(prev, unarchive(chatroom));
            }, state);
        case types.MARK_CHATROOM_READ:
            return setChatroomReadState(state, action.meta.chatroom);
        case success(types.SET_MESSAGES_READ):
            return setChatroomReadState(state, action.meta.chatroom);
        default:
            return state;
    }
};
var unarchive = function(room) {
    return (__assign(__assign({}, room), {
        isArchived: false
    }));
};
export var unreadChatroomCountReducer = combineReducers({
    byFilter: byFilter,
});