import {
    __assign
} from "tslib";
import {
    combineReducers
} from 'redux';
import types from '../../state/types';
import config from '../../constants/unread-chatroom-count-config';
import {
    shouldFilterChatroom
} from '../../state/reducer/chatroomsFilter';
import {
    pending,
    success
} from '../../utils/promise-middleware-utils';
export var hashUnseenFilter = function(filter) {
    return 'participantType' in filter ? filter.participantType : filter.participantId;
};
export var parseUnseenFilter = function(s) {
    return s === 'business' || s === 'siteMember' ? {
        participantType: s
    } : {
        participantId: s
    };
};
var normalize = function(chatrooms) {
    return chatrooms.reduce(function(acc, _a) {
        var chatroomId = _a.chatroomId;
        acc[chatroomId] = true;
        return acc;
    }, {});
};
var setUnseenChatrooms = function(state, action) {
    var _a;
    var payload = action.payload;
    return __assign(__assign({}, state), (_a = {}, _a[hashUnseenFilter(action.meta.filter)] = payload.length > config.maxTrackableUnreads ?
        {
            resyncCountdown: config.maxTrackableUnreads - config.maxUnreadsCount
        } :
        {
            chatrooms: normalize(payload)
        }, _a));
};
var getMatchedFilters = function(state, chatroom) {
    return Object.keys(state)
        .map(parseUnseenFilter)
        .filter(function(filter) {
            return shouldFilterChatroom(chatroom, 'participantId' in filter ?
                {
                    participantIds: [filter.participantId]
                } :
                {
                    participantType: filter.participantType
                });
        })
        .map(hashUnseenFilter);
};
var isOverflow = function(state) {
    return 'resyncCountdown' in state;
};
var setChatroomAsUnseenInFilter = function(state, chatroomId) {
    var _a;
    if (isOverflow(state)) {
        return state;
    }
    if (Object.keys(state.chatrooms).length === config.maxTrackableUnreads) {
        return {
            resyncCountdown: config.maxTrackableUnreads - config.maxUnreadsCount,
        };
    }
    return {
        chatrooms: __assign(__assign({}, state.chatrooms), (_a = {}, _a[chatroomId] = true, _a)),
    };
};
var setChatroomAsUnseen = function(state, chatroom) {
    if (!chatroom) {
        return state;
    }
    var matchedFilters = getMatchedFilters(state, chatroom);
    var newState = __assign({}, state);
    matchedFilters.forEach(function(filterHash) {
        newState[filterHash] = setChatroomAsUnseenInFilter(state[filterHash], chatroom.id);
    });
    return newState;
};
var setChatroomAsSeenInFilter = function(state, chatroomId) {
    if (isOverflow(state)) {
        return {
            resyncCountdown: Math.max(0, state.resyncCountdown - 1),
        };
    }
    if (state.chatrooms[chatroomId]) {
        var chatrooms = __assign({}, state.chatrooms);
        delete chatrooms[chatroomId];
        return {
            chatrooms: chatrooms
        };
    }
    return state;
};
var setChatroomIdAsSeen = function(state, chatroomId) {
    var filters = Object.keys(state);
    var newState = __assign({}, state);
    filters.forEach(function(filterHash) {
        newState[filterHash] = setChatroomAsSeenInFilter(state[filterHash], chatroomId);
    });
    return newState;
};
var setChatroomAsSeen = function(state, chatroom) {
    if (!chatroom) {
        return state;
    }
    var matchedFilters = getMatchedFilters(state, chatroom);
    var newState = __assign({}, state);
    matchedFilters.forEach(function(filterHash) {
        newState[filterHash] = setChatroomAsSeenInFilter(state[filterHash], chatroom.id);
    });
    return newState;
};
var byFilter = function(state, action) {
    var _a;
    if (state === void 0) {
        state = {};
    }
    switch (action.type) {
        case success(types.SET_UNSEEN_CHATROOMS):
            return setUnseenChatrooms(state, action);
        case types.ADD_MESSAGE:
            {
                var _b = action.meta.chatroom,
                    _c = _b === void 0 ? {} : _b,
                    _d = _c.lastSeenMessageSequence,
                    lastSeenMessageSequence = _d === void 0 ? 0 : _d,
                    _e = _c.lastReadMessageSequence,
                    lastReadMessageSequence = _e === void 0 ? 0 : _e;
                var lastReadOrSeenSequence = Math.max(lastSeenMessageSequence, lastReadMessageSequence);
                return action.messageSentByCurrentUser ||
                    action.message.isSilent ||
                    action.message.sequence <= lastReadOrSeenSequence ?
                    state :
                    setChatroomAsUnseen(state, action.meta.chatroom);
            }
        case types.HANDLE_ROOM_UNARCHIVED:
        case types.UNARCHIVE_ROOM:
        case types.SET_LAST_MESSAGE_UNREAD:
            return setChatroomAsUnseen(state, action.meta.chatroom);
        case types.UNARCHIVE_ROOMS:
            return action.meta.chatrooms.reduce(function(prev, chatroom) {
                return setChatroomAsUnseen(prev, chatroom);
            }, state);
        case types.MARK_CHATROOM_SEEN:
            return setChatroomAsSeen(state, action.meta.chatroom);
        case pending(types.MARK_CHATROOMS_SEEN):
            {
                var _f = action.meta,
                    filter = _f.filter,
                    filteredChatrooms = _f.filteredChatrooms;
                var filterHash = hashUnseenFilter(filter);
                var filteredState = state[filterHash];
                var chatroomIds = isOverflow(filteredState) ? [] : Object.keys(filteredState.chatrooms);
                return __assign(__assign(__assign({}, filteredChatrooms.reduce(function(prev, chatroom) {
                    return setChatroomAsSeen(prev, chatroom);
                }, state)), chatroomIds.reduce(function(prev, chatroomId) {
                    return setChatroomIdAsSeen(prev, chatroomId);
                }, state)), (_a = {}, _a[filterHash] = {
                    chatrooms: {},
                }, _a));
            }
        default:
            return state;
    }
};
export var unseenChatroomCountReducer = combineReducers({
    byFilter: byFilter,
});