import {
    __awaiter,
    __generator
} from "tslib";
import types from '../../state/types';
import config from '../../constants/unread-chatroom-count-config';
import {
    getFilteredUnseenChatrooms,
    getLastKnownMessageSequence
} from '../../state/reducer/selector.chatrooms';
import _unionBy from 'lodash/unionBy';
import {
    filterChatrooms
} from '../../state/reducer/chatroomsFilter';
import {
    isChatroomUnseen
} from './selector.unseen-chatroom-count';
import {
    parseUnseenFilter
} from './reducer.unseen-chatroom-count';
var mergeUnseens = function(filter, unseenChatrooms, state) {
    return _unionBy(unseenChatrooms.chatrooms.filter(function(_a) {
        var chatroomId = _a.chatroomId;
        var chatroom = state.chatrooms.byId[chatroomId];
        if (!chatroom) {
            return true;
        }
        return isChatroomUnseen(chatroom);
    }), getFilteredUnseenChatrooms(state, filter), function(chatroom) {
        return chatroom.chatroomId;
    });
};
var shouldResync = function(prevState, newState) {
    return prevState &&
        newState &&
        'resyncCountdown' in prevState &&
        'resyncCountdown' in newState &&
        prevState.resyncCountdown === 1 &&
        newState.resyncCountdown === 0;
};
var UnseenChatroomCountActions = /** @class */ (function() {
    function UnseenChatroomCountActions(serverApi) {
        this.serverApi = serverApi;
    }
    UnseenChatroomCountActions.prototype.updateUnseenChatrooms = function(filter) {
        var _this = this;
        return function(dispatch, getState) {
            var fetchAndMergeUnseenChatrooms = function() {
                return __awaiter(_this, void 0, void 0, function() {
                    var _a, _b;
                    return __generator(this, function(_c) {
                        switch (_c.label) {
                            case 0:
                                _a = mergeUnseens;
                                _b = [filter];
                                return [4 /*yield*/ , this.serverApi.http$fetchUnseenChatroomCount(filter, config.maxTrackableUnreads + 1)];
                            case 1:
                                return [2 /*return*/ , _a.apply(void 0, _b.concat([_c.sent(), getState()]))];
                        }
                    });
                });
            };
            return dispatch({
                type: types.SET_UNSEEN_CHATROOMS,
                payload: fetchAndMergeUnseenChatrooms(),
                meta: {
                    filter: filter,
                },
            });
        };
    };
    UnseenChatroomCountActions.prototype.markChatroomAsSeen = function(chatroomId) {
        var _this = this;
        return function(dispatch, getState) {
            var prevState = getState();
            dispatch({
                type: types.MARK_CHATROOM_SEEN,
                payload: chatroomId,
                meta: {
                    chatroom: getState().chatrooms.byId[chatroomId],
                },
            });
            return Promise.all(Object.keys(prevState.unseenChatroomCount.byFilter)
                .filter(function(filter) {
                    return shouldResync(prevState.unseenChatroomCount.byFilter[filter], getState().unseenChatroomCount.byFilter[filter]);
                })
                .map(function(filter) {
                    return dispatch(_this.updateUnseenChatrooms(parseUnseenFilter(filter)));
                }));
        };
    };
    UnseenChatroomCountActions.prototype.markChatroomsAsSeen = function(filter) {
        var _this = this;
        return function(dispatch, getState) {
            return dispatch({
                type: types.MARK_CHATROOMS_SEEN,
                payload: _this.serverApi.http$markChatroomsAsSeen(filter, getLastKnownMessageSequence(getState())),
                meta: {
                    filter: filter,
                    filteredChatrooms: Object.values(filterChatrooms(getState().chatrooms.byId, 'participantId' in filter ?
                        {
                            participantIds: [filter.participantId]
                        } :
                        {
                            participantType: filter.participantType
                        })),
                },
            });
        };
    };
    return UnseenChatroomCountActions;
}());
export default UnseenChatroomCountActions;