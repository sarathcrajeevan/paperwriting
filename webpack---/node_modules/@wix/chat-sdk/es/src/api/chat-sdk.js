import {
    __awaiter,
    __generator
} from "tslib";
import Message from '../domain/message';
import ChatroomApi from './api.chatroom';
import chatroomsActionsFactory from '../state/action/action.chatrooms';
import messagesActionsFactory from '../state/action/action.messages';
import ServerApi from '../server-api/server-api';
import CurrentUser from '../server-api/current-user';
import appService from '../services/app-service';
import * as Constants from '../constants/constants';
import TextTypingService from '../services/text-typing.service';
import PersistenceService from '../services/persistence.service';
import SubscriptionService from '../services/subscription-service';
import ChatAgent from '../server-api/chat-agent';
import {
    setupStore
} from '../state';
import {
    getCachedChatToken,
    getHandshakeChatToken,
    isExpiredToken,
    saveToken,
} from '../services/handshake-token-service';
import ChatroomsApi from './api.chatrooms';
import MessagesApi from './api.messages';
import {
    isExperimentOn
} from '../utils/experiments-utils';
import FirebaseService from 'firebase-service';
import {
    onRealtimeEvent
} from '../realtime/event-handlers';
import {
    UnseenChatroomCountApi
} from '../modules/unseen-chatroom-count/api.unseen-chatroom-count';
import UnseenChatroomCountActions from '../modules/unseen-chatroom-count/action.unseen-chatroom-count';
import UnreadChatroomCountActions from '../modules/unread-chatroom-count/action.unread-chatroom-count';
import PresencePublicApi from './public/public-api.presence';
import presenceActions from '../presence/action.presence';
import {
    realtimeClientFactory
} from '../realtime/client';
import {
    DEFAULT_THROTTLE_THRESHOLD
} from '../constants/constants';
import ConnectivityService from '../services/connectivity.service';
import UnreadChatroomCountApi from '../modules/unread-chatroom-count/api.unread-chatroom-count';
/**
 * Chat SDK
 * @doc chat-sdk
 * singleton object that holds all public API calls
 */
var SDK = /** @class */ (function() {
    function SDK() {
        var _this = this;
        this.unseenChatroom = {
            /**
             * Tells the SDK that you want to know how many rooms have unread messages in them,
             * with the option to "mark as seen".
             * The callback will give you a number every time the number of unread rooms changes, unless the count is above
             * some threshold, at which point it'll give you the threshold number and a `hasOverflow: true`.
             * @param callback
             * @param filter
             */
            subscribeToCount: function(callback, filter) {
                _this._assertInitialized();
                return _this.unseenChatroomCountApi.subscribe(callback, filter);
            },
            /**
             * Marks a given chatrooms filter as seen
             * @param filter
             */
            markChatroomsAsSeen: function(filter) {
                _this._assertInitialized();
                return _this.unseenChatroomCountApi.markChatroomsAsSeen(filter);
            },
        };
        this._initialized = false;
        this._experiments = {};
        this._onConnectCallbacks = [];
        this._onConnectingCallbacks = [];
        this._onConnectionEstablishedCallbacks = [];
        this._onDisconnectCallbacks = [];
        this._onInitCallbacks = [];
        this._connected = false;
        this._connectivityProviderWasSet = false;
        this._currentUser = new CurrentUser();
    }
    /**
     * If the sdk is already initialized it will resolve immediately. Otherwise it will wait until initialization is
     * complete and then resolve. This is useful if you are getting errors that some operation is not allowed
     * until the sdk is initialized.
     */
    SDK.prototype.waitForInitialized = function() {
        var _this = this;
        var resolveOnInit = function(resolve) {
            return _this._registerOnInit(function() {
                return resolve();
            });
        };
        return new Promise(function(resolve) {
            return resolveOnInit(resolve);
        });
    };
    Object.defineProperty(SDK.prototype, "initialized", {
        /**
         * Will be `true` only after the initialization process is completed. If you need to wait for initialization
         * to complete before continuing, see `waitForInitialized`
         */
        get: function() {
            return this._initialized;
        },
        enumerable: false,
        configurable: true
    });
    SDK.prototype.initWithHandshake = function(params) {
        return __awaiter(this, void 0, void 0, function() {
            var tokenServer, chatToken, sdk;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        _verifyInitParams(params);
                        this.setConnectivityProviderIfNeeded(params.connectivityProvider);
                        this.clear();
                        tokenServer = params.tokenServer;
                        if (!tokenServer) {
                            throw new Error('Trying to call init with handshake without passing the issue server url');
                        }
                        return [4 /*yield*/ , getCachedChatToken(params.persistenceEngine)];
                    case 1:
                        chatToken = _a.sent();
                        if (!(!chatToken && tokenServer && ConnectivityService.online)) return [3 /*break*/ , 3];
                        return [4 /*yield*/ , getHandshakeChatToken(tokenServer)];
                    case 2:
                        chatToken = _a.sent();
                        _a.label = 3;
                    case 3:
                        sdk = chatSdk.init(Object.assign({}, params, {
                            chatToken: chatToken
                        }));
                        if (!chatToken) return [3 /*break*/ , 5];
                        return [4 /*yield*/ , saveToken(chatToken, params.persistenceEngine)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        return [2 /*return*/ , sdk];
                }
            });
        });
    };
    SDK.prototype.setConnectivityProviderIfNeeded = function(connectivityProvider) {
        if (connectivityProvider && !this._connectivityProviderWasSet) {
            ConnectivityService.setConnectivityProvider(connectivityProvider);
            this._connectivityProviderWasSet = true;
        }
    };
    /**
     * @function init
     * Initialize the SDK
     * @param initChatSdkParams
     * @return initiliazed sdk
     */
    SDK.prototype.init = function(initChatSdkParams) {
        var _this = this;
        var chatToken = initChatSdkParams.chatToken,
            _a = initChatSdkParams.preFetch,
            preFetch = _a === void 0 ? false : _a;
        this.initServices(initChatSdkParams);
        this._initialized = true;
        this.notifyOnInit();
        var wasOnlineOnInit = ConnectivityService.online;
        ConnectivityService.waitForOnline.then(function() {
            if (preFetch) {
                _this._fetchRooms({
                    isSilent: false
                });
            }
            _this.connectToRealtime({
                chatToken: chatToken,
                eventHooks: _this._eventHooks
            }).catch(function(e) {
                console.error('ErrorOnConnectToRealtime', e);
            });
            _this.serverApi.http$fetchCurrentUserDisplayData().then(function(displayData) {
                _this._currentUser.displayData = displayData;
            });
            _this._connected = true;
            _this._onConnectCallbacks.forEach(function(cb) {
                return cb();
            });
            _this.chatroomsApi.fetchMessageDrafts();
            if (!wasOnlineOnInit) {
                _this.subscriptionService.refreshSubscribedData();
            }
            ConnectivityService.executeEveryTimeOnBackToOnline(_this.reconnect.bind(_this, {
                chatToken: chatToken,
                tokenServer: initChatSdkParams.tokenServer
            }));
            ConnectivityService.executeEveryTimeOnOffline(_this.disconnect.bind(_this));
        });
        return this;
    };
    SDK.prototype.initServices = function(initChatSdkParams) {
        var chatServerUrl = initChatSdkParams.chatServerUrl,
            chatToken = initChatSdkParams.chatToken,
            _a = initChatSdkParams.eventHooks,
            eventHooks = _a === void 0 ? {} : _a,
            _b = initChatSdkParams.experiments,
            experiments = _b === void 0 ? {} : _b,
            appName = initChatSdkParams.appName,
            persistenceEngine = initChatSdkParams.persistenceEngine,
            httpHeaders = initChatSdkParams.httpHeaders,
            tokenServer = initChatSdkParams.tokenServer,
            throttleThreshold = initChatSdkParams.throttleThreshold,
            connectivityProvider = initChatSdkParams.connectivityProvider,
            presenceOptions = initChatSdkParams.presenceOptions;
        _verifyInitParams({
            chatServerUrl: chatServerUrl,
            chatToken: chatToken,
            tokenServer: tokenServer
        });
        this.clear();
        this._currentUser.loadJwtChatToken(chatToken);
        appService.setAppName(appName);
        this._currentUser.token = chatToken;
        this._experiments = experiments;
        this._eventHooks = Object.assign(defaultEventHooks, eventHooks);
        this.realtimeClient = realtimeClientFactory(new FirebaseService(undefined, {
            atomicServerTime: this.isExperimentOn(Constants.experiments.FirebaseAtomicServerTime),
        }));
        var subscriptionService = new SubscriptionService();
        var _throttleThreshold = throttleThreshold !== undefined ? throttleThreshold : DEFAULT_THROTTLE_THRESHOLD;
        var chatAgent;
        if (tokenServer) {
            chatAgent = new ChatAgent({
                baseUrl: chatServerUrl,
                currentUser: this._currentUser,
                httpHeaders: httpHeaders,
                tokenServer: tokenServer,
                throttleThreshold: _throttleThreshold,
            });
        } else {
            chatAgent = new ChatAgent({
                baseUrl: chatServerUrl,
                currentUser: this._currentUser,
                httpHeaders: httpHeaders,
                throttleThreshold: _throttleThreshold,
            });
        }
        this.serverApi = new ServerApi(chatAgent);
        this.setConnectivityProviderIfNeeded(connectivityProvider);
        this.persistenceService = new PersistenceService(persistenceEngine, this.getUserId(), this._currentUser.participantIds);
        this.unseenChatroomCountActions = new UnseenChatroomCountActions(this.serverApi);
        this.unreadChatroomCountActions = new UnreadChatroomCountActions(this.serverApi);
        var unreadChatroomCountActions = this.unreadChatroomCountActions;
        var chatroomsActions = chatroomsActionsFactory(this.serverApi, this.persistenceService, this._eventHooks, this.unseenChatroomCountActions, unreadChatroomCountActions, experiments);
        this.store = this._setupStoreReuseIfNecessary(chatroomsActions);
        this.unseenChatroomCountApi = new UnseenChatroomCountApi({
            store: this.store,
            actions: this.unseenChatroomCountActions,
        });
        this.unreadChatroomCountApi = new UnreadChatroomCountApi({
            store: this.store,
            actions: this.unreadChatroomCountActions,
        });
        var chatroomsApi = new ChatroomsApi({
            store: this.store,
            chatroomsActions: chatroomsActions,
            subscriptionService: subscriptionService,
            serverApi: this.serverApi,
            unreadChatroomCountActions: this.unreadChatroomCountActions,
        });
        var chatroomApi = new ChatroomApi({
            store: this.store,
            chatroomsActions: chatroomsActions,
            subscriptionService: subscriptionService,
            currentUser: this._currentUser,
            enrichedChatroom: this.isExperimentOn(Constants.experiments.EnrichedChatroom),
        });
        this.messagesActions = messagesActionsFactory(this.serverApi);
        var messagesApi = new MessagesApi({
            store: this.store,
            messagesActions: this.messagesActions,
            subscriptionService: subscriptionService,
            drillInMessageIndications: this.isExperimentOn(Constants.experiments.DrillInMessageIndications),
        });
        var textTypingService = new TextTypingService(this.store, chatroomsActions, this.serverApi, this.persistenceService);
        this.presenceOptions = presenceOptions;
        this.presence = new PresencePublicApi(this._currentUser, this.serverApi, this.store);
        Object.assign(this, {
            subscriptionService: subscriptionService,
            chatroomsActions: chatroomsActions,
            chatroomsApi: chatroomsApi,
            chatroomApi: chatroomApi,
            messagesApi: messagesApi,
            textTypingService: textTypingService,
        });
    };
    /**
     * Un-initializes the sdk and disconnects associated realtime sockets. After this call,
     * the sdk is essentially dead until you call init again. Useful if the user logged out or
     * completely switched contexts to the point where a new token will need to be issued and
     * everything started from scratch.
     *
     * If you want to keep the data you have but shutoff the realtime websocket to not abuse the network,
     * use `disconnect` instead.
     */
    SDK.prototype.clear = function() {
        if (this._initialized) {
            this.store.dispatch(this.chatroomsActions.action$resetStore());
            this._initialized = false;
        }
        if (this._connected) {
            this.disconnect();
        }
    };
    /**
     * Disconnects the sdk from receiving realtime events. Useful if you need to be conservative with
     * network traffic, like in a mobile app, because it will close the websocket. If you do this, your data
     * will be stale and you will need to call `reconnect` to get back in sync.
     */
    SDK.prototype.disconnect = function() {
        this.store.dispatch(presenceActions.action$clearPresence());
        this._onDisconnectCallbacks.forEach(function(cb) {
            return cb();
        });
        this.realtimeClient.disconnect();
        this._connected = false;
    };
    //TODO remove chat-agent._issueNewTokenIfNeeded should be removed and use this
    SDK.prototype.reissueTokenIfNeeded = function(_a) {
        var chatToken = _a.chatToken,
            tokenServer = _a.tokenServer;
        return __awaiter(this, void 0, void 0, function() {
            var _b;
            return __generator(this, function(_c) {
                switch (_c.label) {
                    case 0:
                        if (!tokenServer) {
                            return [2 /*return*/ , Promise.reject('TokenServer must be provided')];
                        }
                        if (!(chatToken && !isExpiredToken(chatToken))) return [3 /*break*/ , 1];
                        this._currentUser.token = chatToken;
                        return [3 /*break*/ , 3];
                    case 1:
                        if (!ConnectivityService.online) {
                            return [2 /*return*/ , Promise.reject('Unable to reissue token when offline')];
                        }
                        _b = this._currentUser;
                        return [4 /*yield*/ , getHandshakeChatToken(tokenServer)];
                    case 2:
                        _b.token = _c.sent();
                        _c.label = 3;
                    case 3:
                        this._currentUser.loadJwtChatToken(chatToken);
                        return [2 /*return*/ , this._currentUser.token];
                }
            });
        });
    };
    /**
     * See `disconnect()` - if you disconnected, you have to reconnect. In addition
     * to resuming listening to realtime events, sdk will refresh any data that may be
     * stale if there is an active subscription listening to that data
     * At least one of the following must be provided:
     * @param reconnectParams ReconnectSdkParams
     */
    SDK.prototype.reconnect = function(reconnectParams) {
        return __awaiter(this, void 0, void 0, function() {
            var chatToken;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        this._assertInitialized();
                        if (this._connected) {
                            return [2 /*return*/ ];
                        }
                        return [4 /*yield*/ , this.reissueTokenIfNeeded(reconnectParams)];
                    case 1:
                        chatToken = _a.sent();
                        this._onConnectCallbacks.forEach(function(cb) {
                            return cb();
                        });
                        return [2 /*return*/ , Promise.all([
                            this.subscriptionService.refreshSubscribedData(),
                            this.connectToRealtime({
                                chatToken: chatToken,
                                eventHooks: this._eventHooks
                            }),
                        ])];
                }
            });
        });
    };
    SDK.prototype.reconnectWithHandshake = function(_a) {
        var tokenServer = _a.tokenServer;
        return __awaiter(this, void 0, void 0, function() {
            var chatToken;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        if (!tokenServer) {
                            throw new Error('Trying to reconnect chat-sdk without a `tokenServer`');
                        }
                        if (this._connected) {
                            return [2 /*return*/ ];
                        }
                        return [4 /*yield*/ , getCachedChatToken(this.persistenceService.persistenceEngine)];
                    case 1:
                        chatToken = _b.sent();
                        return [2 /*return*/ , this.reconnect({
                            chatToken: chatToken,
                            tokenServer: tokenServer
                        })];
                }
            });
        });
    };
    /**
     * Register a callback that will be called every time sdk starts opening a connection to our realtime server.
     * Essentially once during initialization and again each time `reconnect` is called.
     * @param callback
     */
    SDK.prototype.onConnecting = function(callback) {
        this._onConnectingCallbacks.push(callback);
    };
    /**
     * Register a callback that will be called every time sdk finishes opening a connection to our realtime server.
     * Essentially once during initialization and again each time `reconnect` is called.
     * @param callback
     */
    SDK.prototype.onConnectionEstablished = function(callback) {
        this._onConnectionEstablishedCallbacks.push(callback);
    };
    /**
     * Register a callback that will be called whenever `disconnect()` is called. This is not intended as a way
     * to monitor whenever a connection is interrupted for reasons other than the consumer calling `disconnect`.
     * @param callback
     */
    SDK.prototype.onDisconnect = function(callback) {
        this._onDisconnectCallbacks.push(callback);
    };
    /**
     * @description You use this subscription when you are
     interested in finding out which chatrooms are relevant
     to the current `chatToken`'s authentication and the provided set of `filter`s.
     The data that comes back in the callback is meant to be enough to render a chatroom list,
     and is order by lastMessage timestamp descending.
  
     Currently, you can filter chatrooms by `participantId`, `isArchived` and `isUnread`. When you subscribe to a filtered list,
     the callback will only be called when a chatroom inside the specified filter changes. You can
     subscribe to multiple filters simultaneously, each one is independent.
     * @param {Function} callback
     * @param filter
     */
    SDK.prototype.subscribeToChatRoomsList = function(_a) {
        var subscriberId = _a.subscriberId,
            callback = _a.callback,
            filter = _a.filter;
        this._assertInitialized();
        return this.chatroomsApi.subscribeToChatRoomsList({
            subscriberId: subscriberId,
            callback: callback,
            filter: filter
        });
    };
    /**
     * @function subscribeToChatRoom
     * get notified when the room is changed.
     * @param {ChatroomId} chatroomId
     * @param {Function} onChange - called with `room` on any change in the room.
     * @param {Function} onNewMessage - called when a new message is added to a *NON EMPTY* room (i.e. will not be called for the first message added)
     * @param {Function} onInitialFetchDone - called when the initial fetch of room data is completed
     * @param {Function} onError - called with `error` string when an error occurs (for example network error)
     * @param onNewRealtimeMessage - Deprecated, do not use
     * @returns {Function} unsubscribe function
     */
    SDK.prototype.subscribeToChatRoom = function(_a) {
        var chatroomId = _a.chatroomId,
            onChange = _a.onChange,
            onNewMessage = _a.onNewMessage,
            onInitialFetchDone = _a.onInitialFetchDone,
            onError = _a.onError;
        this._assertInitialized();
        return this.chatroomApi.subscribeToChatRoom({
            chatroomId: chatroomId,
            onChange: onChange,
            onNewMessage: onNewMessage,
            onInitialFetchDone: onInitialFetchDone,
            onError: onError
        });
    };
    /**
     * Tells the SDK that you want to know how many rooms have unread messages in them.
     The callback will give you a number every time the number of unread rooms changes, unless the count is above
     some threshold, at which point it'll give you the threshold number and a `hasOverflow: true`.
     * @param {GlobalUnreadsCountCallbackFunc} callback
     * @param {UnreadChatroomCountFilter} filter - Filter used when fetching initial unread count
     */
    SDK.prototype.subscribeToGlobalUnreadStatus = function(_a) {
        var callback = _a.callback,
            filter = _a.filter;
        this._assertInitialized();
        if (!filter) {
            throw Error('Filter is now required');
        }
        return this.unreadChatroomCountApi.subscribe(callback, filter);
    };
    /**
     * Tells the SDK that you want to know how many rooms have unread messages in them, broken down by participant.
     The callback will give you a number every time the number of unread rooms changes, unless the count is above
     some threshold (UNREAD_CHATROOM_IDS_COUNT_LIMIT_PER_PARTICIPANT), at which point it'll give you the threshold number, currently - 100.
     * @param {GlobalUnreadsBreakdownCountCallbackFunc} callback
     * @param {UnreadChatroomCountFilter} filter - Filter used when fetching initial unread count
     */
    SDK.prototype.subscribeToBreakdownUnreadStatus = function(_a) {
        var callback = _a.callback,
            filter = _a.filter;
        this._assertInitialized();
        return this.unreadChatroomCountApi.subscribeToBreakdown(callback, filter);
    };
    /**
     *
     * Returns the current snapshot of unread count and a list of unread chat rooms ids.
     * if the unread count is bigger than the "unreadChatroomLimit" param, it will not return the chatrooms ids.
     *
     * @param filter - in case an empty array is passed then the unread is for all sites. Otherwise it's the unread count
     * for the specific participants ids that are passed
     * @param unreadChatroomLimit - optional (default is set to ServerApi.DEFAULT_UNREAD_CHATROOM_IDS_COUNT_LIMIT (100))
     */
    SDK.prototype.getUnreadCount = function(filter, unreadChatroomLimit) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                this._assertInitialized();
                return [2 /*return*/ , this.serverApi.http$fetchUnreadChatroomIds({
                    filter: filter,
                    unreadChatroomLimit: unreadChatroomLimit
                })];
            });
        });
    };
    /**
     * @function subscribeToDrillInMessageIndications
     * Tells the SDK that you want to monitor seen/sent indications changes of a single message.
     the callback will be called only when a new indication added to the relevant message.
     For example: when a contact reads the message via email, the callback will be called with all seen/sent indications relevant to that message.
     Important thing to notice: message indication is different and does not include message status.
     to read more about message status click [here](docs/chat-platform/message-data-model.md#messageStatus).
     * @param {ChatroomId} chatroomId
     * @param {string} messageId
     * @param {number} sequence
     * @param {Function} callback - called with `messages indications` on any change in them.
     * @returns {Function} unsubscribe function
     */
    SDK.prototype.subscribeToDrillInMessageIndications = function(_a) {
        var chatroomId = _a.chatroomId,
            messageId = _a.messageId,
            sequence = _a.sequence,
            callback = _a.callback;
        this._assertInitialized();
        if (this.isExperimentOn(Constants.experiments.DrillInMessageIndications)) {
            return this.messagesApi.subscribeToDrillInMessageIndications({
                chatroomId: chatroomId,
                messageId: messageId,
                sequence: sequence,
                callback: callback
            });
        }
    };
    SDK.prototype.getChatroom = function(_a) {
        var chatroomId = _a.chatroomId;
        this._assertInitialized();
        return this.chatroomApi.getChatroom({
            chatroomId: chatroomId
        });
    };
    SDK.prototype.getUnreadCountForRoom = function(chatroomId) {
        return this.chatroomsApi.getUnreadCountForRoom(chatroomId);
    };
    SDK.prototype.getUnreadCountForRooms = function(chatroomIds) {
        return this.chatroomsApi.getUnreadCountForRooms(chatroomIds);
    };
    SDK.prototype.fetchRooms = function(_a) {
        var filter = _a.filter,
            cursor = _a.cursor,
            _b = _a.isSilent,
            isSilent = _b === void 0 ? false : _b;
        this._assertInitialized();
        return this._fetchRooms({
            filter: filter,
            cursor: cursor,
            isSilent: isSilent
        });
    };
    SDK.prototype.sendMessage = function(message) {
        this._assertInitialized();
        return this.chatroomApi.sendMessage(message);
    };
    /**
     * Adds a message to the chatroom but DOES NOT send it to the server. To send, use `sendMessage`.
     * You do not have to add a message before sending it, but you can choose to do so. Typical use-case:
     * the user selected an image to send, so you want to add it to the chatroom so that it will be rendered
     * in the UI as the last message. But you need to finish uploading it somewhere before you can actually send
     * the message. So you call `addMessage` and then `sendMessage` once the upload is done.
     * @param dto
     * @param transit
     */
    SDK.prototype.addMessage = function(_a) {
        var dto = _a.dto,
            transit = _a.transit;
        this._assertInitialized();
        return this.chatroomApi.addMessage({
            dto: dto,
            transit: transit
        });
    };
    SDK.prototype.addChatrooms = function(_a) {
        var rooms = _a.rooms;
        this._assertInitialized();
        return this.chatroomsApi.addRooms({
            rooms: rooms
        });
    };
    /**
     * persist=false DOES NOT delete messages from the server's database, which is not supported by chat. This delete's only the
     * local, client-side copy of a message. Common use-case: a message failed to send (network error) so only exists
     * client-side. The user can choose to delete the message and try again.x
     * @param messageId
     */
    SDK.prototype.deleteMessage = function(messageId, persist) {
        if (persist === void 0) {
            persist = false;
        }
        this._assertInitialized();
        return this.chatroomApi.deleteMessage(messageId, persist);
    };
    SDK.prototype.resendMessage = function(messageId) {
        this._assertInitialized();
        return this.chatroomApi.resendMessage(messageId);
    };
    SDK.prototype.deleteLabel = function(params) {
        this._assertInitialized();
        return this.chatroomApi.deleteLabel(params);
    };
    SDK.prototype.unstarRoom = function(chatroomId) {
        this._assertInitialized();
        return this.chatroomApi.unstarRoom(chatroomId);
    };
    SDK.prototype.starRoom = function(chatroomId) {
        this._assertInitialized();
        return this.chatroomApi.starRoom(chatroomId);
    };
    SDK.prototype.notifyTyping = function(chatroomId, text) {
        this._assertInitialized();
        return this.textTypingService.notifyTyping(chatroomId, text);
    };
    SDK.prototype.notifyTypingTextChange = function(chatroomId, text, isActive) {
        if (isActive === void 0) {
            isActive = true;
        }
        this._assertInitialized();
        return this.textTypingService.notifyTextChange(chatroomId, text, isActive);
    };
    SDK.prototype.deleteChatroom = function(chatroomId) {
        this._assertInitialized();
        return this.chatroomsApi.deleteChatroom(chatroomId);
    };
    /**
     * @function deleteChatrooms
     * Bulk delete all chatrooms provided.
     * @param chatroomIds an array of chatroomIds
     */
    SDK.prototype.deleteChatrooms = function(chatroomIds) {
        this._assertInitialized();
        return this.chatroomsApi.deleteChatrooms(chatroomIds);
    };
    SDK.prototype.archiveChatroom = function(chatroomId) {
        this._assertInitialized();
        return this.chatroomsApi.archiveChatroom(chatroomId);
    };
    /**
     * @function archiveChatrooms
     * Bulk archive all chatrooms provided.
     * @param chatroomIds an array of chatroomIds
     */
    SDK.prototype.archiveChatrooms = function(chatroomIds) {
        this._assertInitialized();
        return this.chatroomsApi.archiveChatrooms(chatroomIds);
    };
    /**
     * @function unarchiveChatrooms
     * Bulk unarchive all chatrooms provided.
     * @param chatroomIds an array of chatroomIds
     */
    SDK.prototype.unarchiveChatrooms = function(chatroomIds) {
        this._assertInitialized();
        return this.chatroomsApi.unarchiveChatrooms(chatroomIds);
    };
    SDK.prototype.unarchiveChatroom = function(chatroomId) {
        this._assertInitialized();
        return this.chatroomsApi.unarchiveChatroom(chatroomId);
    };
    SDK.prototype.setLastMessageUnread = function(_a) {
        var chatroomId = _a.chatroomId;
        this._assertInitialized();
        return this.chatroomApi.setLastMessageUnread({
            chatroomId: chatroomId
        });
    };
    SDK.prototype.isExperimentOn = function(experiment) {
        return isExperimentOn(this._experiments, experiment);
    };
    SDK.prototype.getUserId = function() {
        return this._currentUser.userId;
    };
    SDK.prototype.clearPersistence = function() {
        if (this.persistenceService) {
            this.persistenceService.clearMessageDrafts();
            this.persistenceService.clearToken();
        }
    };
    /**
     * @function setAllRoomsAsRead
     *
     * Set all chat rooms for a given filter to be read.
     * If a filter is not provided all rooms will be set to read.
     * @param {ChatroomsListFilter} filter of chatrooms
     */
    SDK.prototype.setAllRoomsAsRead = function(filter, updateServer) {
        if (updateServer === void 0) {
            updateServer = true;
        }
        return this.chatroomsApi.markAllRoomsAsRead(filter, updateServer);
    };
    /**
     * @function setMessagesRead
     *
     * Set messages as read for a specific room.
     * Note that latest (known) message sequence will be set for the room (meaning that on a rare race condition,
     * if another message is received around the time this call is made, room can go back to an unread state).
     * @param {chatroomId}
     */
    SDK.prototype.setMessagesRead = function(_a) {
        var chatroomId = _a.chatroomId;
        this._assertInitialized();
        return this.chatroomApi.setMessagesRead({
            chatroomId: chatroomId
        });
    };
    /**
     * @function setRoomsMessagesRead
     *
     * Set messages as read for a provided rooms ids.
     * Note that latest (known) message sequence will be set for each room (meaning that on a rare race condition,
     * if another message is received around the time this call is made, room can go back to an unread state).
     * @param {chatroomIds}
     */
    SDK.prototype.setRoomsMessagesRead = function(chatroomIds) {
        return this.chatroomApi.setRoomsMessagesRead(chatroomIds);
    };
    /**
     * @function: search
     *
     * @description search for a specific search term in all chatrooms name and messages.
     * Returns search results according to SearchResults type.
     * @param searchTerm: string
     * @param participantIds: string[] - relevant search results only for given participantIds
     */
    SDK.prototype.search = function(_a) {
        var searchTerm = _a.searchTerm,
            participantIds = _a.participantIds,
            _b = _a.chatroomsPageSize,
            chatroomsPageSize = _b === void 0 ? 10 : _b,
            _c = _a.chatroomsNextPointer,
            chatroomsNextPointer = _c === void 0 ? 0 : _c,
            _d = _a.messagesPageSize,
            messagesPageSize = _d === void 0 ? 10 : _d,
            _e = _a.messagesNextPointer,
            messagesNextPointer = _e === void 0 ? 0 : _e;
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_f) {
                return [2 /*return*/ , this.chatroomsApi.search({
                    searchTerm: searchTerm,
                    participantIds: participantIds,
                    chatroomsPageSize: chatroomsPageSize,
                    chatroomsNextPointer: chatroomsNextPointer,
                    messagesPageSize: messagesPageSize,
                    messagesNextPointer: messagesNextPointer,
                })];
            });
        });
    };
    /**
     * @function: getMessagesPage
     *
     * @description get a specific messages page accrodind to given message sequence
     * @param chatroomId: string
     * @param messageSequence: number - the messageSequence that will be in the middle of the given page
     * @param pageSize: number
     */
    SDK.prototype.getMessagesPage = function(_a) {
        var chatroomId = _a.chatroomId,
            messageSequence = _a.messageSequence,
            pageSize = _a.pageSize;
        return __awaiter(this, void 0, void 0, function() {
            var messages;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        return [4 /*yield*/ , this.serverApi.http$fetchRoomMessagesPage({
                            chatroomId: chatroomId,
                            messageSequence: messageSequence,
                            pageSize: pageSize
                        })];
                    case 1:
                        messages = _b.sent();
                        return [2 /*return*/ , messages.reverse().map(function(message) {
                            return new Message(message);
                        })];
                }
            });
        });
    };
    /**
     * @function: buttonInteraction
     *
     * @description reacts to a button interaction (click)
     * @param button: Button - the clicked button, with it's metadata
     * @param chatroomId: string
     */
    SDK.prototype.buttonInteraction = function(button, chatroomId) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        this._assertInitialized();
                        return [4 /*yield*/ , this.chatroomApi.buttonInteraction(button, chatroomId)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/ ];
                }
            });
        });
    };
    /**
     * @function: updateHttpHeaders
     *
     * @description Updates the headers that all the agent's http requests are sent with. This is useful in cases like authentication-related headers that expire and need refreshed.
     * @param headers: An object containing HTTP header key-value pairs. This will update existing headers, but won't get rid of any.
     *
     * You may need to call `reconnect()` after updating the headers.
     */
    SDK.prototype.updateHttpHeaders = function(headers) {
        this.serverApi.updateHttpHeaders(headers);
    };
    SDK.prototype.notifyOnInit = function() {
        this._onInitCallbacks.forEach(function(callback) {
            return callback();
        });
    };
    SDK.prototype._registerOnInit = function(callback) {
        if (!this._initialized) {
            this._onInitCallbacks.push(callback);
        } else {
            callback();
        }
    };
    SDK.prototype.connectToRealtime = function(_a) {
        var _this = this;
        var _b, _c;
        var chatToken = _a.chatToken,
            eventHooks = _a.eventHooks;
        if (!((_b = this.presenceOptions) === null || _b === void 0 ? void 0 : _b.disableWatch)) {
            this.presence.watch((_c = this.presenceOptions) === null || _c === void 0 ? void 0 : _c.useNewConvention);
        }
        this.store.dispatch(presenceActions.action$clearStalePresenceSessions());
        this._onConnectingCallbacks.forEach(function(cb) {
            return cb();
        });
        if (!chatToken) {
            return Promise.reject('Unexpected error: Unable to connect to realtime without a chatToken');
        }
        return this.serverApi
            .http$initRealtimeToken(chatToken)
            .then(function(realtimeServiceSetup) {
                return _this.realtimeClient.connect({
                    realtimeServiceSetup: realtimeServiceSetup,
                    onEvent: function(data) {
                        return onRealtimeEvent({
                            store: _this.store,
                            chatroomsActions: _this.chatroomsActions,
                            messagesActions: _this.messagesActions,
                            data: data,
                            currentUser: _this._currentUser,
                        });
                    },
                    eventHooks: eventHooks,
                });
            })
            .then(function() {
                return _this._onConnectionEstablishedCallbacks.forEach(function(cb) {
                    return cb();
                });
            });
    };
    SDK.prototype._fetchRooms = function(_a) {
        var _b = _a.filter,
            filter = _b === void 0 ? undefined : _b,
            _c = _a.cursor,
            cursor = _c === void 0 ? undefined : _c,
            _d = _a.isSilent,
            isSilent = _d === void 0 ? false : _d;
        return this.chatroomsApi.fetchRooms({
            filter: filter,
            cursor: cursor,
            isSilent: isSilent
        });
    };
    SDK.prototype._assertInitialized = function() {
        if (!this.initialized) {
            throw new Error('Trying to call chat-sdk without having it initialized');
        }
    };
    SDK.prototype._setupStoreReuseIfNecessary = function(chatroomsActions) {
        if (!this.existingStore) {
            this.existingStore = setupStore();
            return this.existingStore;
        } else {
            var store = this.existingStore;
            store.dispatch(chatroomsActions.action$resetStore());
            return store;
        }
    };
    return SDK;
}());

function _verifyInitParams(_a) {
    var chatServerUrl = _a.chatServerUrl,
        chatToken = _a.chatToken,
        tokenServer = _a.tokenServer;
    if (!chatToken && !tokenServer) {
        throw new Error('Trying to initialize chat-sdk without chatToken or tokenServer');
    }
    if (!chatServerUrl) {
        throw new Error('Trying to initialize chat-sdk without chatServerUrl');
    }
}
var defaultEventHooks = {
    reportMonitoringBi: function() {
        return null;
    }
};
var getSdkFromWindowOrCreateNew = function() {
    if (typeof window === 'object') {
        if (!window.chatSdk) {
            window.chatSdk = new SDK();
        }
        return window.chatSdk;
    }
    return new SDK();
};
export var chatSdk = getSdkFromWindowOrCreateNew();