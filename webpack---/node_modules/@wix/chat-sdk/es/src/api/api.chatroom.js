import {
    __assign,
    __awaiter,
    __generator
} from "tslib";
import _isEmpty from 'lodash/isEmpty';
import _maxBy from 'lodash/maxBy';
import _get from 'lodash/get';
import _difference from 'lodash/difference';
import * as messageDraftInitialStateCache from '../state/helpers/message-draft.initial-state-cache';
import * as chatEventEmitter from '../services/chat-event-emitter.service';
import Message from '../domain/message';
import {
    createGetChatroomMessagesSelector
} from '../state/reducer/selector.messages';
import {
    getChatRoom
} from '../state/stateReader';
import getRoomListener from './room-listener';
import {
    getMissingParticipantIds
} from '../state/helpers/participants.helper';
import * as constants from '../constants/constants';
import {
    getLastMessageSequence
} from '../state/reducer/selector.chatrooms';
import {
    buildEnrichedChatroomFromState
} from '../domain/enriched-chat-room';
import {
    chatSdk
} from './chat-sdk';
import {
    Chatroom
} from '../domain/chat-room';
import MessageOptions from '../domain/message-options';
import {
    calculateNextUnreadableSequence
} from './message-sequence';
import {
    STAR_LABEL_ID
} from '../constants/constants';
var ChatroomApi = /** @class */ (function() {
    function ChatroomApi(_a) {
        var store = _a.store,
            chatroomsActions = _a.chatroomsActions,
            subscriptionService = _a.subscriptionService,
            currentUser = _a.currentUser,
            enrichedChatroom = _a.enrichedChatroom;
        this.store = store;
        this.chatroomsActions = chatroomsActions;
        this.subscriptionService = subscriptionService;
        this.currentUser = currentUser;
        this.enrichedChatroom = enrichedChatroom;
    }
    ChatroomApi.prototype.subscribeToChatRoom = function(_a) {
        var _this = this;
        var chatroomId = _a.chatroomId,
            onChange = _a.onChange,
            onNewMessage = _a.onNewMessage,
            onInitialFetchDone = _a.onInitialFetchDone,
            onError = _a.onError;
        var _b = this,
            store = _b.store,
            chatroomsActions = _b.chatroomsActions;
        messageDraftInitialStateCache.invalidate(chatroomId);
        var _notifyChanges = getRoomListener(chatroomId);
        _notifyChanges({
            store: store,
            onChange: onChange,
            onNewMessage: onNewMessage,
            onError: onError
        });
        var removeStoreSubscription = store.subscribe(function() {
            return _notifyChanges({
                store: store,
                onChange: onChange,
                onNewMessage: onNewMessage,
                onError: onError
            });
        });
        var getData = this._createDataFetcher(chatroomId, onInitialFetchDone);
        setTimeout(function() {
            return getData();
        }, 0); // defer to next event loop so the subscriber could process existing data
        var removeFromSubscriptionService = this._registerSubscription(chatroomId, getData);
        var fetchMissingParticipantsDisplayData = function(enrichedChatroom) {
            var participantIdsFromIndicationsDto = enrichedChatroom.indications.lastMessageIndications.map(function(indication) {
                return indication.participantId;
            });
            var participantIdsFromParticipantsDto = enrichedChatroom.participants.items.map(function(participant) {
                return participant.id;
            });
            if (_isEmpty(_difference(participantIdsFromIndicationsDto, participantIdsFromParticipantsDto))) {
                return;
            }
            var missingParticipantIdsFromState = getMissingParticipantIds(participantIdsFromIndicationsDto);
            if (!_isEmpty(missingParticipantIdsFromState)) {
                store.dispatch(chatroomsActions.action$fetchRoomParticipantsDisplayData(chatroomId, missingParticipantIdsFromState));
            }
        };
        chatEventEmitter.addListener(chatEventEmitter.CHAT_INTERNAL_EVENTS.FETCH_ENRICHED_CHATROOM_COMPLETED, fetchMissingParticipantsDisplayData);
        var fetchMessageErrorIndications = function() {
            _this.store.dispatch(_this.chatroomsActions.fetchMessageErrorIndications(chatroomId));
        };
        return {
            fetchMore: function(cursor) {
                store.dispatch(chatroomsActions.fetchRoomMessages(chatroomId, cursor)).then(function() {
                    fetchMessageErrorIndications();
                });
            },
            unsubscribe: function() {
                removeStoreSubscription();
                removeFromSubscriptionService();
                chatEventEmitter.removeListener(chatEventEmitter.CHAT_INTERNAL_EVENTS.FETCH_ENRICHED_CHATROOM_COMPLETED, fetchMissingParticipantsDisplayData);
            },
        };
    };
    ChatroomApi.prototype._registerSubscription = function(chatroomId, getData) {
        var subscriptionIdentifier = {
            chatroomId: chatroomId
        };
        return this.subscriptionService.registerSubscription(subscriptionIdentifier, getData);
    };
    ChatroomApi.prototype._createDataFetcher = function(chatroomId, onInitialFetchDone) {
        var _this = this;
        // called on initial room fetch AND on refresh (via subscriptionService)
        return function() {
            return Promise.all([
                    _this.store.dispatch(_this.chatroomsActions.action$fetchRoom(chatroomId, _this.enrichedChatroom)),
                    _this.store.dispatch(_this.chatroomsActions.fetchRoomMessages(chatroomId)),
                ])
                .then(function() {
                    _this.store.dispatch(_this.chatroomsActions.fetchMessageErrorIndications(chatroomId));
                    if (onInitialFetchDone) {
                        var state = _this.store.getState();
                        var chatroom = buildEnrichedChatroomFromState(state, chatroomId);
                        onInitialFetchDone(chatroom);
                    }
                })
                .catch(function(e) {
                    console.error('CHAT4893 Error on room initial fetch', e);
                });
        };
    };
    ChatroomApi.prototype.getChatroom = function(_a) {
        var chatroomId = _a.chatroomId;
        return __awaiter(this, void 0, void 0, function() {
            var chatRoom;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        chatRoom = getChatRoom(this.store.getState(), chatroomId);
                        if (!_isEmpty(chatRoom)) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , this.store.dispatch(this.chatroomsActions.action$fetchRoom(chatroomId, this.enrichedChatroom))];
                    case 1:
                        _b.sent();
                        chatRoom = getChatRoom(this.store.getState(), chatroomId);
                        _b.label = 2;
                    case 2:
                        return [2 /*return*/ , new Chatroom(chatRoom)];
                }
            });
        });
    };
    ChatroomApi.prototype.setMessagesRead = function(_a) {
        var chatroomId = _a.chatroomId;
        var lastReadMessageSequence = getLastMessageSequence(this.store.getState(), chatroomId);
        if (lastReadMessageSequence) {
            return this.store.dispatch(this.chatroomsActions.action$setMessagesRead(chatroomId, lastReadMessageSequence));
        }
    };
    ChatroomApi.prototype.setRoomsMessagesRead = function(chatroomIds) {
        var state = this.store.getState();
        var chatroomIdWithMostRecentMessageSequence = _maxBy(chatroomIds, function(chatroomId) {
            return _get(getChatRoom(state, chatroomId), 'lastMessage.sequence');
        });
        var mostRecentLastMessageSequence = chatroomIdWithMostRecentMessageSequence &&
            _get(getChatRoom(state, chatroomIdWithMostRecentMessageSequence), 'lastMessage.sequence');
        if (mostRecentLastMessageSequence) {
            this.store.dispatch(this.chatroomsActions.action$setRoomsMessagesRead(chatroomIds, mostRecentLastMessageSequence));
        }
    };
    ChatroomApi.prototype.setLastMessageUnread = function(_a) {
        var chatroomId = _a.chatroomId;
        var state = this.store.getState();
        var messages = createGetChatroomMessagesSelector(chatroomId)(state);
        var chatroom = getChatRoom(state, chatroomId);
        var unreadableSequence = calculateNextUnreadableSequence(chatroom.lastReadMessageSequence, messages, this.currentUser.userId);
        if (unreadableSequence) {
            return this.store.dispatch(this.chatroomsActions.action$setLastMessageUnread(chatroomId, unreadableSequence));
        }
    };
    ChatroomApi.prototype.sendMessage = function(_a) {
        var dto = _a.dto;
        var _b = this,
            currentUser = _b.currentUser,
            store = _b.store,
            chatroomsActions = _b.chatroomsActions;
        var dtoWithCurrentUserDetails = __assign(__assign({}, dto), {
            sender: dto.sender || {
                userId: currentUser.userId,
                type: currentUser.type
            },
            senderDisplayData: currentUser.displayData
        });
        var messageToSend = new Message(dtoWithCurrentUserDetails);
        var sendMessageAction = chatroomsActions.action$sendMessage(messageToSend);
        return store.dispatch(sendMessageAction);
    };
    ChatroomApi.prototype.addMessage = function(_a) {
        var _b;
        var dto = _a.dto,
            transit = _a.transit;
        return __awaiter(this, void 0, void 0, function() {
            var _c, currentUser, store, chatroomsActions, messageIsFromCurrentUser, message, chatroomId, chatroomById, isEnrichedChatroom, fetchPromise;
            return __generator(this, function(_d) {
                switch (_d.label) {
                    case 0:
                        _c = this, currentUser = _c.currentUser, store = _c.store, chatroomsActions = _c.chatroomsActions;
                        messageIsFromCurrentUser = !((_b = dto.sender) === null || _b === void 0 ? void 0 : _b.userId) || dto.sender.userId == currentUser.userId;
                        message = Object.assign(dto, {
                                transit: transit
                            }, messageIsFromCurrentUser ?
                            {
                                senderDisplayData: currentUser.displayData,
                                sender: {
                                    userId: currentUser.userId
                                },
                            } :
                            {});
                        chatroomId = dto.chatroomId;
                        chatroomById = store.getState().chatrooms.byId[chatroomId];
                        if (!(!chatroomById || !chatroomById.id)) return [3 /*break*/ , 2];
                        isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
                        fetchPromise = store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom));
                        return [4 /*yield*/ , fetchPromise];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2:
                        return [2 /*return*/ , store.dispatch(chatroomsActions.action$addMessage(message, true, store.getState().chatrooms.byId[chatroomId]))];
                }
            });
        });
    };
    ChatroomApi.prototype.deleteMessage = function(messageId, persist) {
        if (persist === void 0) {
            persist = false;
        }
        var _a = this,
            store = _a.store,
            chatroomsActions = _a.chatroomsActions;
        var deleteMessageAction = chatroomsActions.action$deleteMessage(messageId, persist);
        return store.dispatch(deleteMessageAction);
    };
    ChatroomApi.prototype.resendMessage = function(messageId) {
        var _a = this,
            store = _a.store,
            chatroomsActions = _a.chatroomsActions;
        var resendMessageAction = chatroomsActions.action$resendMessage(messageId);
        return store.dispatch(resendMessageAction);
    };
    ChatroomApi.prototype.deleteLabel = function(_a) {
        var chatroomId = _a.chatroomId,
            labelId = _a.labelId;
        var _b = this,
            store = _b.store,
            chatroomsActions = _b.chatroomsActions;
        var deleteLabelAction = chatroomsActions.action$removeRoomLabels([{
            chatroomId: chatroomId,
            labelId: labelId
        }], true);
        return store.dispatch(deleteLabelAction);
    };
    ChatroomApi.prototype.unstarRoom = function(chatroomId) {
        return this.deleteLabel({
            chatroomId: chatroomId,
            labelId: STAR_LABEL_ID
        });
    };
    ChatroomApi.prototype.starRoom = function(chatroomId) {
        var _a = this,
            store = _a.store,
            chatroomsActions = _a.chatroomsActions;
        var updateLabelAction = chatroomsActions.action$updateRoomLabel({
            chatroomId: chatroomId,
            labelId: STAR_LABEL_ID
        });
        return store.dispatch(updateLabelAction);
    };
    ChatroomApi.prototype.buttonInteraction = function(button, chatroomId) {
        var _a = this,
            store = _a.store,
            currentUser = _a.currentUser,
            chatroomsActions = _a.chatroomsActions;
        switch (button.type) {
            case 'POSTBACK':
                {
                    if (button.payload) {
                        var message = Message.fromText({
                            text: button.text,
                            chatroomId: chatroomId,
                            userId: currentUser.userId,
                            userType: currentUser.type,
                            summary: button.text,
                            isEphemeral: true,
                            isSilent: true,
                        });
                        var messageOptions = new MessageOptions({
                            chatAction: __assign({
                                actionType: 'BUTTON_INTERACTION'
                            }, button.payload),
                        });
                        return store.dispatch(chatroomsActions.action$sendPostbackMessage(message, messageOptions));
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
    };
    return ChatroomApi;
}());
export default ChatroomApi;