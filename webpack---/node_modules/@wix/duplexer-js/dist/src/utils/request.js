"use strict";
var __extends = (this && this.__extends) || (function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({
                    __proto__: []
                }
                instanceof Array && function(d, b) {
                    d.__proto__ = b;
                }) ||
            function(d, b) {
                for (var p in b)
                    if (b.hasOwnProperty(p)) d[p] = b[p];
            };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);

        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function(mod) {
    return (mod && mod.__esModule) ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
var deferred_1 = __importDefault(require("./deferred"));
var ResponseError = /** @class */ (function(_super) {
    __extends(ResponseError, _super);

    function ResponseError(reason, response) {
        var _this = _super.call(this, reason) || this;
        _this.reason = reason;
        _this.response = response;
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, ResponseError.prototype);
        return _this;
    }
    ResponseError.prototype.getStatus = function() {
        return (this.response && this.response.status) || -1;
    };
    return ResponseError;
}(Error));
exports.ResponseError = ResponseError;

function isCancel(error) {
    return error.reason === 'canceled';
}
exports.isCancel = isCancel;

function post(url, payload, config) {
    if (config === void 0) {
        config = {};
    }
    var deferred = new deferred_1.default();
    var headers = config.headers || {};
    var request = new XMLHttpRequest();
    request.open('POST', url, true);
    request.onreadystatechange = function() {
        if (request.readyState !== 4) {
            return;
        }
        // request errored out, will be handled by onerror handler
        if (request.status === 0) {
            return;
        }
        var response = {
            data: maybeJSON(request.responseText),
            status: request.status,
        };
        settle(deferred, request, response);
    };
    request.onerror = function() {
        return deferred.reject(new ResponseError('network error'));
    };
    if (payload !== undefined) {
        request.setRequestHeader('Content-Type', 'application/json;charset=utf-8');
    }
    if (config.onChunk !== undefined) {
        var prevIndex_1 = 0;
        request.onprogress = function() {
            if (request.status !== 200) {
                return;
            }
            var currIndex = request.responseText.length;
            if (prevIndex_1 === currIndex) {
                return;
            }
            request.responseText
                .substring(prevIndex_1, currIndex)
                .split('\n')
                .filter(function(x) {
                    return x;
                })
                .forEach(function(chunk) {
                    return config.onChunk(maybeJSON(chunk));
                });
            prevIndex_1 = currIndex;
        };
    }
    var xsrf = readCookie('XSRF-TOKEN');
    if (xsrf !== undefined) {
        headers['X-XSRF-TOKEN'] = xsrf;
    }
    Object.keys(headers).forEach(function(key) {
        var value = headers[key];
        request.setRequestHeader(key, value);
    });
    if (config.cancelToken !== undefined) {
        config.cancelToken.promise.then(function() {
            request.abort();
            deferred.reject(new ResponseError('canceled'));
        });
    }
    if (payload === undefined) {
        payload = null; // IE tends to send "undefined" as string
    } else {
        payload = JSON.stringify(payload);
    }
    request.send(payload);
    return deferred.promise;
}
exports.post = post;

function readCookie(name) {
    var match = typeof window !== 'undefined' &&
        window.document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    return match ? decodeURIComponent(match[3]) : undefined;
}

function settle(deferred, request, response) {
    if (verifyStatus(request)) {
        deferred.resolve(response);
    } else {
        deferred.reject(new ResponseError('server error', response));
    }
}

function verifyStatus(request) {
    var status = request.status;
    return status >= 200 && status < 300;
}

function maybeJSON(data) {
    try {
        return JSON.parse(data);
    } catch (_a) {
        return data;
    }
}
//# sourceMappingURL=request.js.map