import {
    __assign,
    __awaiter,
    __generator
} from "tslib";
import {
    isIdle
} from '@wix/toolbelt';
import {
    Status,
} from './domain';
import {
    uuid,
    deepEqual,
    copy,
    toActivity
} from './utils';
import {
    PresenceService
} from '@wix/ambassador-presence-service/http';
import {
    INIT_BATCH_TIME,
    KEEP_ALIVE_TIME,
    PRESENCE_URL,
    WATCH_GROUP_TIME,
} from './constants';
var TrackState;
(function(TrackState) {
    TrackState[TrackState["INIT"] = 0] = "INIT";
    TrackState[TrackState["SUBSCRIBED"] = 1] = "SUBSCRIBED";
})(TrackState || (TrackState = {}));
var UpdateType;
(function(UpdateType) {
    UpdateType[UpdateType["NONE"] = 0] = "NONE";
    UpdateType[UpdateType["STATE"] = 1] = "STATE";
    UpdateType[UpdateType["ACTIVITY"] = 2] = "ACTIVITY";
})(UpdateType || (UpdateType = {}));
var IDLE_TIME = 1000 * 60 * 10; // 10 min
var Group = /** @class */ (function() {
    function Group(_a) {
        var _this = this;
        var getPresenceConnection = _a.getPresenceConnection,
            scope = _a.scope,
            getSignedInstance = _a.getSignedInstance,
            _b = _a.initialState,
            initialState = _b === void 0 ? {} : _b,
            _c = _a.keepAliveInterval,
            keepAliveInterval = _c === void 0 ? KEEP_ALIVE_TIME : _c,
            isIdleMs = _a.isIdleMs,
            onIdle = _a.onIdle,
            onActive = _a.onActive;
        var _d, _e;
        this.onStateChangeFn = function() {};
        this.sessionId = uuid();
        this.trackState = TrackState.INIT;
        this.lastInactivity = null;
        this.list = [];
        this.onDisconnectFn = function() {};
        this.shuoldWatchGroup = true;
        this.onIdle = function() {
            _this.lastInactivity = Date.now() - _this.isIdleMs;
            _this.refreshState();
            _this.onIdleFn();
        };
        this.onActive = function() {
            _this.lastInactivity = null;
            _this.refreshState();
            _this.onActiveFn();
        };
        this.watchGroup = function() {
            if (_this.shuoldWatchGroup) {
                _this.presenceClient()
                    .watch({
                        scope: _this.scope
                    })
                    .catch(function() {});
            }
            if (_this.watchGroupTimer) {
                clearTimeout(_this.watchGroupTimer);
            }
            _this.watchGroupTimer = setTimeout(function() {
                return _this.watchGroup();
            }, WATCH_GROUP_TIME);
        };
        this.onSubscribe = function() {
            return __awaiter(_this, void 0, void 0, function() {
                var _this = this;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            this.list = [];
                            this.trackState = TrackState.INIT;
                            if (this.initBatchTimer) {
                                clearTimeout(this.initBatchTimer);
                            }
                            this.watchGroup();
                            // we await in order to get a better chance to get
                            // that SetPresence update on the initial batch
                            return [4 /*yield*/ , this.keepAlive()];
                        case 1:
                            // we await in order to get a better chance to get
                            // that SetPresence update on the initial batch
                            _a.sent();
                            this.idle.listen();
                            this.initBatchTimer = setTimeout(function() {
                                _this.trackState = TrackState.SUBSCRIBED;
                                _this.onStateChange();
                            }, INIT_BATCH_TIME);
                            return [2 /*return*/ ];
                    }
                });
            });
        };
        this.handleStateChanges = function(presentity) {
            // in case Presence's GC kicks in - auto offline
            // sends the event with no data at all
            presentity.data = presentity.data || {};
            var updateType = _this.updateList(presentity);
            if (_this.trackState === TrackState.SUBSCRIBED &&
                updateType === UpdateType.STATE) {
                _this.onStateChange(presentity);
            }
        };
        this.getPresenceConnection = getPresenceConnection;
        this.getSignedInstance = getSignedInstance;
        this.keepAliveInterval = keepAliveInterval;
        this.scope = scope;
        this.storeState(initialState);
        this.isIdleMs = (_e = (_d = window.__PRESENCE_IDLE_TIME) !== null && _d !== void 0 ? _d : isIdleMs) !== null && _e !== void 0 ? _e : IDLE_TIME;
        this.onIdleFn = onIdle !== null && onIdle !== void 0 ? onIdle : (function() {});
        this.onActiveFn = onActive !== null && onActive !== void 0 ? onActive : (function() {});
        this.idle = isIdle({
            isIdleTime: this.isIdleMs,
            onIdle: this.onIdle,
            onActive: this.onActive,
        });
        this.presenceApi = PresenceService(PRESENCE_URL, {
            ignoredProtoHttpUrlPart: '/api',
        }).PresenceService();
    }
    Group.prototype.track = function(onStateChange, opts) {
        var _a;
        this.onStateChangeFn = onStateChange;
        this.shuoldWatchGroup = (_a = opts === null || opts === void 0 ? void 0 : opts.watchGroup) !== null && _a !== void 0 ? _a : this.shuoldWatchGroup;
        this.connection = this.getPresenceConnection();
        var info = {
            presenceSessionId: this.sessionId,
            watchGroup: opts === null || opts === void 0 ? void 0 : opts.watchGroup,
        };
        this.connection.on('@duplexer:disconnected', this.onDisconnectFn);
        return this.connection
            .subscribe(this.scope, {
                info: info
            })
            .on('@duplexer:subscription_succeeded', this.onSubscribe)
            .on('update-state', this.handleStateChanges);
    };
    Group.prototype.disconnect = function() {
        if (this.connection) {
            this.connection.disconnect();
            this.connection = undefined;
        }
    };
    Group.prototype.onDisconnect = function(onDisconnectFn) {
        this.onDisconnectFn = onDisconnectFn;
    };
    Group.prototype.setState = function(state) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        this.storeState(state);
                        if (!this.connection) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , this.presenceClient().setData({
                            sessionId: this.sessionId,
                            scope: this.scope,
                            data: this.state,
                        })];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [2 /*return*/ ];
                }
            });
        });
    };
    Group.prototype.getSessionId = function() {
        return this.sessionId;
    };
    Group.prototype.emptyGroup = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        return [4 /*yield*/ , this.presenceClient().resetScope({
                            scope: this.scope,
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/ ];
                }
            });
        });
    };
    Group.prototype.storeState = function(state) {
        this.state = __assign(__assign({}, state), {
            __lastInactivity: this.lastInactivity
        });
    };
    Group.prototype.refreshState = function() {
        return this.setState(this.state);
    };
    Group.prototype.keepAlive = function() {
        return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.connection) {
                            clearTimeout(this.keepAliveTimer);
                            return [2 /*return*/ ];
                        }
                        return [4 /*yield*/ , this.refreshState().catch(function() {})];
                    case 1:
                        _a.sent();
                        if (this.keepAliveTimer) {
                            clearTimeout(this.keepAliveTimer);
                        }
                        this.keepAliveTimer = setTimeout(function() {
                            return _this.keepAlive();
                        }, this.keepAliveInterval);
                        return [2 /*return*/ ];
                }
            });
        });
    };
    Group.prototype.onStateChange = function(presentity) {
        this.onStateChangeFn(copy(this.list), presentity ? copy(presentity) : undefined);
    };
    Group.prototype.updateList = function(presentity) {
        var prev = this.list.find(function(p) {
            return p.userId === presentity.userId && p.sessionId === presentity.sessionId;
        });
        presentity.activity = toActivity(presentity);
        // when someone starts watching a group, the entire group
        // is being sent to everyone. we may want to solve it.
        if (prev && deepEqual(prev, presentity)) {
            return UpdateType.NONE;
        }
        if (prev) {
            this.list = this.list.filter(function(p) {
                return p !== prev;
            });
        }
        if (presentity.status === Status.ONLINE) {
            this.list.push(presentity);
        }
        return UpdateType.STATE;
    };
    Group.prototype.presenceClient = function() {
        return this.presenceApi({
            Authorization: this.getSignedInstance(),
        });
    };
    return Group;
}());
export default Group;
//# sourceMappingURL=group.js.map