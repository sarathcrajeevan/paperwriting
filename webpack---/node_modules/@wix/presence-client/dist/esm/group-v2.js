import {
    __assign,
    __awaiter,
    __generator
} from "tslib";
import {
    isIdle
} from '@wix/toolbelt';
import {
    Scope
} from './domain';
import {
    setPresence,
    updatePresence,
} from '@wix/ambassador-presence-v2-presence/http';
import {
    Scope as ScopeV2,
    PresenceStatus,
} from '@wix/ambassador-presence-v2-presence/types';
import {
    HttpClient
} from '@wix/http-client';
import {
    KEEP_ALIVE_TIME
} from './constants';
import {
    uuid
} from './utils';
var IDLE_TIME = 1000 * 60 * 10; // 10 min
var GroupV2 = /** @class */ (function() {
    function GroupV2(_a) {
        var _this = this;
        var getPresenceConnection = _a.getPresenceConnection,
            scope = _a.scope,
            getSignedInstance = _a.getSignedInstance,
            _b = _a.initialState,
            initialState = _b === void 0 ? {} : _b,
            _c = _a.keepAliveInterval,
            keepAliveInterval = _c === void 0 ? KEEP_ALIVE_TIME : _c,
            isIdleMs = _a.isIdleMs,
            onIdle = _a.onIdle,
            onActive = _a.onActive;
        var _d, _e;
        this.sessionId = uuid();
        this.onDisconnectFn = function() {};
        this.shouldWatchGroup = true;
        this.onIdle = function() {
            void _this.updatePresence({});
            _this.onIdleFn();
        };
        this.onActive = function() {
            var _a = _this.preparePayload(),
                payload = _a.payload,
                mask = _a.mask;
            mask.push('status');
            void _this.updateState({
                mask: mask,
                presence: {
                    scope: _this.scope,
                    sessionId: _this.sessionId,
                    status: PresenceStatus.ACTIVE,
                    payload: payload,
                },
            });
            _this.onActiveFn();
        };
        this.onSubscribe = function() {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/ , this.keepAlive()];
                        case 1:
                            _a.sent();
                            this.idle.listen();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
        this.getPresenceConnection = getPresenceConnection;
        this.keepAliveInterval = keepAliveInterval;
        this.scope = scope;
        this.isIdleMs = (_e = (_d = window.__PRESENCE_IDLE_TIME) !== null && _d !== void 0 ? _d : isIdleMs) !== null && _e !== void 0 ? _e : IDLE_TIME;
        this.onIdleFn = onIdle !== null && onIdle !== void 0 ? onIdle : (function() {});
        this.onActiveFn = onActive !== null && onActive !== void 0 ? onActive : (function() {});
        this.initialState = initialState;
        this.idle = isIdle({
            isIdleTime: this.isIdleMs,
            onIdle: this.onIdle,
            onActive: this.onActive,
        });
        this.httpClient = new HttpClient({
            getAppToken: getSignedInstance,
        });
    }
    GroupV2.prototype.track = function(opts) {
        var _a;
        this.shouldWatchGroup = (_a = opts === null || opts === void 0 ? void 0 : opts.watchGroup) !== null && _a !== void 0 ? _a : this.shouldWatchGroup;
        this.connection = this.getPresenceConnection();
        this.createState(this.initialState);
        var info = {
            presenceSessionId: this.sessionId,
            watchGroup: opts === null || opts === void 0 ? void 0 : opts.watchGroup,
        };
        this.connection.on('@duplexer:disconnected', this.onDisconnectFn);
        return this.connection
            .subscribe(this.getConnectionScope(this.scope), {
                info: info
            })
            .on('@duplexer:subscription_succeeded', this.onSubscribe);
    };
    GroupV2.prototype.disconnect = function() {
        if (this.connection) {
            this.connection.disconnect();
            this.connection = undefined;
        }
    };
    GroupV2.prototype.onDisconnect = function(onDisconnectFn) {
        this.onDisconnectFn = onDisconnectFn;
    };
    GroupV2.prototype.createState = function(payload) {
        return __awaiter(this, void 0, void 0, function() {
            var presence;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        presence = {
                            payload: payload,
                            scope: this.scope,
                            sessionId: this.sessionId,
                            status: PresenceStatus.ACTIVE,
                        };
                        return [4 /*yield*/ , this.httpClient.request(setPresence({
                            presence: presence
                        }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/ ];
                }
            });
        });
    };
    GroupV2.prototype.updateState = function(state) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.connection) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , this.httpClient.request(updatePresence(state))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        return [2 /*return*/ ];
                }
            });
        });
    };
    GroupV2.prototype.preparePayload = function(payload) {
        if (payload === void 0) {
            payload = {};
        }
        var fullPayload = __assign({
            lastActiveDate: new Date()
        }, payload);
        var mask = Object.keys(fullPayload).map(function(key) {
            return "payload." + key;
        });
        return {
            payload: fullPayload,
            mask: mask
        };
    };
    GroupV2.prototype.updatePresence = function(payload, predefinedMask) {
        if (predefinedMask === void 0) {
            predefinedMask = [];
        }
        return __awaiter(this, void 0, void 0, function() {
            var _a, fullPayload, payloadMask, mask;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.preparePayload(payload), fullPayload = _a.payload, payloadMask = _a.mask;
                        mask = Array.from(new Set(payloadMask.concat(predefinedMask)));
                        return [4 /*yield*/ , this.updateState({
                            mask: mask,
                            presence: {
                                payload: fullPayload,
                                scope: this.scope,
                                sessionId: this.sessionId,
                                status: PresenceStatus.ACTIVE,
                            },
                        })];
                    case 1:
                        _b.sent();
                        return [2 /*return*/ ];
                }
            });
        });
    };
    GroupV2.prototype.getSessionId = function() {
        return this.sessionId;
    };
    GroupV2.prototype.refreshState = function() {
        return this.updatePresence({});
    };
    GroupV2.prototype.keepAlive = function() {
        return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.connection) {
                            clearTimeout(this.keepAliveTimer);
                            return [2 /*return*/ ];
                        }
                        return [4 /*yield*/ , this.refreshState().catch(function() {})];
                    case 1:
                        _a.sent();
                        if (this.keepAliveTimer) {
                            clearTimeout(this.keepAliveTimer);
                        }
                        this.keepAliveTimer = setTimeout(function() {
                            return _this.keepAlive();
                        }, this.keepAliveInterval);
                        return [2 /*return*/ ];
                }
            });
        });
    };
    GroupV2.prototype.getConnectionScope = function(scope) {
        switch (scope) {
            case ScopeV2.VIEWER:
                return Scope.VIEWER;
            case ScopeV2.EDITOR_X:
                return Scope.EDITOR_X;
            default:
                return '';
        }
    };
    return GroupV2;
}());
export default GroupV2;
//# sourceMappingURL=group-v2.js.map