import {
    __assign,
    __awaiter,
    __extends,
    __generator,
    __spreadArrays
} from "tslib";
import React from 'react';
import {
    Constants,
    CustomTemplateData,
    Message,
    StandardTemplateData,
    DeliveryMethodId,
    chatSdk,
} from '@wix/chat-sdk';
import {
    allAttachmentTypes,
    areFilesTooLarge,
    isFileTooLarge,
    isFileTypeSupported,
    toDialogFileTypes,
} from '../../services/media-utils';
import {
    AppMode,
} from '../..';
import uuidV4 from 'uuid/v4';
import {
    translate
} from 'react-i18next';
import {
    onAddUploadedImageItem
} from '../../experimental/onAddUploadedImageItem';
import {
    FileSelectionMethods
} from '../../types/files';
import {
    attachments,
    getAttachmentType
} from '@wix/inbox-common';
import {
    Experiments
} from '../../constants/experiments';
import {
    getDeliveryMethodsBadges
} from './deliveryMethodHelpers';
import {
    appendDataToMessage
} from './messageHelpers';
var withInputHandlers = function(ComponentToWrap) {
    var withInput = /** @class */ (function(_super) {
        __extends(WithInputHandlers, _super);

        function WithInputHandlers(props) {
            var _this = _super.call(this, props) || this;
            _this.handleKeyDown = function(e) {
                if (_this.shouldSendMessage(e)) {
                    _this.handleSendMessage();
                    e.preventDefault();
                }
            };
            _this.handleChange = function(e) {
                var val = e.target.value;
                _this.props.handleChange && _this.props.handleChange(val);
                _this.setState({
                    message: val,
                });
            };
            _this.onSubjectChange = function(e) {
                var val = e.target.value;
                _this.setState({
                    subject: val,
                });
            };
            _this.getSubjectInfo = function(replaceEmpty) {
                if (replaceEmpty === void 0) {
                    replaceEmpty = false;
                }
                var _a, _b, _c;
                var strategy = (_b = (_a = _this.props).subjectStrategy) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.messages, _this.props.deliveryMethods || []);
                if (!(strategy === null || strategy === void 0 ? void 0 : strategy.enable)) {
                    return {};
                }
                var subject = (_c = _this.state.subject) !== null && _c !== void 0 ? _c : strategy === null || strategy === void 0 ? void 0 : strategy.default;
                if (replaceEmpty && _this.state.subject === '') {
                    subject = (strategy === null || strategy === void 0 ? void 0 : strategy.emptySubject) || '';
                }
                return {
                    subject: subject,
                    enable: strategy === null || strategy === void 0 ? void 0 : strategy.enable,
                };
            };
            _this.handleSendMessage = function() {
                var _a, _b;
                if (_this.state.message) {
                    var _c = _this.props,
                        chatroomId = _c.chatroomId,
                        userId = _c.userId,
                        deliveryMethods = _c.deliveryMethods;
                    var trimmedMessage = _this.state.message.trim();
                    var badges = deliveryMethods && _this.getDeliveryMethodsBadges(deliveryMethods);
                    var message = Message.fromText({
                        summary: trimmedMessage,
                        text: trimmedMessage,
                        chatroomId: chatroomId,
                        userId: userId,
                        deliveryMethods: deliveryMethods,
                        badges: badges,
                        title: (_b = (_a = _this.getSubjectInfo(true)) === null || _a === void 0 ? void 0 : _a.subject) === null || _b === void 0 ? void 0 : _b.trim(),
                    });
                    if (!_this.allAttachmentsReady()) {
                        return;
                    }
                    message = _this.appendAttachmentPartsToMessage(message);
                    _this.clearAttachments();
                    _this.props.onSendMessage(message);
                    _this.closeKeyboard();
                    _this.setState({
                        message: '',
                        error: null,
                    });
                }
            };
            _this.shouldSendMessage = function(e) {
                var _a = _this.props.sendOnEnter,
                    sendOnEnter = _a === void 0 ? true : _a;
                var isComposing = _this.state.isComposing;
                var pressedEnterKey = e.key === 'Enter';
                var pressedShiftKey = e.shiftKey;
                var pressedCtrlKey = e.ctrlKey;
                var pressedCommandKey = e.metaKey;
                var messageHasContent = _this.state.message.trim();
                var allowSendUsingEnter = sendOnEnter && !pressedShiftKey;
                var allowSendUsingCtrlEnter = !sendOnEnter && pressedCtrlKey;
                var allowSendUsingCommandEnter = !sendOnEnter && pressedCommandKey;
                var isAllowedToSendMessage = allowSendUsingEnter ||
                    allowSendUsingCtrlEnter ||
                    allowSendUsingCommandEnter;
                return (!isComposing &&
                    pressedEnterKey &&
                    messageHasContent &&
                    isAllowedToSendMessage);
            };
            _this.isSelectedDeliveryMethod = function(method) {
                var _a;
                return ((_a = _this.props.deliveryMethods) === null || _a === void 0 ? void 0 : _a[0]) === method;
            };
            _this.allowSMSImages = function() {
                return _this.isSelectedDeliveryMethod(DeliveryMethodId.SMS) &&
                    chatSdk.isExperimentOn(Experiments.AllowSMSImages);
            };
            _this.allowedAttachmentTypes = function() {
                return _this.isSelectedDeliveryMethod(DeliveryMethodId.SMS) ?
                    _this.allowSMSImages() ?
                    [attachments.attachmentTypes.IMAGE] :
                    [] :
                    _this.isSelectedDeliveryMethod(DeliveryMethodId.Instagram) ?
                    [attachments.attachmentTypes.IMAGE] :
                    allAttachmentTypes;
            };
            // for dialog, i.e image/*,.xlsx,.xls,.doc,.docx,.ppt,.pptx,.pdf
            _this.allowedFiles = function() {
                var allowedDialog = toDialogFileTypes(_this.allowedAttachmentTypes());
                return allowedDialog;
            };
            _this.handleFileSelect = function(file, selectionMethod) {
                if (selectionMethod === void 0) {
                    selectionMethod = FileSelectionMethods.Input;
                }
                if (isFileTypeSupported(file, _this.allowedAttachmentTypes())) {
                    if (isFileTooLarge(file)) {
                        _this.setState({
                            error: 'error.file.too.large'
                        });
                        _this.closeKeyboard();
                    } else if (areFilesTooLarge(__spreadArrays(_this.attachmentFiles(), [file]))) {
                        _this.setState({
                            error: 'error.file.too.large.all'
                        });
                        _this.closeKeyboard();
                    } else {
                        _this.sendFileMessage(file, selectionMethod).catch(function() {});
                        _this.setState({
                            error: null
                        });
                    }
                } else {
                    _this.setState({
                        error: 'error.unsupported.file.format'
                    });
                    _this.closeKeyboard();
                }
            };
            _this.getDeliveryMethodsBadges = function(deliveryMethods) {
                return getDeliveryMethodsBadges(_this.props.t, deliveryMethods);
            };
            _this.attachmentsEnabled = function() {
                return _this.props.appMode !== AppMode.Widget &&
                    chatSdk.isExperimentOn(Experiments.InboxAttachments);
            };
            _this.addAttachmentIfEnabled = function(message) {
                var _a, _b, _c, _d;
                if (_this.attachmentsEnabled()) {
                    _this.setState({
                        attachments: __spreadArrays(_this.state.attachments, [message]),
                    });
                    (_b = (_a = _this.props.eventHooks) === null || _a === void 0 ? void 0 : _a.onAttachmentAction) === null || _b === void 0 ? void 0 : _b.call(_a, 'added', getAttachmentType((_d = (_c = message.transit) === null || _c === void 0 ? void 0 : _c.file) === null || _d === void 0 ? void 0 : _d.type));
                }
            };
            _this.cleanAttachments = function() {
                var _a, _b, _c;
                if ((_a = _this.state.attachments) === null || _a === void 0 ? void 0 : _a.length) {
                    var currentAttachments = _this.state.attachments;
                    var cleanedAttachments = currentAttachments.filter(function(attachment) {
                        var _a;
                        if (isFileTypeSupported((_a = attachment === null || attachment === void 0 ? void 0 : attachment.transit) === null || _a === void 0 ? void 0 : _a.file, _this.allowedAttachmentTypes())) {
                            return attachment;
                        }
                    });
                    var attachmentsRemoved = _this.state.attachments.length - cleanedAttachments.length;
                    if (attachmentsRemoved > 0) {
                        _this.setState({
                            attachments: __spreadArrays(cleanedAttachments)
                        });
                        (_c = (_b = _this.props.eventHooks) === null || _b === void 0 ? void 0 : _b.onAttachmentAction) === null || _c === void 0 ? void 0 : _c.call(_b, "cleaned", 'unknown', attachmentsRemoved);
                    }
                }
            };
            _this.attachmentFiles = function() {
                return _this.state.attachments.map(function(attachment) {
                    return attachment.transit.file;
                });
            };
            _this.allAttachmentsReady = function() {
                var _a, _b;
                if (!((_a = _this.state.attachments) === null || _a === void 0 ? void 0 : _a.length)) {
                    return true;
                }
                var ready = ((_b = _this.state.attachments) === null || _b === void 0 ? void 0 : _b.reduce(function(acc, attachment) {
                    if (attachment.transit.isPending) {
                        acc.ready = false;
                    }
                    return acc;
                }, {
                    ready: true
                })).ready;
                return ready;
            };
            _this.appendAttachmentPartsToMessage = function(message) {
                if (_this.attachmentsEnabled() && _this.state.attachments) {
                    var newMessage = _this.state.attachments.reduce(function(acc, attachment) {
                        acc.newMessage = appendDataToMessage(acc.newMessage, attachment.data);
                        return acc;
                    }, {
                        newMessage: message
                    }).newMessage;
                    return newMessage;
                }
                return message;
            };
            _this.clearAttachments = function() {
                _this.setState({
                    attachments: []
                });
            };
            _this.updateAttachmentIfEnabled = function(message) {
                if (_this.attachmentsEnabled()) {
                    var new_attachments = _this.state.attachments.map(function(attachment) {
                        if (attachment.id === message.id) {
                            return message;
                        }
                        return attachment;
                    });
                    _this.setState({
                        attachments: __spreadArrays(new_attachments),
                    });
                }
            };
            _this.handleFileErrorDismiss = function() {
                _this.setState({
                    error: null
                });
            };
            _this.closeKeyboard = function() {
                _this.setState({
                    isKeyboardOpen: false
                });
            };
            _this.handleKeyboardButtonClick = function(keyboardName, keyboardNameForBI) {
                _this.setState(function(prevState) {
                    return {
                        isKeyboardOpen: prevState.activeKeyboardName === keyboardName ?
                            !prevState.isKeyboardOpen :
                            true,
                        activeKeyboardName: keyboardName,
                        error: null,
                    };
                }, function() {
                    if (keyboardNameForBI && _this.state.isKeyboardOpen) {
                        _this.props.eventHooks &&
                            _this.props.eventHooks.onInputKeyboardSwitch &&
                            _this.props.eventHooks.onInputKeyboardSwitch(keyboardNameForBI);
                    }
                });
            };
            _this.onAddItemToTextArea = function(item, _a) {
                var _b = _a === void 0 ? {} : _a,
                    _c = _b.closeKeyboard,
                    closeKeyboard = _c === void 0 ? true : _c,
                    _d = _b.addNewLine,
                    addNewLine = _d === void 0 ? true : _d;
                var _e, _f;
                var separator = _this.state.message && addNewLine ? '\n' : '';
                var newMessage = "" + _this.state.message + separator + item;
                _this.props.handleChange && _this.props.handleChange(newMessage);
                _this.setState({
                    message: newMessage
                });
                if (closeKeyboard) {
                    _this.closeKeyboard();
                }
                (_f = (_e = _this.props.eventHooks) === null || _e === void 0 ? void 0 : _e.onAddItemToTextArea) === null || _f === void 0 ? void 0 : _f.call(_e, _this.state.activeKeyboardName);
            };
            _this.onAttachCustomTemplateItem = function(_a, _b) {
                var appName = _a.appName,
                    appData = _a.appData,
                    summary = _a.summary;
                var _c = (_b === void 0 ? {} : _b).closeKeyboard,
                    closeKeyboard = _c === void 0 ? true : _c;
                var _d = _this.props,
                    userId = _d.userId,
                    chatroomId = _d.chatroomId,
                    onSendMessage = _d.onSendMessage,
                    deliveryMethods = _d.deliveryMethods;
                var badges = deliveryMethods && _this.getDeliveryMethodsBadges(deliveryMethods);
                onSendMessage(Message.fromTemplate({
                    templateData: new CustomTemplateData({
                        appName: appName,
                        appData: appData,
                    }),
                    userId: userId,
                    chatroomId: chatroomId,
                    messageType: Constants.MessageTypes.Templates.Custom,
                    summary: summary,
                    deliveryMethods: deliveryMethods,
                    badges: badges,
                }));
                if (closeKeyboard) {
                    _this.closeKeyboard();
                }
            };
            _this.onAttachStandardTemplateItem = function(_a, _b) {
                var title = _a.title,
                    _c = _a.descriptions,
                    descriptions = _c === void 0 ? [] : _c,
                    _d = _a.buttons,
                    buttons = _d === void 0 ? [] : _d,
                    imageUrl = _a.imageUrl,
                    orientation = _a.orientation,
                    summary = _a.summary;
                var _e = (_b === void 0 ? {} : _b).closeKeyboard,
                    closeKeyboard = _e === void 0 ? true : _e;
                var _f = _this.props,
                    userId = _f.userId,
                    chatroomId = _f.chatroomId,
                    onSendMessage = _f.onSendMessage,
                    deliveryMethods = _f.deliveryMethods;
                var badges = deliveryMethods && _this.getDeliveryMethodsBadges(deliveryMethods);
                var templateData = new StandardTemplateData({
                    title: title,
                    lines: descriptions,
                    buttons: buttons.map(function(_a) {
                        var text = _a.text,
                            ctaLink = _a.ctaLink;
                        return ({
                            text: text,
                            cta: ctaLink,
                        });
                    }),
                    orientation: orientation,
                    image: imageUrl,
                });
                onSendMessage(Message.fromTemplate({
                    templateData: templateData,
                    userId: userId,
                    chatroomId: chatroomId,
                    messageType: Constants.MessageTypes.Templates.Standard,
                    summary: summary,
                    deliveryMethods: deliveryMethods,
                    badges: badges,
                }));
                if (closeKeyboard) {
                    _this.closeKeyboard();
                }
            };
            _this.onAttachUploadedImageItem = function(item, _a) {
                var _b = (_a === void 0 ? {} : _a).closeKeyboard,
                    closeKeyboard = _b === void 0 ? false : _b;
                var deliveryMethods = _this.props.deliveryMethods;
                var badges = deliveryMethods && _this.getDeliveryMethodsBadges(deliveryMethods);
                onAddUploadedImageItem(item, _this.props.onSendMessage, _this.props.chatroomId, _this.props.t('message.sent.photo'), _this.props.userId, undefined, badges);
                if (closeKeyboard) {
                    _this.closeKeyboard();
                }
            };
            _this.handleComposition = function(state) {
                _this.setState({
                    isComposing: state === 'start'
                });
            };
            _this.onRemoveAttachment = function(attachment) {
                var _a, _b, _c, _d;
                var new_attachments = _this.state.attachments.filter(function(a) {
                    return a.id !== attachment.id;
                });
                _this.setState({
                    attachments: __spreadArrays(new_attachments)
                });
                (_b = (_a = _this.props.eventHooks) === null || _a === void 0 ? void 0 : _a.onAttachmentAction) === null || _b === void 0 ? void 0 : _b.call(_a, 'removed', getAttachmentType((_d = (_c = attachment === null || attachment === void 0 ? void 0 : attachment.transit) === null || _c === void 0 ? void 0 : _c.file) === null || _d === void 0 ? void 0 : _d.type));
            };
            _this.state = {
                message: _this.props.message || '',
                error: null,
                activeKeyboardName: null,
                isKeyboardOpen: false,
                isComposing: false,
                subject: undefined,
                attachments: [],
            };
            return _this;
        }
        WithInputHandlers.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
            var draftLoaded = nextProps.message && !this.props.message && !this.state.message;
            if (draftLoaded) {
                this.setState({
                    message: nextProps.message
                });
            }
        };
        WithInputHandlers.prototype.componentDidUpdate = function(prevProps, prevState) {
            // widget special use case of folding emoji panel when header is being unfolded
            if (prevState.isKeyboardOpen &&
                prevProps.isHeaderFolded &&
                !this.props.isHeaderFolded) {
                this.closeKeyboard();
            }
            // switched channels, for example: from Email to Chat
            if (prevProps.deliveryMethods !== this.props.deliveryMethods) {
                this.cleanAttachments();
            }
        };
        WithInputHandlers.prototype.sendFileMessage = function(file, selectionMethod) {
            return __awaiter(this, void 0, void 0, function() {
                var _a, userId, chatroomId, onClearUnreadDisplay, onUploadFile, onAddMessage, onSendMessage, deliveryMethods, t, id, baseMessage, badges, message, uploaded;
                return __generator(this, function(_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.props.onUploadFile) {
                                return [2 /*return*/ ];
                            }
                            if (file.type.startsWith('image')) {
                                return [2 /*return*/ , this.sendImageMessage(file, selectionMethod)];
                            }
                            _a = this.props, userId = _a.userId, chatroomId = _a.chatroomId, onClearUnreadDisplay = _a.onClearUnreadDisplay, onUploadFile = _a.onUploadFile, onAddMessage = _a.onAddMessage, onSendMessage = _a.onSendMessage, deliveryMethods = _a.deliveryMethods, t = _a.t;
                            id = uuidV4();
                            baseMessage = {
                                id: id,
                                userId: userId,
                                chatroomId: chatroomId,
                            };
                            badges = deliveryMethods && this.getDeliveryMethodsBadges(deliveryMethods);
                            message = Message.fromFile(__assign(__assign({}, baseMessage), {
                                transit: {
                                    status: 'uploading',
                                    isPending: true,
                                    file: file,
                                },
                                summary: t('message.sent.file'),
                                fileName: file.name,
                                fileSize: file.size,
                                type: file.type,
                                deliveryMethods: deliveryMethods,
                                badges: badges
                            }));
                            // pending
                            this.addAttachmentIfEnabled(message);
                            onClearUnreadDisplay();
                            if (!this.attachmentsEnabled()) {
                                onAddMessage({
                                    dto: message.dto,
                                    transit: message.transit
                                });
                            }
                            return [4 /*yield*/ , onUploadFile(file, selectionMethod)];
                        case 1:
                            uploaded = _b.sent();
                            message = Message.fromFile(__assign(__assign({}, baseMessage), {
                                transit: {
                                    status: 'uploaded',
                                    file: file,
                                },
                                summary: t('message.sent.file'),
                                uri: uploaded.url,
                                mediaFileId: uploaded.mediaFileId,
                                mediaProvider: uploaded.mediaProvider,
                                fileName: uploaded.name,
                                fileSize: uploaded.fileSize,
                                type: uploaded.contentType,
                                deliveryMethods: deliveryMethods,
                                badges: badges
                            }));
                            // update uploaded
                            this.updateAttachmentIfEnabled(message);
                            if (!this.attachmentsEnabled()) {
                                onAddMessage({
                                    dto: message.dto,
                                    transit: message.transit
                                });
                                onSendMessage(message);
                            }
                            return [2 /*return*/ ];
                    }
                });
            });
        };
        WithInputHandlers.prototype.sendImageMessage = function(file, source) {
            return __awaiter(this, void 0, void 0, function() {
                var _a, userId, chatroomId, onClearUnreadDisplay, onUploadFile, onAddMessage, onSendMessage, deliveryMethods, t, id, baseMessage, badges, message, uploaded;
                return __generator(this, function(_b) {
                    switch (_b.label) {
                        case 0:
                            _a = this.props, userId = _a.userId, chatroomId = _a.chatroomId, onClearUnreadDisplay = _a.onClearUnreadDisplay, onUploadFile = _a.onUploadFile, onAddMessage = _a.onAddMessage, onSendMessage = _a.onSendMessage, deliveryMethods = _a.deliveryMethods, t = _a.t;
                            id = uuidV4();
                            baseMessage = {
                                id: id,
                                userId: userId,
                                chatroomId: chatroomId,
                            };
                            badges = deliveryMethods && this.getDeliveryMethodsBadges(deliveryMethods);
                            message = Message.fromImage(__assign(__assign({}, baseMessage), {
                                transit: {
                                    status: 'uploading',
                                    isPending: true,
                                    file: file,
                                },
                                summary: t('message.sent.photo'),
                                deliveryMethods: deliveryMethods,
                                badges: badges
                            }));
                            onClearUnreadDisplay();
                            if (!this.attachmentsEnabled()) {
                                onAddMessage({
                                    dto: message.dto,
                                    transit: message.transit
                                });
                            }
                            // pending
                            this.addAttachmentIfEnabled(message);
                            return [4 /*yield*/ , onUploadFile(file, source)];
                        case 1:
                            uploaded = _b.sent();
                            message = Message.fromImage(__assign(__assign({}, baseMessage), {
                                transit: {
                                    status: 'uploaded',
                                    file: file,
                                },
                                summary: t('message.sent.photo'),
                                uri: uploaded.url,
                                mediaFileId: uploaded.mediaFileId,
                                mediaProvider: uploaded.mediaProvider,
                                fileName: uploaded.name,
                                fileSize: uploaded.fileSize,
                                width: uploaded.width,
                                height: uploaded.height,
                                deliveryMethods: deliveryMethods,
                                badges: badges
                            }));
                            this.updateAttachmentIfEnabled(message);
                            if (!this.attachmentsEnabled()) {
                                onAddMessage({
                                    dto: message.dto,
                                    transit: message.transit
                                });
                                onSendMessage(message);
                            }
                            return [2 /*return*/ ];
                    }
                });
            });
        };
        WithInputHandlers.prototype.render = function() {
            var inputHandlerProps = {
                handleKeyDown: this.handleKeyDown,
                handleComposition: this.handleComposition,
                handleChange: this.handleChange,
                handleCloseKeyboard: this.closeKeyboard,
                handleFileErrorDismiss: this.handleFileErrorDismiss,
                allowedFiles: this.allowedFiles,
                message: this.state.message,
                error: this.state.error,
                activeKeyboardName: this.state.activeKeyboardName,
                isKeyboardOpen: this.state.isKeyboardOpen,
                onAddItemToTextArea: this.onAddItemToTextArea,
                onAttachCustomTemplateItem: this.onAttachCustomTemplateItem,
                onAttachStandardTemplateItem: this.onAttachStandardTemplateItem,
                onAttachUploadedImageItem: this.onAttachUploadedImageItem,
                handleKeyboardButtonClick: this.handleKeyboardButtonClick,
                inputKeyboards: this.props.inputKeyboards || [],
                inputButtons: this.props.inputButtons || [],
                onSendMessage: this.handleSendMessage,
                onFileSelect: this.handleFileSelect,
                onSubjectChange: this.onSubjectChange,
                getSubjectInfo: this.getSubjectInfo,
                attachments: this.state.attachments,
                onRemoveAttachment: this.onRemoveAttachment,
                allAttachmentsReady: this.allAttachmentsReady,
            };
            // `as P` can be removed once the following issue closes
            // https://github.com/Microsoft/TypeScript/issues/28884
            var injectedProps = __assign(__assign({}, this.props), inputHandlerProps);
            return React.createElement(ComponentToWrap, __assign({}, injectedProps));
        };
        return WithInputHandlers;
    }(React.Component));
    return translate()(withInput);
};
export default withInputHandlers;
//# sourceMappingURL=withInputHandlers.js.map