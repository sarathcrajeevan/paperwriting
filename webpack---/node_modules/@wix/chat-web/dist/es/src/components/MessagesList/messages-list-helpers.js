import {
    __assign,
    __spreadArrays
} from "tslib";
import _get from 'lodash/get';
import _flatten from 'lodash/flatten';
import {
    Constants,
    MessageGroupingService,
    DeliveryMethodId,
    chatSdk,
} from '@wix/chat-sdk';
import {
    AUTO_MESSAGES
} from '../../constants/messages';
import {
    AppMode
} from '../../constants/app-mode';
var _a = Constants.MessageDirections,
    Incoming = _a.Incoming,
    Outgoing = _a.Outgoing,
    System = _a.System;
var MessageTypes = Constants.MessageTypes;
var Templates = MessageTypes.Templates;
var messageGroupingService = new MessageGroupingService();
var MessageUtils = /** @class */ (function() {
    function MessageUtils(_a) {
        var messages = _a.messages,
            userId = _a.userId,
            lastReadMessageSequence = _a.lastReadMessageSequence,
            unreadCount = _a.unreadCount,
            messageDirectionOverride = _a.messageDirectionOverride,
            includeTitle = _a.includeTitle,
            appMode = _a.appMode,
            sendersData = _a.sendersData;
        this.messages = this.addGroups(messages, lastReadMessageSequence, unreadCount);
        this.includeTitle = includeTitle;
        this.userId = userId;
        this.lastReadMessageSequence = lastReadMessageSequence;
        this.unreadCount = unreadCount;
        this.messageDirectionOverride = messageDirectionOverride;
        this.appMode = appMode;
        this.sendersData = sendersData;
    }
    MessageUtils.prototype.addGroups = function(messages, lastReadMessageSequence, unreadCount) {
        var relevantLastReadMessageSequence = lastReadMessageSequence && unreadCount && unreadCount > 0 ?
            lastReadMessageSequence :
            undefined;
        messageGroupingService.setLastReadSequence(relevantLastReadMessageSequence);
        return messageGroupingService.addGroups(messages);
    };
    MessageUtils.prototype.getListWithProps = function() {
        var allMessages = this.addUnreadToList(this.messages);
        var enrichedWithProps = this.enrichWithProps(allMessages);
        var enrichedWithTimestamps = this.addTimestamps(enrichedWithProps);
        return enrichedWithTimestamps;
    };
    MessageUtils.prototype.addTimestamps = function(list) {
        return _flatten(list.map(function(message) {
            return message.shouldShowTimestamp ?
                [{
                    timestamp: message.formattedTimestamp
                }, message] :
                message;
        }));
    };
    MessageUtils.prototype.enrichWithProps = function(list) {
        var _this = this;
        return _flatten(list.map(function(message) {
            var _a;
            if (message.unreadCount) {
                return message;
            }
            var name = _get(message, 'senderDisplayData.name');
            var senderUserId = _get(message, 'sender.userId');
            var sender = (_a = _this.sendersData) === null || _a === void 0 ? void 0 : _a.filter(function(senderData) {
                return senderData.id === senderUserId;
            }).pop();
            var title = _this.includeTitle ? (sender === null || sender === void 0 ? void 0 : sender.userName) || name : undefined;
            var badges = message.badges || [];
            var isAutoMessage = badges.some(function(badge) {
                return badge.type === AUTO_MESSAGES.BADGE_ID ||
                    badge.text === AUTO_MESSAGES.BADGE_ID;
            });
            var isCustomType = message.type === Templates.Custom;
            var isMinimalTemplateType = message.type === Templates.Minimal;
            var isSystem = message.type === Templates.System;
            var wrapWithBubble = !isMinimalTemplateType && !isCustomType && !isSystem;
            var sharedProps = {
                rawMessage: message,
                position: _this.messageDirectionOverride ?
                    _this.messageDirectionOverride(message) :
                    _this.getPosition(message),
                wrapWithBubble: wrapWithBubble,
                isCustomType: isCustomType,
                formattedTimestamp: message.createdAtFormatted,
                title: title,
                senderUserId: senderUserId,
                transit: message.transit,
                isAutoMessage: isAutoMessage,
            };
            if (message.type === Templates.Form) {
                var msg = _this.messageOnlyWithSharedProps(message, sharedProps);
                var attachments = _this.messagePartsWithSharedProps(message, sharedProps, {
                    shouldShowTimestamp: false
                });
                return __spreadArrays([msg], attachments);
            }
            if (_this.appMode === AppMode.FullApp && MessageUtils.isEmail(message)) {
                return _this.messageOnlyWithSharedProps(message, sharedProps, {
                    groupPosition: undefined,
                });
            }
            if (message.type === MessageTypes.Message) {
                return _this.messagePartsWithSharedProps(message, sharedProps);
            }
            return _this.messageOnlyWithSharedProps(message, sharedProps);
        }));
    };
    MessageUtils.prototype.messagePartsWithSharedProps = function(message, sharedProps, overrides) {
        var messageGrouping = messageGroupingService.getPartsGrouping(message);
        return message.messageParts.map(function(messagePart, index) {
            return __assign(__assign(__assign({}, sharedProps), {
                messagePart: messagePart,
                groupPosition: messageGrouping[index].groupPosition,
                type: messagePart.mimeType,
                shouldShowTimestamp: messageGrouping[index].showSentTime === 'always'
            }), overrides);
        });
    };
    MessageUtils.prototype.messageOnlyWithSharedProps = function(message, sharedProps, overrides) {
        if (overrides === void 0) {
            overrides = {};
        }
        return __assign(__assign(__assign({}, sharedProps), {
            message: message,
            groupPosition: message.groupPosition,
            type: message.type,
            shouldShowTimestamp: message.showSentTime === 'always'
        }), overrides);
    };
    MessageUtils.prototype.addUnreadToList = function(list) {
        var _this = this;
        return _flatten(list.map(function(message) {
            return _this.lastReadMessageSequence &&
                Number(_this.unreadCount) > 0 &&
                message.sequence === _this.lastReadMessageSequence ?
                [message, {
                    unreadCount: _this.unreadCount
                }] :
                message;
        }));
    };
    MessageUtils.prototype.isSentByUser = function(message) {
        var messageSenderUserId = _get(message, 'sender.userId');
        return messageSenderUserId === this.userId;
    };
    MessageUtils.prototype.isSystemMessage = function(message) {
        return message.messageType === Constants.MessageTypes.Templates.System;
    };
    MessageUtils.prototype.getPosition = function(message) {
        var messageSenderType = _get(message, 'sender.type');
        if (messageSenderType === 'system') {
            return System;
        }
        if (this.isSystemMessage(message)) {
            return System;
        }
        if (this.isSentByUser(message)) {
            return Outgoing;
        }
        return Incoming;
    };
    MessageUtils.isEmail = function(message) {
        var _a;
        return (chatSdk.isExperimentOn('specs.chat.InboxAttachments') &&
            (message === null || message === void 0 ? void 0 : message.messageType) === MessageTypes.Message &&
            (((_a = message === null || message === void 0 ? void 0 : message.deliveryMethods) === null || _a === void 0 ? void 0 : _a.includes(DeliveryMethodId.Email)) ||
                message.originMethod === DeliveryMethodId.Email));
    };
    return MessageUtils;
}());
export {
    MessageUtils
};
//# sourceMappingURL=messages-list-helpers.js.map