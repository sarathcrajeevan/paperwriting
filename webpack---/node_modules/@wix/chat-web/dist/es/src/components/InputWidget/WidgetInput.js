import {
    __assign,
    __extends,
    __spreadArrays
} from "tslib";
import React from 'react';
import styles from './WidgetInput.scss';
import {
    translate
} from 'react-i18next';
import Textarea from 'react-textarea-autosize';
import InputButtons from '../InputButtons/InputButtons';
import EmojiPanel from '../EmojiPanel/EmojiPanel';
import {
    EmojiIcon
} from '../EmojiPanel/EmojiIcon';
import Attach from '../../svgIcons/dist/components/attach';
import Send from '../../svgIcons/dist/components/send';
import withTheme from '../../providers/theme/withTheme';
import X from 'wix-ui-icons-common/X';
import _get from 'lodash/get';
import classNames from 'classnames';
import withAllowInput from '../../providers/ChatConfiguration/withAllowInput';
import withInputHandlers from '../../providers/withInputHandlers/withInputHandlers';
import direction from 'direction';
import {
    FileSelectionMethods
} from '../../types/files';
var WidgetInput = /** @class */ (function(_super) {
    __extends(WidgetInput, _super);

    function WidgetInput(props) {
        var _this = _super.call(this, props) || this;
        _this.input = null;
        _this.getKeyboardComponentByName = function(name) {
            var keyboardConf = _this.keyboards.find(function(keyboard) {
                return keyboard.componentName === name;
            });
            if (keyboardConf) {
                return keyboardConf.component;
            }
        };
        _this.isKeyboardOpen = function(name) {
            return _this.props.isKeyboardOpen && _this.props.activeKeyboardName === name;
        };
        _this.focusInput = function() {
            _this.input && _this.input.focus();
        };
        _this.onAddItemToTextArea = function(item, options) {
            _this.props.onAddItemToTextArea(item, options);
            _this.focusInput();
        };
        _this.renderKeyboards = function() {
            var _a = _this.props,
                isKeyboardOpen = _a.isKeyboardOpen,
                activeKeyboardName = _a.activeKeyboardName;
            var KeyboardComponent = _this.getKeyboardComponentByName(activeKeyboardName);
            if (_this.props.error) {
                return null;
            }
            return (React.createElement("div", {
                "data-hook": "input-keyboards",
                className: styles.inputKeyboards + " " + (!isKeyboardOpen && styles.minimized)
            }, isKeyboardOpen && KeyboardComponent && (React.createElement("div", {
                    "data-hook": activeKeyboardName,
                    className: styles.keyboardWrapper
                },
                React.createElement(KeyboardComponent, {
                    onAddItemToTextArea: _this.onAddItemToTextArea,
                    onAttachCustomTemplateItem: function() {},
                    onAttachStandardTemplateItem: function() {},
                    onAttachUploadedImageItem: function() {},
                    closeKeyboard: _this.props.handleCloseKeyboard,
                    isOpen: isKeyboardOpen,
                    recipientParticipantId: _this.props.otherParticipantId
                })))));
        };
        _this.handleFileSelect = function(e) {
            var target = e.target;
            var file = target.files && target.files[0];
            file && _this.props.onFileSelect(file, FileSelectionMethods.Input);
            target.value = '';
        };
        _this.handlePaste = function(e) {
            var clipboardData = e.clipboardData;
            var file = clipboardData.files && clipboardData.files[0];
            if (file) {
                e.preventDefault();
                _this.props.onFileSelect(file, FileSelectionMethods.Clipboard);
            }
        };
        _this.state = {
            isFocus: false,
        };
        return _this;
    }
    WidgetInput.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
        var _this = this;
        var becameVisible = nextProps.isVisible && !this.props.isVisible;
        if (becameVisible) {
            setTimeout(function() {
                _this.focusInput();
            });
        }
    };
    WidgetInput.prototype.componentDidUpdate = function(prevProps, prevState) {
        if (!prevProps.isKeyboardOpen && this.props.isKeyboardOpen) {
            this.props.foldHeader && this.props.foldHeader({
                animation: true
            });
        }
        var _a = this.props,
            _b = _a.droppedFiles,
            droppedFiles = _b === void 0 ? [] : _b,
            onDroppedFilesUpload = _a.onDroppedFilesUpload;
        if (droppedFiles.length > 0) {
            this.props.onFileSelect(droppedFiles[0], FileSelectionMethods.DragNDrop);
            onDroppedFilesUpload();
        }
    };
    Object.defineProperty(WidgetInput.prototype, "keyboards", {
        get: function() {
            var _this = this;
            var color = _get(this.props.theme, 'input.color');
            var opacityOnFocus = _get(this.props.theme, 'input.opacityOnFocus');
            var focusStyle = {
                opacity: this.state.isFocus ? 1 : 0.7
            };
            var opacityProp = opacityOnFocus ? focusStyle : null;
            var colorProp = color ? {
                color: color
            } : null;
            var emojiKeyboardConfig = {
                componentName: 'emoji-keyboard',
                component: EmojiPanel,
                icon: EmojiIcon,
                buttonClassName: styles.emojiButton,
                iconTooltip: this.props.t('input.buttons.tooltip.emoji'),
            };
            var allKeyboards = __spreadArrays(this.props.inputKeyboards, [
                emojiKeyboardConfig,
            ]);
            return allKeyboards.map(function(keyboard) {
                return (__assign(__assign({}, keyboard), {
                    button: {
                        className: keyboard.buttonClassName,
                        dataHook: keyboard.componentName,
                        onClick: function() {
                            _this.props.handleKeyboardButtonClick(keyboard.componentName);
                            _this.focusInput();
                        },
                        children: (React.createElement(keyboard.icon, {
                            iconSize: "20px",
                            style: __assign(__assign({}, colorProp), opacityProp),
                            open: _this.isKeyboardOpen('emoji-keyboard')
                        })),
                        ariaLabel: keyboard.iconTooltip,
                    }
                }));
            });
        },
        enumerable: true,
        configurable: true
    });
    WidgetInput.prototype.onBlur = function() {
        this.setState({
            isFocus: !!this.props.message && this.props.message.length > 0,
        });
    };
    WidgetInput.prototype.onFocus = function() {
        var foldHeader = this.props.foldHeader;
        this.props.isMobile && foldHeader && foldHeader({
            animation: true
        });
        this.setState({
            isFocus: true
        });
    };
    WidgetInput.prototype.componentDidMount = function() {
        var _a = this.props,
            isMobile = _a.isMobile,
            isVisible = _a.isVisible,
            allowInput = _a.allowInput;
        allowInput && !isMobile && isVisible && this.focusInput();
    };
    WidgetInput.prototype.renderFileError = function(colorProp) {
        var buttonColor = _get(this.props.theme, 'room.button.background');
        var borderRadius = _get(this.props.theme, 'room.button.borderRadius');
        var buttonStyle = buttonColor ? {
            backgroundColor: buttonColor
        } : {};
        buttonStyle =
            borderRadius !== undefined ?
            __assign({
                borderRadius: borderRadius
            }, buttonStyle) : buttonStyle;
        return (React.createElement("div", {
                style: __assign({}, colorProp),
                className: styles.error
            },
            React.createElement("button", {
                    className: styles.xButton,
                    onClick: this.props.handleFileErrorDismiss
                },
                React.createElement(X, null)),
            React.createElement("span", {
                className: styles.errorTitle
            }, this.props.t('error.oops')),
            React.createElement("span", {
                className: styles.errorText
            }, this.props.t(this.props.error)),
            React.createElement("span", {
                    style: buttonStyle,
                    className: styles.chooseAnotherFile
                },
                React.createElement("input", {
                    disabled: this.props.disabled,
                    type: "file",
                    accept: this.props.allowedFiles(),
                    onChange: this.handleFileSelect,
                    className: styles.fileUploadInput,
                    "data-hook": "another-file-upload-input"
                }),
                this.props.t('error.choose.another.file'))));
    };
    WidgetInput.prototype.render = function() {
        var _a;
        var _this = this;
        if (!this.props.allowInput) {
            return null;
        }
        var color = _get(this.props.theme, 'input.color');
        var sendIconColor = _get(this.props.theme, 'input.sendIconColor');
        var dividerColor = _get(this.props.theme, 'input.dividerColor', color);
        var dividerWidth = _get(this.props.theme, 'input.dividerWidth');
        var opacityOnFocus = _get(this.props.theme, 'input.opacityOnFocus');
        var focusStyle = {
            opacity: this.state.isFocus ? 1 : 0.7
        };
        var opacityProp = opacityOnFocus ? focusStyle : null;
        var colorProp = color ? {
            color: color
        } : null;
        var sendIconColorProp = sendIconColor ?
            {
                color: sendIconColor
            } :
            colorProp;
        var dividerProp = dividerWidth ?
            {
                borderTop: dividerWidth + "px solid " + dividerColor
            } :
            null;
        var _b = this.props,
            getInputSendViaIndication = _b.getInputSendViaIndication,
            offlineChannels = _b.offlineChannels,
            isMobile = _b.isMobile,
            disabled = _b.disabled,
            placeholder = _b.placeholder,
            t = _b.t,
            _c = _b.eventHooks,
            eventHooks = _c === void 0 ? {} : _c,
            message = _b.message,
            error = _b.error,
            onSendMessage = _b.onSendMessage,
            allowedFiles = _b.allowedFiles;
        var fileButton = {
            className: styles.fileButton,
            dataHook: 'attachment-button',
            onClick: eventHooks.onAttachmentClick,
            children: (React.createElement("span", {
                    "data-hook": "attachment-button-style",
                    style: __assign(__assign({
                        transform: 'rotate(-315deg)',
                        display: 'inline-block'
                    }, colorProp), opacityProp)
                },
                React.createElement(Attach, {
                    width: "9px",
                    height: "23px"
                }),
                React.createElement("input", {
                    tabIndex: 0,
                    disabled: disabled,
                    type: "file",
                    accept: allowedFiles(),
                    onChange: this.handleFileSelect,
                    className: styles.fileUploadInput,
                    "data-hook": "file-upload-input",
                    "aria-label": t('input.attachment.button.aria-label')
                }))),
        };
        var sendButton = {
            dataHook: 'send-button',
            disabled: !message.trim(),
            onClick: onSendMessage,
            ariaLabel: t('input.send'),
        };
        var widgetButtons = [!message ?
            fileButton :
            __assign(__assign({}, sendButton), {
                children: (React.createElement("span", {
                        "data-hook": "send-button-style",
                        style: __assign(__assign({}, sendIconColorProp), opacityProp)
                    },
                    React.createElement(Send, {
                        size: "16px"
                    }))),
                className: styles.sendButtonIcon + " " + styles.sendButton
            }),
        ];
        var inputSendViaIndicationComponent = getInputSendViaIndication && getInputSendViaIndication(offlineChannels);
        var textareaClasses = (_a = {},
            _a[styles.withLabel] = !!inputSendViaIndicationComponent,
            _a[styles.isEmpty] = !message,
            _a);
        var maxRows = this.props.maxRows || 5;
        var fontFamily = _get(this.props.theme, 'room.fontFamily');
        var maybeDefaultFont = fontFamily ? '' : styles.defaultFont;
        var dir = direction(message);
        return (React.createElement("div", {
                "data-hook": "input-wrapper",
                className: styles.inputWrapper + " " + maybeDefaultFont,
                style: {
                    fontFamily: fontFamily
                }
            },
            this.renderKeyboards(),
            error && this.renderFileError(colorProp),
            React.createElement("div", {
                    "data-hook": "input-box-wrapper",
                    className: classNames(styles.textareaWrapper, textareaClasses),
                    onBlur: function() {
                        return _this.onBlur();
                    },
                    onFocus: function() {
                        return _this.onFocus();
                    },
                    style: __assign({}, dividerProp)
                },
                inputSendViaIndicationComponent && (React.createElement("div", {
                    className: styles.inputLabel,
                    "data-hook": "input-label"
                }, inputSendViaIndicationComponent)),
                React.createElement("div", {
                        className: styles.container
                    }, !isMobile && (React.createElement(InputButtons, {
                        buttons: this.keyboards.map(function(keyboard) {
                            return keyboard.button;
                        })
                    })),
                    React.createElement(Textarea, {
                        "aria-label": "Type your message. Hit enter to submit.",
                        "data-hook": "input",
                        disabled: disabled,
                        inputRef: function(input) {
                            return (_this.input = input);
                        },
                        maxRows: maxRows,
                        className: styles.input,
                        onKeyDown: this.props.handleKeyDown,
                        onChange: this.props.handleChange,
                        placeholder: placeholder || t('input.placeholder'),
                        value: message,
                        role: "textbox",
                        style: __assign(__assign({}, colorProp), {
                            boxShadow: 'none',
                            direction: dir !== 'neutral' ? dir : undefined
                        }),
                        onPaste: this.handlePaste
                    }),
                    React.createElement(InputButtons, {
                        buttons: widgetButtons,
                        disabled: disabled
                    })))));
    };
    WidgetInput.defaultProps = {
        sendOnEnter: true,
        allowInput: true,
    };
    return WidgetInput;
}(React.Component));
export default withInputHandlers(withAllowInput(withTheme(translate()(WidgetInput))));
//# sourceMappingURL=WidgetInput.js.map