import {
    __assign,
    __extends,
    __spreadArrays
} from "tslib";
import React from 'react';
import Textarea from 'react-textarea-autosize';
import {
    translate
} from 'react-i18next';
import s from './InputFullApp.scss';
import X from 'wix-ui-icons-common/X';
import {
    Text,
    Button,
    IconButton
} from 'wix-style-react';
import withInputHandlers from '../../providers/withInputHandlers/withInputHandlers';
import PaperClipIcon from '../../svgIcons/dist/components/attachment';
import Smiley from '../../svgIcons/dist/components/smiley';
import EmojiPanel from '../EmojiPanel/EmojiPanel';
import withAllowInput from '../../providers/ChatConfiguration/withAllowInput';
import classNames from 'classnames';
import {
    DeliveryMethodId,
    chatSdk,
} from '@wix/chat-sdk';
import InputButtons from '../InputButtons/InputButtons';
import SendIcon from '../../svgIcons/dist/components/sendIconOutline';
import {
    FileSelectionMethods,
    SupportedAttachmentFormat,
} from '../..';
import {
    withClickOutsideHandler,
} from '../../providers/ClickBetweenProvider/withClickBetweenHandlers';
import direction from 'direction';
import _compact from 'lodash/compact';
import {
    deliveryMethodMaxMessageLength
} from '../../constants/delivery-method-constants';
import {
    SubjectLine
} from './SubjectLine';
import {
    AttachmentArea
} from '../attachments/AttachmentArea/AttachmentArea';
import {
    Experiments
} from '../../constants/experiments';
var InputFullApp = /** @class */ (function(_super) {
    __extends(InputFullApp, _super);

    function InputFullApp(props) {
        var _this = _super.call(this, props) || this;
        _this.textAreaRef = null;
        _this.getKeyboardComponentByName = function(name) {
            var keyboardConf = _this.keyboards.find(function(keyboard) {
                return keyboard.componentName === name;
            });
            if (keyboardConf) {
                return keyboardConf.component;
            }
        };
        _this.getIsKeyboardHasCustomLayout = function(name) {
            var keyboardConf = _this.keyboards.find(function(keyboard) {
                return keyboard.componentName === name;
            });
            return !!(keyboardConf && keyboardConf.hasCustomLayout);
        };
        _this.getIsKeyboardHasSearch = function(name) {
            var keyboardConf = _this.keyboards.find(function(keyboard) {
                return keyboard.componentName === name;
            });
            return !!(keyboardConf && keyboardConf.hasSearch);
        };
        _this.getIsKeyboardShouldUnmountOnWhenClosed = function(name) {
            var keyboardConf = _this.keyboards.find(function(keyboard) {
                return keyboard.componentName === name;
            });
            return !!(keyboardConf && keyboardConf.unmountOnClose);
        };
        _this.isKeyboardOpen = function(componentName) {
            return (_this.props.isKeyboardOpen &&
                _this.props.activeKeyboardName === componentName);
        };
        _this.shouldChangeInputlayout = function() {
            if (!_this.textAreaDuplicateRef || _this.props.compactView) {
                return false;
            }
            return _this.isTextAreaOverlapsInputButtons() ?
                !_this.state.columnLayout :
                _this.state.columnLayout;
        };
        _this.isTextAreaOverlapsInputButtons = function() {
            // We use textAreaDuplicate because our third party (TextArea) has fixed size.
            if (!_this.textAreaDuplicateRef ||
                !_this.inputButtonsRef ||
                !_this.textAreaWrapperRef) {
                return false;
            }
            var shouldNotOverlapButtonsThreshold = 10;
            return (Number(_this.textAreaDuplicateRef.clientWidth) +
                Number(_this.inputButtonsRef.clientWidth) +
                shouldNotOverlapButtonsThreshold >
                _this.textAreaWrapperRef.clientWidth);
        };
        _this.renderSendButtonIcon = function() {
            return (React.createElement(IconButton, {
                    as: "button",
                    dataHook: 'send-icon',
                    size: "small"
                },
                React.createElement(SendIcon, null)));
        };
        _this.getSendText = function() {
            var deliveryMethods = _this.props.deliveryMethods;
            if (chatSdk.isExperimentOn('specs.chat.emailSubjectLineMobileSide') && (deliveryMethods === null || deliveryMethods === void 0 ? void 0 : deliveryMethods.includes(DeliveryMethodId.Email))) {
                return _this.props.t('input.send.email');
            }
            return _this.props.t('input.send');
        };
        _this.sendButton = function() {
            var compactView = _this.props.compactView;
            return {
                dataHook: 'send-button',
                hide: _this.props.disabled ||
                    !_this.props.message ||
                    !_this.props.message.trim() ||
                    !_this.props.allAttachmentsReady(),
                onClick: _this.handleSend,
                children: compactView ? _this.renderSendButtonIcon() : _this.getSendText(),
                className: compactView ? s.sendButtonIcon : s.sendButton,
                ariaLabel: _this.props.t('input.send'),
            };
        };
        _this.fileButton = function() {
            var _a;
            return {
                className: classNames(s.inputButton),
                tooltipContent: _this.props.t('input.buttons.tooltip.attach'),
                tooltipProps: {
                    placement: 'top-end',
                    maxWidth: '250px'
                },
                disabled: false,
                dataHook: 'attachment-button',
                onClick: (_a = _this.props.eventHooks) === null || _a === void 0 ? void 0 : _a.onAttachmentClick,
                children: React.createElement(PaperClipIcon, {
                    size: "24px",
                    onClick: _this.clickOnInputFile
                }),
                ariaLabel: _this.props.t('input.buttons.tooltip.attach'),
            };
        };
        _this.focusInput = function() {
            _this.textAreaRef && _this.textAreaRef.focus();
        };
        _this.handleSend = function() {
            _this.props.onSendMessage();
            _this.focusInput();
        };
        _this.handleFileErrorDismiss = function() {
            _this.props.handleFileErrorDismiss();
            _this.focusInput();
        };
        _this.renderInputSendViaIndication = function() {
            var LineSeparatorWrapper = _this.withLineSeperatorWrapper;
            var inputSendViaIndication = _this.props.getInputSendViaIndication &&
                _this.props.getInputSendViaIndication(_this.props.offlineChannels, _this.props.messages);
            return (inputSendViaIndication && (React.createElement(LineSeparatorWrapper, {
                    show: true,
                    dataHook: 'input-send-indication'
                },
                React.createElement("div", {
                    "data-hook": "input-send-indication",
                    className: s.inputSendViaIndication
                }, inputSendViaIndication))));
        };
        _this.renderSubjectLine = function() {
            var LineSeparatorWrapper = _this.withLineSeperatorWrapper;
            var subjectInfo = _this.props.getSubjectInfo();
            if (!subjectInfo.enable) {
                return;
            }
            return (React.createElement(LineSeparatorWrapper, {
                    show: true,
                    dataHook: 'input-subject-line-separator'
                },
                React.createElement(SubjectLine, {
                    onSubjectChange: _this.props.onSubjectChange,
                    subject: subjectInfo.subject
                })));
        };
        _this.withLineSeperatorWrapper = function(_a) {
            var show = _a.show,
                dataHook = _a.dataHook,
                children = _a.children;
            return (React.createElement("div", {
                    "data-hook": "line-separator-wrapper-" + dataHook,
                    className: s.lineSeparatorWrapper
                },
                children,
                show && (React.createElement("div", {
                    "data-hook": "line-separator-" + dataHook,
                    className: s.lineSeparator
                }))));
        };
        _this.clickOnInputFile = function() {
            var _a;
            _this.focusInput();
            (_a = _this.inputFileRef) === null || _a === void 0 ? void 0 : _a.click();
        };
        _this.renderFileError = function() {
            var _a = _this.props,
                t = _a.t,
                error = _a.error;
            var LineSeparatorWrapper = _this.withLineSeperatorWrapper;
            return (React.createElement(LineSeparatorWrapper, {
                    show: true,
                    dataHook: 'file-upload-error'
                },
                React.createElement("div", {
                        className: s.sendFileError,
                        "data-hook": "file-upload-error"
                    },
                    React.createElement("button", {
                            "data-hook": "close-error-button",
                            className: s.exitButton,
                            onClick: _this.handleFileErrorDismiss
                        },
                        React.createElement(X, null)),
                    React.createElement("span", {
                        className: s.fileErrorTitle
                    }, t('error.oops')),
                    React.createElement("div", {
                            className: s.fileErrorText
                        },
                        React.createElement(Text, {
                            weight: "normal",
                            size: "small"
                        }, t(error))),
                    React.createElement("div", {
                            className: s.fileErrorChooseAnotherFile
                        },
                        React.createElement(Button, {
                            dataHook: "another-file-upload",
                            onClick: _this.clickOnInputFile
                        }, t('error.choose.another.file'))))));
        };
        _this.renderKeyboards = function() {
            var _a, _b;
            var LineSeparatorWrapper = _this.withLineSeperatorWrapper;
            var _c = _this.props,
                isKeyboardOpen = _c.isKeyboardOpen,
                activeKeyboardName = _c.activeKeyboardName,
                deliveryMethods = _c.deliveryMethods;
            var KeyboardComponent = _this.getKeyboardComponentByName(activeKeyboardName) || null;
            var isKeyboardHasCustomLayout = _this.getIsKeyboardHasCustomLayout(activeKeyboardName);
            var shouldUnmountKeyboard = _this.getIsKeyboardShouldUnmountOnWhenClosed(activeKeyboardName) &&
                !isKeyboardOpen;
            var hasSearch = _this.getIsKeyboardHasSearch(activeKeyboardName) && isKeyboardOpen;
            var outerWrapperClasses = classNames((_a = {},
                _a[s.inputKeyboards] = true,
                _a[s.internalKeyboardStyle] = !isKeyboardHasCustomLayout,
                _a[s.minimized] = !isKeyboardOpen,
                _a[s.withSearch] = hasSearch,
                _a));
            var innerWrapperClasses = classNames((_b = {},
                _b[s.keyboardWrapper] = true,
                _b[s.internalKeyboardStyle] = !isKeyboardHasCustomLayout,
                _b));
            var KeyboardOuterComponent = (React.createElement("div", {
                "data-hook": "input-keyboards",
                className: outerWrapperClasses
            }, KeyboardComponent && !shouldUnmountKeyboard && (React.createElement("div", {
                    "data-hook": activeKeyboardName,
                    className: innerWrapperClasses
                },
                React.createElement(KeyboardComponent, {
                    onAddItemToTextArea: _this.onAddItemToTextArea,
                    onAttachCustomTemplateItem: _this.onAttachCustomTemplateItem,
                    onAttachStandardTemplateItem: _this.onAttachStandardTemplateItem,
                    onAttachUploadedImageItem: _this.onAttachUploadedImageItem,
                    closeKeyboard: _this.props.handleCloseKeyboard,
                    isOpen: isKeyboardOpen,
                    recipientParticipantId: _this.props.otherParticipantId,
                    supportedAttachmentFormat: chatSdk.isExperimentOn(Experiments.InboxAttachments) && (deliveryMethods === null || deliveryMethods === void 0 ? void 0 : deliveryMethods.includes(DeliveryMethodId.Email)) ?
                        SupportedAttachmentFormat.Text :
                        SupportedAttachmentFormat.All
                })))));
            if (_this.props.error) {
                return null;
            }
            return isKeyboardHasCustomLayout ? (KeyboardOuterComponent) : (React.createElement(LineSeparatorWrapper, {
                show: !!isKeyboardOpen,
                dataHook: 'input-keyboards'
            }, KeyboardOuterComponent));
        };
        _this.onAttachCustomTemplateItem = function(item, options) {
            _this.props.onAttachCustomTemplateItem(item, options);
            _this.focusInput();
        };
        _this.onAttachStandardTemplateItem = function(item, options) {
            _this.props.onAttachStandardTemplateItem(item, options);
            _this.focusInput();
        };
        _this.onAttachUploadedImageItem = function(item, options) {
            _this.props.onAttachUploadedImageItem(item, options);
            _this.focusInput();
        };
        _this.onAddItemToTextArea = function(item, options) {
            _this.props.onAddItemToTextArea(item, options);
            _this.focusInput();
        };
        _this.handleFileSelect = function(e) {
            var target = e.target;
            var file = target.files && target.files[0];
            file && _this.props.onFileSelect(file, FileSelectionMethods.Input);
            target.value = '';
        };
        _this.renderFileInput = function() {
            return (React.createElement("input", {
                ref: function(ref) {
                    return (_this.inputFileRef = ref);
                },
                disabled: _this.props.disabled,
                type: "file",
                accept: _this.props.allowedFiles(),
                onChange: _this.handleFileSelect,
                className: s.fileUploadInput,
                "data-hook": 'file-upload-input'
            }));
        };
        _this.renderDuplicateTextArea = function() {
            return (React.createElement("span", {
                className: s.duplicateTextArea,
                ref: function(ref) {
                    return (_this.textAreaDuplicateRef = ref);
                }
            }, _this.props.message));
        };
        _this.getDeliveryMethodMaxLength = function() {
            var deliveryMethods = _this.props.deliveryMethods;
            var selectedDeliveryMethod = deliveryMethods === null || deliveryMethods === void 0 ? void 0 : deliveryMethods[0];
            if (selectedDeliveryMethod) {
                return deliveryMethodMaxMessageLength[selectedDeliveryMethod];
            }
        };
        _this.getMessage = function() {
            var message = _this.props.message;
            return _this.getDeliveryMethodMaxLength() ?
                message.slice(0, _this.getDeliveryMethodMaxLength()) :
                message;
        };
        _this.state = {
            columnLayout: true,
        };
        return _this;
    }
    InputFullApp.prototype.componentDidMount = function() {
        this.textAreaRef && this.textAreaRef.focus();
        var setClickBetweenHandler = this.props.setClickBetweenHandler;
        setClickBetweenHandler(this.props.handleCloseKeyboard);
    };
    Object.defineProperty(InputFullApp.prototype, "keyboards", {
        get: function() {
            var _this = this;
            var emojiKeyboardConfig = {
                componentName: 'emoji-keyboard',
                icon: Smiley,
                iconTooltip: this.props.t('input.buttons.tooltip.emoji'),
                component: EmojiPanel,
                keyboardNameForBI: undefined,
                hasCustomLayout: false,
                unmountOnClose: false,
            };
            return __spreadArrays(this.props.inputKeyboards, [emojiKeyboardConfig]).map(function(keyboard) {
                var KeyboardIcon = keyboard.icon;
                return __assign(__assign({}, keyboard), {
                    button: {
                        className: s.inputButton + " " + (_this.isKeyboardOpen(keyboard.componentName) && s.activeButton),
                        children: (React.createElement(KeyboardIcon, {
                            "data-hook": keyboard.componentName + "-icon",
                            size: "24px"
                        })),
                        tooltipContent: keyboard.iconTooltip,
                        dataHook: keyboard.componentName,
                        onClick: function() {
                            _this.props.handleKeyboardButtonClick(keyboard.componentName, keyboard.keyboardNameForBI);
                            _this.focusInput();
                        },
                        ariaLabel: keyboard.iconTooltip,
                        hasCustomLayout: keyboard.hasCustomLayout,
                        hasSearch: keyboard.hasSearch,
                    }
                });
            });
        },
        enumerable: true,
        configurable: true
    });
    InputFullApp.prototype.getExtraButtons = function() {
        var _this = this;
        var _a;
        return (((_a = this.props.inputButtons) === null || _a === void 0 ? void 0 : _a.filter(function(x) {
            return !!x;
        })) || []).map(function(button) {
            var buttonChildren = (button === null || button === void 0 ? void 0 : button.getChildren) ? button === null || button === void 0 ? void 0 : button.getChildren({
                onAttachStandardTemplateItem: _this.onAttachStandardTemplateItem,
                onAddItemToTextArea: _this.onAddItemToTextArea,
                closeKeyboard: function() {
                    return _this.props.handleCloseKeyboard();
                },
            }) : button === null || button === void 0 ? void 0 : button.children;
            return __assign(__assign({
                className: s.inputButton
            }, button), {
                children: buttonChildren
            });
        });
    };
    InputFullApp.prototype.render = function() {
        var _a;
        var _this = this;
        var _b = this.props,
            disabled = _b.disabled,
            placeholder = _b.placeholder,
            _c = _b.allowInput,
            allowInput = _c === void 0 ? true : _c,
            error = _b.error,
            preventClickBetween = _b.preventClickBetween;
        var buttons = _compact(__spreadArrays(this.keyboards.map(function(keyboard) {
            return keyboard.button;
        }), this.getExtraButtons(), [
            this.props.allowedFiles() && this.fileButton(),
            this.sendButton(),
        ]));
        var inputClasses = classNames((_a = {},
            _a[s.root] = true,
            _a[s.columnLayout] = this.state.columnLayout,
            _a));
        if (!allowInput) {
            return null;
        }
        var dir = direction(this.props.message);
        return (React.createElement("div", {
                "data-hook": "root",
                className: inputClasses,
                ref: function(ref) {
                    return (_this.rootRef = ref);
                },
                onClick: preventClickBetween
            },
            this.renderFileInput(),
            this.renderInputSendViaIndication(),
            this.renderSubjectLine(),
            error && this.renderFileError(),
            this.renderKeyboards(),
            React.createElement("div", {
                    className: s.textAreaWrapper,
                    ref: function(ref) {
                        return (_this.textAreaWrapperRef = ref);
                    }
                },
                React.createElement(Textarea, {
                    "aria-label": "Type your message. Hit enter to submit.",
                    "data-hook": "input",
                    disabled: disabled,
                    inputRef: function(ref) {
                        return (_this.textAreaRef = ref);
                    },
                    maxRows: 10,
                    className: s.textArea,
                    onKeyDown: this.props.handleKeyDown,
                    onChange: this.props.handleChange,
                    placeholder: placeholder || this.props.t('input.placeholder'),
                    value: this.getMessage(),
                    role: "textbox",
                    style: {
                        direction: dir !== 'neutral' ? dir : undefined,
                    },
                    maxLength: this.getDeliveryMethodMaxLength()
                }),
                React.createElement(AttachmentArea, {
                    attachments: this.props.attachments,
                    onRemoveAttachment: this.props.onRemoveAttachment
                }),
                React.createElement("div", {
                        className: s.inputButtonsWrapper,
                        ref: function(ref) {
                            return (_this.inputButtonsRef = ref);
                        }
                    },
                    React.createElement(InputButtons, {
                        buttons: buttons,
                        disabled: disabled
                    })))));
    };
    return InputFullApp;
}(React.Component));
export default withInputHandlers(withAllowInput(translate()(withClickOutsideHandler(InputFullApp))));
//# sourceMappingURL=InputFullApp.js.map