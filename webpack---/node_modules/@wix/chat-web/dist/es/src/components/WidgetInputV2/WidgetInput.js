import {
    __assign,
    __extends,
    __spreadArrays
} from "tslib";
import React, {
    createRef
} from 'react';
import styles from './WidgetInput.scss';
import {
    translate
} from 'react-i18next';
import Textarea from 'react-textarea-autosize';
import EmojiPanel from '../EmojiPanel/EmojiPanel';
import Attach from '../../svgIcons/dist/components/attach';
import Send from '../../svgIcons/dist/components/send';
import withTheme from '../../providers/theme/withTheme';
import X from 'wix-ui-icons-common/X';
import _get from 'lodash/get';
import classNames from 'classnames';
import withAllowInput from '../../providers/ChatConfiguration/withAllowInput';
import withInputHandlers from '../../providers/withInputHandlers/withInputHandlers';
import direction from 'direction';
import {
    FileSelectionMethods
} from '../../types/files';
import {
    EmojiIcon
} from '../EmojiPanel/EmojiIcon';
var WidgetInput = /** @class */ (function(_super) {
    __extends(WidgetInput, _super);

    function WidgetInput(props) {
        var _this = _super.call(this, props) || this;
        _this.input = null;
        _this.getKeyboardComponentByName = function(name) {
            var keyboardConf = _this.getKeyboards().find(function(keyboard) {
                return keyboard.componentName === name;
            });
            if (keyboardConf) {
                return keyboardConf.component;
            }
        };
        _this.isKeyboardOpen = function(name) {
            return _this.props.isKeyboardOpen && _this.props.activeKeyboardName === name;
        };
        _this.getKeyboards = function() {
            var emojiKeyboardConfig = {
                componentName: 'emoji-keyboard',
                component: EmojiPanel,
                icon: EmojiIcon,
                buttonClassName: styles.emojiButton,
                iconTooltip: _this.props.t('input.buttons.tooltip.emoji'),
            };
            var allKeyboards = __spreadArrays(_this.props.inputKeyboards, [
                emojiKeyboardConfig,
            ]);
            return allKeyboards.map(function(keyboard) {
                return (__assign(__assign({}, keyboard), {
                    button: {
                        className: keyboard.buttonClassName,
                        dataHook: keyboard.componentName,
                        onClick: function() {
                            _this.props.handleKeyboardButtonClick(keyboard.componentName);
                            _this.focusInput();
                        },
                        ariaLabel: keyboard.iconTooltip,
                        children: (React.createElement(keyboard.icon, {
                            iconSize: "16px",
                            open: _this.isKeyboardOpen('emoji-keyboard')
                        })),
                    }
                }));
            });
        };
        _this.focusInput = function() {
            _this.input && _this.input.focus();
        };
        _this.onAddItemToTextArea = function(item, options) {
            _this.props.onAddItemToTextArea(item, options);
            _this.focusInput();
        };
        _this.renderKeyboardArea = function(dividerProp) {
            var _a;
            var _b = _this.props,
                isKeyboardOpen = _b.isKeyboardOpen,
                activeKeyboardName = _b.activeKeyboardName;
            if (_this.props.error) {
                return null;
            }
            var KeyboardComponent = _this.getKeyboardComponentByName(activeKeyboardName);
            return (React.createElement("div", {
                "data-hook": "input-keyboards",
                className: classNames(styles.keyboards, (_a = {},
                    _a[styles.minimized] = !isKeyboardOpen,
                    _a)),
                style: isKeyboardOpen ? __assign({}, dividerProp) : undefined
            }, isKeyboardOpen && KeyboardComponent && (React.createElement("div", {
                    "data-hook": activeKeyboardName,
                    className: styles.keyboardWrapper
                },
                React.createElement(KeyboardComponent, {
                    onAddItemToTextArea: _this.onAddItemToTextArea,
                    onAttachCustomTemplateItem: function() {},
                    onAttachStandardTemplateItem: function() {},
                    onAttachUploadedImageItem: function() {},
                    closeKeyboard: _this.props.handleCloseKeyboard,
                    isOpen: isKeyboardOpen,
                    recipientParticipantId: _this.props.otherParticipantId
                })))));
        };
        _this.handleFileSelect = function(e) {
            var target = e.target;
            var file = target.files && target.files[0];
            file && _this.props.onFileSelect(file, FileSelectionMethods.Input);
            target.value = '';
        };
        _this.handlePaste = function(e) {
            var clipboardData = e.clipboardData;
            var file = clipboardData.files && clipboardData.files[0];
            if (file) {
                e.preventDefault();
                _this.props.onFileSelect(file, FileSelectionMethods.Clipboard);
            }
        };
        _this.shouldShowSendButton = function() {
            return !!_this.props.message || _this.props.showSendButton;
        };
        _this.getButtons = function() {
            var _a = _this.props,
                disabled = _a.disabled,
                t = _a.t,
                _b = _a.eventHooks,
                eventHooks = _b === void 0 ? {} : _b,
                allowedFiles = _a.allowedFiles,
                isMobile = _a.isMobile,
                showSendButton = _a.showSendButton;
            var fileButton = {
                className: styles.fileButton,
                dataHook: 'attachment-button',
                onClick: function() {
                    var _a, _b;
                    (_a = _this.attachmentInput.current) === null || _a === void 0 ? void 0 : _a.click();
                    (_b = eventHooks.onAttachmentClick) === null || _b === void 0 ? void 0 : _b.call(eventHooks);
                },
                children: (React.createElement("span", {
                        "data-hook": "attachment-button-style"
                    },
                    React.createElement(Attach, {
                        width: "7px",
                        height: "17px"
                    }),
                    React.createElement("input", {
                        onClick: function(e) {
                            return e.stopPropagation();
                        },
                        tabIndex: -1,
                        ref: _this.attachmentInput,
                        disabled: disabled,
                        type: "file",
                        accept: allowedFiles(),
                        onChange: _this.handleFileSelect,
                        className: styles.fileUploadInput,
                        "data-hook": "file-upload-input"
                    }))),
                ariaLabel: t('input.attachment.button.aria-label'),
            };
            var keyboardButtons = isMobile ?
                [] :
                _this.getKeyboards().map(function(keyboard) {
                    return keyboard.button;
                });
            var withMessage = [];
            var withoutMessage = [fileButton];
            var dynamicButtons = _this.shouldShowSendButton() ?
                withMessage :
                withoutMessage;
            return __spreadArrays(keyboardButtons, dynamicButtons);
        };
        _this.getSendButton = function() {
            var _a = _this.props,
                theme = _a.theme,
                t = _a.t,
                message = _a.message,
                onSendMessage = _a.onSendMessage;
            if (!_this.shouldShowSendButton()) {
                return null;
            }
            var color = _get(theme, 'input.color');
            var sendIconColor = _get(theme, 'input.sendIconColor');
            var colorProp = color ? {
                color: color
            } : null;
            var sendIconColorProp = sendIconColor ?
                {
                    color: sendIconColor
                } :
                colorProp;
            var sendButton = {
                className: styles.sendButton,
                dataHook: 'send-button',
                disabled: !message.trim(),
                onClick: onSendMessage,
                ariaLabel: t('input.send'),
                children: (React.createElement("span", {
                        "data-hook": "send-button-style",
                        style: __assign({}, sendIconColorProp)
                    },
                    React.createElement(Send, {
                        size: "16px"
                    }))),
            };
            return _this.renderButton(sendButton);
        };
        _this.getButtonsComponent = function() {
            var buttons = _this.getButtons();
            return React.createElement(React.Fragment, null, buttons.map(function(button, i) {
                return _this.renderButton(button, i);
            }));
        };
        _this.attachmentInput = createRef();
        return _this;
    }
    WidgetInput.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
        var _this = this;
        var becameVisible = nextProps.isVisible && !this.props.isVisible;
        if (becameVisible) {
            setTimeout(function() {
                _this.focusInput();
            });
        }
    };
    WidgetInput.prototype.componentDidUpdate = function(prevProps) {
        var _a = this.props,
            _b = _a.droppedFiles,
            droppedFiles = _b === void 0 ? [] : _b,
            onDroppedFilesUpload = _a.onDroppedFilesUpload;
        if (droppedFiles.length > 0) {
            this.props.onFileSelect(droppedFiles[0], FileSelectionMethods.DragNDrop);
            onDroppedFilesUpload();
        }
    };
    WidgetInput.prototype.componentDidMount = function() {
        var _a = this.props,
            isMobile = _a.isMobile,
            isVisible = _a.isVisible,
            allowInput = _a.allowInput;
        allowInput && !isMobile && isVisible && this.focusInput();
    };
    WidgetInput.prototype.renderFileError = function(colorProp) {
        var _a = this.props,
            theme = _a.theme,
            error = _a.error,
            handleFileErrorDismiss = _a.handleFileErrorDismiss,
            t = _a.t,
            disabled = _a.disabled,
            allowedFiles = _a.allowedFiles;
        if (!error) {
            return null;
        }
        var buttonColor = _get(theme, 'room.button.background');
        var borderRadius = _get(theme, 'room.button.borderRadius');
        var buttonStyle = buttonColor ? {
            backgroundColor: buttonColor
        } : {};
        buttonStyle =
            borderRadius !== undefined ?
            __assign({
                borderRadius: borderRadius
            }, buttonStyle) : buttonStyle;
        return (React.createElement("div", {
                style: __assign({}, colorProp),
                className: styles.error
            },
            React.createElement("button", {
                    className: styles.xButton,
                    onClick: handleFileErrorDismiss
                },
                React.createElement(X, null)),
            React.createElement("span", {
                className: styles.errorTitle
            }, t('error.oops')),
            React.createElement("span", {
                className: styles.errorText
            }, t(error)),
            React.createElement("span", {
                    style: buttonStyle,
                    className: styles.chooseAnotherFile
                },
                React.createElement("input", {
                    disabled: disabled,
                    type: "file",
                    accept: allowedFiles(),
                    onChange: this.handleFileSelect,
                    className: styles.fileUploadInput,
                    "data-hook": "another-file-upload-input"
                }),
                t('error.choose.another.file'))));
    };
    WidgetInput.prototype.renderButton = function(button, index) {
        var _a;
        var _b = this.props,
            disabled = _b.disabled,
            theme = _b.theme;
        var isDisabled = disabled || button.disabled;
        var color = _get(theme, 'input.color');
        var sendIconColor = _get(theme, 'input.sendIconColor');
        var hoverColor = sendIconColor || color;
        return (React.createElement("button", {
                key: index,
                onClick: function() {
                    return !isDisabled && button.onClick && button.onClick();
                },
                disabled: isDisabled,
                "data-hook": button.dataHook,
                className: classNames(styles.button, button.className, (_a = {},
                    _a[styles.disabled] = isDisabled,
                    _a)),
                "aria-label": button.ariaLabel
            },
            React.createElement("span", {
                className: styles.buttonWrapper,
                style: {
                    color: hoverColor
                }
            }, button.children)));
    };
    WidgetInput.prototype.render = function() {
        var _a;
        var _this = this;
        var _b = this.props,
            allowInput = _b.allowInput,
            theme = _b.theme,
            disabled = _b.disabled,
            placeholder = _b.placeholder,
            t = _b.t,
            message = _b.message,
            banner = _b.banner;
        if (!allowInput) {
            return banner ? (React.createElement("div", {
                    className: styles.blockedInput
                },
                React.createElement("div", {
                    className: styles.banner
                }, banner))) : null;
        }
        var fontFamily = _get(theme, 'room.fontFamily');
        var color = _get(theme, 'input.color');
        var dividerColor = _get(theme, 'input.dividerColor', color);
        var dividerWidth = _get(theme, 'input.dividerWidth');
        var colorProp = color ? {
            color: color
        } : null;
        var dividerProp = dividerWidth ?
            {
                borderTop: dividerWidth + "px solid " + dividerColor
            } :
            null;
        var maxRows = 5;
        var dir = direction(message);
        return (React.createElement("div", {
                "data-hook": "widget-input",
                className: classNames(styles.widgetInput),
                style: __assign({
                    fontFamily: fontFamily
                }, colorProp)
            },
            this.renderKeyboardArea(dividerProp),
            this.renderFileError(colorProp),
            React.createElement("div", {
                    "data-hook": "textarea-wrapper",
                    className: classNames(styles.textareaWrapper, (_a = {},
                        _a[styles.withBanner] = !!banner,
                        _a)),
                    style: __assign({}, dividerProp)
                },
                React.createElement("div", {
                        className: styles.container
                    },
                    React.createElement(Textarea, {
                        "aria-label": "Type your message. Hit enter to submit.",
                        "data-hook": "input",
                        disabled: disabled,
                        inputRef: function(input) {
                            return (_this.input = input);
                        },
                        maxRows: maxRows,
                        className: styles.textarea,
                        onKeyDown: this.props.handleKeyDown,
                        onCompositionStart: function() {
                            return _this.props.handleComposition('start');
                        },
                        onCompositionEnd: function() {
                            return _this.props.handleComposition('end');
                        },
                        onChange: this.props.handleChange,
                        placeholder: placeholder || t('input.placeholder'),
                        value: message,
                        role: "textbox",
                        style: __assign(__assign({}, colorProp), {
                            boxShadow: 'none',
                            direction: dir !== 'neutral' ? dir : undefined
                        }),
                        onPaste: this.handlePaste
                    }), !banner && this.getButtonsComponent(),
                    this.getSendButton()),
                banner && (React.createElement("div", {
                        className: styles.container
                    },
                    this.getButtonsComponent(),
                    React.createElement("div", {
                        className: styles.banner
                    }, banner))))));
    };
    WidgetInput.defaultProps = {
        sendOnEnter: true,
        allowInput: true,
    };
    return WidgetInput;
}(React.Component));
export default withInputHandlers(withAllowInput(withTheme(translate()(WidgetInput))));
//# sourceMappingURL=WidgetInput.js.map