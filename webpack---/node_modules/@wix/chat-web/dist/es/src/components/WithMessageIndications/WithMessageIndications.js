import {
    __extends
} from "tslib";
import React from 'react';
import s from './WithMessageIndications.scss';
import {
    chatSdk,
    Constants
} from '@wix/chat-sdk';
import _isEmpty from 'lodash/isEmpty';
import _concat from 'lodash/concat';
import _map from 'lodash/map';
import ChevronDown from 'wix-ui-icons-common/ChevronDown';
import {
    translate
} from 'react-i18next';
import classNames from 'classnames';
import withAppMode from '../../providers/appMode/withAppMode';
import {
    AppMode
} from '../..';
import MessageIndicationSummary from '../MessageIndicationSummary/MessageIndicationSummary';
import {
    Popover,
    Text
} from 'wix-style-react';
import {
    IndicationEvent
} from '@wix/chat-sdk/lib/src/constants/constants';
var MessageTypes = Constants.MessageTypes;
var Templates = MessageTypes.Templates;
var WithDrillInIndications = /** @class */ (function(_super) {
    __extends(WithDrillInIndications, _super);

    function WithDrillInIndications(props) {
        var _this = _super.call(this, props) || this;
        _this.updateIndicationDetails = function(drillInIndications) {
            _this.setState({
                drillInIndications: drillInIndications
            });
        };
        _this.showDrillInMessageIndications = function() {
            var rawMessage = _this.props.rawMessage;
            if (rawMessage) {
                _this.unsubscribeObject = chatSdk.subscribeToDrillInMessageIndications({
                    chatroomId: rawMessage.chatroomId,
                    messageId: rawMessage.id,
                    sequence: rawMessage.sequence,
                    callback: _this.updateIndicationDetails,
                });
                _this.setState({
                    showDrillInIndications: true
                });
                _this.props.onClickOnDrillInMessageIndications(rawMessage.id);
            }
        };
        _this.indicationDetailsToTranslatedKey = function(event, method) {
            var indicationEventPartialKey = event === Constants.IndicationEvent.SEEN ?
                'seen' :
                event === Constants.IndicationEvent.SENT ?
                'sent' :
                event === Constants.IndicationEvent.FAILED ?
                'failed' :
                null;
            return indicationEventPartialKey && method ?
                "message.indication." + indicationEventPartialKey + "." + method.toLowerCase() :
                null;
        };
        _this.addSentByChatDefaultIndication = function(indications, rawMessage) {
            return _concat(indications, {
                event: Constants.IndicationEvent.SENT,
                method: 'default',
                formattedTimestamp: rawMessage.createdAtFormatted,
            });
        };
        _this.renderDrillInIndicationItem = function(allIndicationDetails, eventFilter) {
            // method => did fail?
            var failedVia = allIndicationDetails.reduce(function(acc, details) {
                acc[details.method] =
                    acc[details.method] || details.event === IndicationEvent.FAILED ?
                    true :
                    undefined;
                return acc;
            }, {});
            return _map(allIndicationDetails, function(indicationDetails) {
                if (indicationDetails.event !== eventFilter) {
                    return;
                }
                // if FAILED indication, get the text (translation) for SENT
                var indicationTranslatedKey = _this.indicationDetailsToTranslatedKey(indicationDetails.event === IndicationEvent.FAILED ?
                    IndicationEvent.SENT :
                    indicationDetails.event, indicationDetails.method);
                // if we have a failed indication for this method
                // dont show SENT or SEEN indications
                // will only show the FAILED indication
                var isFailed = failedVia[indicationDetails.method];
                if (indicationDetails.event !== IndicationEvent.FAILED && isFailed) {
                    return;
                }
                if (!indicationTranslatedKey) {
                    return;
                }
                return (React.createElement("div", {
                        "data-hook": "drill-in-list-item",
                        className: s.drillInListItem,
                        key: indicationDetails.event + "-" + indicationDetails.method
                    },
                    React.createElement("div", {
                            className: s.indicationDetails
                        },
                        React.createElement(Text, {
                            skin: 'standard',
                            dataHook: "drill-in-indication-item-details",
                            weight: "bold",
                            size: "small",
                            secondary: false,
                            light: false
                        }, _this.props.t(indicationTranslatedKey)),
                        React.createElement(Text, {
                                dataHook: "drill-in-indication-item-timestamp",
                                weight: "bold",
                                size: "small",
                                secondary: true,
                                light: true,
                                skin: isFailed ? 'error' : 'standard'
                            }, isFailed ?
                            _this.props.t('message.indication.failed') :
                            indicationDetails.formattedTimestamp)),
                    eventFilter === Constants.IndicationEvent.SENT ||
                    eventFilter === Constants.IndicationEvent.FAILED ? (React.createElement("div", {
                        className: s.lineSeparator
                    })) : (React.createElement("div", {
                        className: s.sectionLineSeparator
                    }))));
            });
        };
        _this.renderDrillInIndications = function() {
            var drillInIndications = _this.state.drillInIndications;
            var rawMessage = _this.props.rawMessage;
            if (!_this.state.showDrillInIndications) {
                return null;
            }
            var indicationDetailsArrayWithoutDefault = drillInIndications && !_isEmpty(drillInIndications.indications) ?
                drillInIndications.indications[0].details :
                [];
            var sentIndicationDetails = indicationDetailsArrayWithoutDefault.filter(function(i) {
                return i.event === Constants.IndicationEvent.SENT;
            });
            var failedIndicationDetails = indicationDetailsArrayWithoutDefault.filter(function(i) {
                return i.event === Constants.IndicationEvent.FAILED;
            });
            var allIndicationDetails = indicationDetailsArrayWithoutDefault;
            if (sentIndicationDetails.length === 0 &&
                failedIndicationDetails.length === 0) {
                allIndicationDetails = _this.addSentByChatDefaultIndication(indicationDetailsArrayWithoutDefault, rawMessage);
            }
            return (React.createElement("div", {
                    className: s.drillInIndicationsList,
                    "data-hook": "drill-in-indications-list"
                },
                React.createElement("div", {
                    "data-hook": "seen-section",
                    className: s.seenSection
                }, _this.renderDrillInIndicationItem(allIndicationDetails, Constants.IndicationEvent.SEEN)),
                React.createElement("div", {
                    "data-hook": "sent-section",
                    className: s.sentSection
                }, _this.renderDrillInIndicationItem(allIndicationDetails, Constants.IndicationEvent.SENT)),
                React.createElement("div", {
                    "data-hook": "failed-section",
                    className: s.failedSection
                }, _this.renderDrillInIndicationItem(allIndicationDetails, Constants.IndicationEvent.FAILED))));
        };
        _this.hideDrillInMessageIndications = function() {
            if (_this.unsubscribeObject) {
                _this.unsubscribeObject.unsubscribe();
            }
            _this.setState({
                showDrillInIndications: false
            });
        };
        _this.isTransitExists = function() {
            return _this.props.rawMessage && _this.props.rawMessage.transit;
        };
        _this.wasMessageSent = function() {
            return _this.isTransitExists() &&
                _this.props.rawMessage.transit.sendStatus ===
                Constants.MessageSendStatus.SENT;
        };
        _this.isFullApp = function() {
            return _this.props.appMode === AppMode.FullApp;
        };
        _this.drillInIndicationsOverlayClasses = function() {
            var _a;
            return classNames((_a = {},
                _a[s.drillInIndicationsMessageOverlay] = true,
                _a[s.shouldStayVisible] = _this.state.showDrillInIndications,
                _a));
        };
        _this.shouldShowDrillInButton = function() {
            return (_this.wasMessageSent() && _this.props.isOutgoingMessage && _this.isFullApp());
        };
        _this.state = {
            showDrillInIndications: false,
            drillInIndications: {
                indications: props.rawMessage && props.rawMessage.indications,
            },
        };
        return _this;
    }
    WithDrillInIndications.prototype.componentWillUnmount = function() {
        if (this.unsubscribeObject) {
            this.unsubscribeObject.unsubscribe();
        }
    };
    WithDrillInIndications.prototype.render = function() {
        var children = this.props.children;
        var shouldShowDrillInButton = this.shouldShowDrillInButton();
        var style = this.props.fullWidth ?
            {
                width: '100%',
                display: 'flex',
                justifyContent: this.props.isOutgoingMessage ? 'end' : 'start',
            } :
            {};
        return (React.createElement("div", {
                "data-hook": "with-drillIn-message-indications-wrapper",
                className: s.drillInIndicationsWrapper,
                style: style
            },
            shouldShowDrillInButton ? (React.createElement("div", {
                    "data-hook": "indications-drill-in-wrapper",
                    className: this.drillInIndicationsOverlayClasses()
                },
                React.createElement(Popover, {
                        dataHook: "drill-in-popover",
                        showArrow: true,
                        shown: this.state.showDrillInIndications,
                        placement: "left",
                        onClickOutside: this.hideDrillInMessageIndications,
                        className: s.drillInIndicationsButtonWrapper,
                        onClick: this.showDrillInMessageIndications,
                        appendTo: 'window'
                    },
                    React.createElement(Popover.Element, null,
                        React.createElement(ChevronDown, {
                            "data-hook": "drill-in-button",
                            size: "24px",
                            className: s.drillInIndicationsButton
                        })),
                    React.createElement(Popover.Content, null, this.renderDrillInIndications())))) : null,
            children));
    };
    return WithDrillInIndications;
}(React.Component));
var WithDrillInIndicationsComponent = withAppMode(translate()(WithDrillInIndications));
var WithMessageIndications = function(_a) {
    var _b;
    var position = _a.position,
        children = _a.children,
        rawMessage = _a.rawMessage,
        isLastMessage = _a.isLastMessage,
        onSendAgain = _a.onSendAgain,
        onClickOnDrillInMessageIndications = _a.onClickOnDrillInMessageIndications,
        getIndicationData = _a.getIndicationData,
        compactView = _a.compactView,
        fullWidth = _a.fullWidth;
    var isMessageDirectionOutgoing = position === Constants.MessageDirections.Outgoing;
    var rootClasses = classNames((_b = {},
        _b[s.root] = true,
        _b[s.toTheRight] = isMessageDirectionOutgoing,
        _b[s.isChatApp] = rawMessage && rawMessage.type === Templates.Custom,
        _b));
    return (React.createElement("div", {
            className: rootClasses,
            style: {
                flex: fullWidth ? 1 : undefined
            }
        },
        React.createElement(WithDrillInIndicationsComponent, {
            rawMessage: rawMessage,
            isLastMessage: isLastMessage,
            isOutgoingMessage: isMessageDirectionOutgoing,
            onClickOnDrillInMessageIndications: onClickOnDrillInMessageIndications,
            fullWidth: fullWidth
        }, children),
        React.createElement(MessageIndicationSummary, {
            transit: rawMessage && rawMessage.transit,
            indications: rawMessage && rawMessage.indications,
            isLastMessage: isLastMessage,
            isOutgoingMessage: isMessageDirectionOutgoing,
            rawMessage: rawMessage,
            onSendAgain: onSendAgain,
            getIndicationData: getIndicationData,
            compactView: compactView
        })));
};
export default WithMessageIndications;
//# sourceMappingURL=WithMessageIndications.js.map