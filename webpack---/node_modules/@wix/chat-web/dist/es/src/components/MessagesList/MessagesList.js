import {
    __assign,
    __extends
} from "tslib";
import React from 'react';
import classNames from 'classnames';
import {
    chatEventEmitter,
    chatSdk,
    Constants,
} from '@wix/chat-sdk';
import StandardTemplateBubble from '../bubbles/StandardTemplateBubble/StandardTemplateBubble';
import StandardTemplateV2Bubble from '../bubbles/StandardTemplateV2Bubble/StandardTemplateV2Bubble';
import SystemTemplateBubble from '../bubbles/SystemTemplateBubble/SystemTemplateBubble';
import PlainTextBubble from '../bubbles/PlainTextBubble/PlainTextBubble';
import MultipartBubble from '../bubbles/MultipartBubble/MultipartBubble';
import ImageBubble from '../bubbles/ImageBubble/ImageBubble';
import FileBubble from '../bubbles/FileBubble/FileBubble';
import MinimalTemplateBubble from '../bubbles/MinimalTemplateBubble/MinimalTemplateBubble';
import FormTemplateBubble from '../bubbles/FormTemplateBubble/FormTemplateBubble';
import UnreadAnchor from '../UnreadAnchor/UnreadAnchor';
import {
    MessageUtils
} from './messages-list-helpers';
import styles from './MessagesList.scss';
import typingStyles from './typing.scss';
import withTheme from '../../providers/theme/withTheme';
import _get from 'lodash/get';
import _last from 'lodash/last';
import _debounce from 'lodash/debounce';
import _isEmpty from 'lodash/isEmpty';
import _isUndefined from 'lodash/isUndefined';
import scrollIntoView from 'dom-scroll-into-view';
import withAppMode from '../../providers/appMode/withAppMode';
import {
    translate
} from 'react-i18next';
import Waypoint from 'react-waypoint';
import ArrowDown from 'wix-ui-icons-common/ArrowDown';
import ChevronDown from 'wix-ui-icons-common/ChevronDown';
import withDisableAutoMessages from '../../providers/ChatConfiguration/withDisableAutoMessages';
import {
    AppMode,
    TitleConfig,
} from '../..';
import {
    Experiments
} from '../../constants/experiments';
import {
    withChatAppsRegistry,
} from '../../providers/ChatAppsRegistryProvider/withChatAppsRegistry';
import MessageEntry from '../MessageEntry/MessageEntry';
import TypingMessage from '../TypingMessage/TypingMessage';
import {
    isDocumentVisible,
    listenToVisibilityChange,
    removeListenerForVisibilityChange,
} from '../../services/visibility-change/visibility-change';
import {
    Loader,
    Tooltip
} from 'wix-style-react';
import {
    getRgbA
} from '../../services/color-utils';
var MIN_TIMESTAMP_WIDTH = 105; // prevents the timestamp for short messages from breaking to new line
var SCROLL_MARGIN_FROM_BOTTOM = 30;
var isTypeHasSeparatedTitle = function(type) {
    return type !== Constants.MimeTypes.PlainText;
};
export var TimestampTooltipPosition;
(function(TimestampTooltipPosition) {
    TimestampTooltipPosition["NONE"] = "none";
    TimestampTooltipPosition["TOP"] = "top";
    TimestampTooltipPosition["BOTTOM"] = "bottom";
    TimestampTooltipPosition["LEFT"] = "left";
    TimestampTooltipPosition["RIGHT"] = "right";
})(TimestampTooltipPosition || (TimestampTooltipPosition = {}));
var MessagesList = /** @class */ (function(_super) {
    __extends(MessagesList, _super);

    function MessagesList(props) {
        var _this = _super.call(this, props) || this;
        _this.isUnreadMessagesButtonExperimentOn = function() {
            return chatSdk.isExperimentOn(Experiments.UnreadMessagesButtonDesktop);
        };
        _this.onVisibilityChangeHandler = function() {
            if (isDocumentVisible()) {
                _this.setState({
                    anchorPosition: _this.props.lastReadMessageSequence,
                });
            }
        };
        _this.handleRealtimeMessage = function(message) {
            if (message.chatroomId === _this.props.chatroomId) {
                _this.setMessagesReadIfNeeded();
                if (!_this.isScrollAtBottom() && isDocumentVisible()) {
                    _this.setState({
                        anchorPosition: _this.props.lastReadMessageSequence,
                    });
                }
            }
        };
        _this.setMessagesReadIfNeeded = function() {
            if (_this.isScrollAtBottom() &&
                _this.props.setMessagesRead &&
                isDocumentVisible()) {
                _this.setState({
                    showUnreadButton: false
                });
                _this.props.setMessagesRead();
            }
        };
        _this.shouldDisplayUnreadButton = function(prevProps, currProps) {
            if (!_this.isUnreadMessagesButtonExperimentOn()) {
                return false;
            }
            var didReceiveNewMessages = currProps.messages.length > prevProps.messages.length &&
                currProps.unreadCount;
            return (didReceiveNewMessages && !_this.state.isScrollBottomBeforeReceiveMessage);
        };
        _this.didSendMessage = function(prevProps, currProps) {
            return (currProps.messages.length > prevProps.messages.length &&
                !currProps.unreadCount);
        };
        _this.isLastMessage = function(messageWithProps) {
            var showPartIndications = (messageWithProps === null || messageWithProps === void 0 ? void 0 : messageWithProps.messagePart) ? (messageWithProps === null || messageWithProps === void 0 ? void 0 : messageWithProps.groupPosition) === 'end' ||
                (messageWithProps === null || messageWithProps === void 0 ? void 0 : messageWithProps.groupPosition) === 'single' :
                true;
            var lastMessage = _last(_this.props.messages);
            var isLast = !!lastMessage &&
                messageWithProps.rawMessage.id === lastMessage.id &&
                showPartIndications;
            return isLast;
        };
        _this.shouldUseStandardTemplateV2 = function(orientation) {
            return orientation === Constants.MessageOrientation.Portrait && !_this.isFullApp();
        };
        _this.getComponentByType = function(type, orientation) {
            switch (type) {
                case Constants.MimeTypes.PlainText:
                    return PlainTextBubble;
                case Constants.MimeTypes.Image:
                    return ImageBubble;
                case Constants.MimeTypes.File:
                    return FileBubble;
                case Constants.MessageTypes.Templates.Standard:
                    {
                        return _this.shouldUseStandardTemplateV2(orientation) ?
                            StandardTemplateV2Bubble :
                            StandardTemplateBubble;
                    }
                case Constants.MessageTypes.Templates.System:
                    {
                        return SystemTemplateBubble;
                    }
                case Constants.MessageTypes.Templates.Form:
                    return FormTemplateBubble;
                case Constants.MessageTypes.Templates.Minimal:
                    return MinimalTemplateBubble;
                case Constants.MessageTypes.Message:
                    return MultipartBubble;
                default:
                    return null;
            }
        };
        _this.handleOnEnterTopArea = function() {
            var _a = _this.props,
                isVisible = _a.isVisible,
                hasMore = _a.hasMore,
                loadMore = _a.loadMore;
            isVisible && hasMore && loadMore && _this.handleOnEnterFetchMoreArea();
            isVisible && _this.handleOnEnterUnfoldHeader();
        };
        _this.handleOnLeaveTopArea = function() {
            var _a = _this.props,
                isVisible = _a.isVisible,
                hasMore = _a.hasMore,
                loadMore = _a.loadMore;
            isVisible && hasMore && loadMore && _this.handleOnEnterFetchMoreArea();
            isVisible && _this.handleOnLeaveFoldHeader();
        };
        _this.handleOnLeaveFoldHeader = function() {
            var _a = _this.props,
                foldHeader = _a.foldHeader,
                messages = _a.messages,
                hasMore = _a.hasMore;
            if (!hasMore && (messages.length === 0 || !_this.isScrollAtBottom())) {
                foldHeader && foldHeader();
            }
        };
        _this.handleOnEnterFetchMoreArea = function() {
            return _this.setState({
                fetching: true
            }, _this.props.loadMore);
        };
        _this.handleOnEnterUnfoldHeader = function() {
            var _a = _this.props,
                unfoldHeader = _a.unfoldHeader,
                messages = _a.messages,
                hasMore = _a.hasMore;
            if (!hasMore && (messages.length === 0 || !_this.isScrollAtBottom())) {
                unfoldHeader && unfoldHeader({
                    animation: true
                });
            }
        };
        _this.isScrollAtBottom = function() {
            var container = _this.container;
            return (!container ||
                container.scrollHeight <=
                container.scrollTop + container.clientHeight + SCROLL_MARGIN_FROM_BOTTOM);
        };
        _this.onScroll = _debounce(_this.setMessagesReadIfNeeded, 100);
        _this.onWheel = function(ev) {
            var scrollTop = _this.container.scrollTop,
                scrollHeight = _this.container.scrollHeight,
                height = _this.container.clientHeight,
                delta = -ev.deltaY,
                up = delta > 0;
            var prevent = function(e) {
                e.stopPropagation();
                e.preventDefault();
                return false;
            };
            if (!up && -delta > scrollHeight - height - scrollTop) {
                // Scrolling down, but this will take us past the bottom.
                _this.container.scrollTop = scrollHeight;
                return prevent(ev);
            }
            if (up && delta > scrollTop) {
                // Scrolling up, but this will take us past the top.
                _this.container.scrollTop = 0;
                return prevent(ev);
            }
        };
        _this.renderUnreadMessagesButton = function() {
            var _a = _this.props,
                theme = _a.theme,
                unreadCount = _a.unreadCount,
                appMode = _a.appMode;
            var look = _get(theme, 'room.unreadMessagesButton.look');
            var unreadButtonThemeStyle = !look ?
                {
                    background: _get(theme, 'room.unreadMessagesButton.background') ||
                        _get(theme, 'header.background'),
                    color: _get(theme, 'room.unreadMessagesButton.color') ||
                        _get(theme, 'header.textColor'),
                } :
                {};
            var hideArrow = _get(theme, 'room.unreadMessagesButton.hideArrow');
            return (React.createElement("div", {
                className: styles.unreadMessagesButton + " " + styles[appMode] + " " + styles[look],
                "data-hook": "unread-messages-button",
                onClick: function() {
                    return _this.scrollDown(true);
                }
            }, appMode === AppMode.FullApp ? (React.createElement("div", {
                    className: styles.unreadButtonFullApp
                },
                React.createElement("div", {
                    className: styles.unreadButtonCount
                }, unreadCount),
                React.createElement(ChevronDown, null))) : (React.createElement("div", {
                    "data-hook": "unread-messages-button-inner-widget",
                    className: styles.unreadMessagesButtonInner + " " + styles[appMode],
                    style: unreadButtonThemeStyle
                },
                React.createElement("span", {
                    className: styles.unreadMessagesText
                }, _this.props.t('unread.messages.button', {
                    count: unreadCount
                })), !hideArrow && React.createElement(ArrowDown, {
                    size: '18px'
                })))));
        };
        _this.state = {
            fetching: false,
            isScrollBottomBeforeReceiveMessage: true,
            showUnreadButton: false,
            anchorPosition: _this.props.lastReadMessageSequence,
        };
        _this.latestTitleKey = '';
        return _this;
    }
    MessagesList.prototype.componentDidMount = function() {
        if (this.props.messages.length > 0) {
            this.scrollDown();
        }
        if (this.container) {
            this.container.addEventListener('wheel', this.onWheel, {
                passive: false,
            });
        }
        chatEventEmitter.addListener(chatEventEmitter.CHAT_EVENTS.NEW_REALTIME_MESSAGE, this.handleRealtimeMessage);
        listenToVisibilityChange(this.onVisibilityChangeHandler);
    };
    MessagesList.prototype.componentWillUnmount = function() {
        if (this.container) {
            this.container.removeEventListener('wheel', this.onWheel);
        }
        chatEventEmitter.removeListener(chatEventEmitter.CHAT_EVENTS.NEW_REALTIME_MESSAGE, this.handleRealtimeMessage);
        removeListenerForVisibilityChange(this.onVisibilityChangeHandler);
    };
    MessagesList.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
        var aggregateStateChanges = {};
        var _a = this.state,
            fetching = _a.fetching,
            isScrollBottomBeforeReceiveMessage = _a.isScrollBottomBeforeReceiveMessage;
        if (fetching && this.fetchCompleted(nextProps)) {
            aggregateStateChanges.fetching = false;
        }
        var isScrollAtBottom = this.isScrollAtBottom();
        if (isScrollBottomBeforeReceiveMessage !== isScrollAtBottom) {
            aggregateStateChanges.isScrollBottomBeforeReceiveMessage =
                isScrollAtBottom;
        }
        if (!_isEmpty(aggregateStateChanges)) {
            this.setState(aggregateStateChanges);
        }
    };
    MessagesList.prototype.UNSAFE_componentWillUpdate = function(nextProps, nextState) {
        if (this.state.fetching && !nextState.fetching) {
            this.offsetBeforeFetchMore =
                this.container.scrollHeight - this.container.scrollTop;
        }
    };
    MessagesList.prototype.componentDidUpdate = function(prevProps, prevState) {
        var aggregateStateChanges = {};
        if (prevState.fetching && !this.state.fetching) {
            this.container.scrollTop =
                this.container.scrollHeight - this.offsetBeforeFetchMore;
            return;
        }
        if (this.shouldScroll(prevProps, this.props)) {
            this.scrollDown();
        }
        if (this.shouldDisplayUnreadButton(prevProps, this.props)) {
            aggregateStateChanges.showUnreadButton = true;
        }
        if (this.isUnreadMessagesButtonExperimentOn()) {
            // tslint:disable-next-line:no-collapsible-if
            if (this.didSendMessage(prevProps, this.props)) {
                this.scrollDown(true);
                aggregateStateChanges.anchorPosition =
                    this.props.lastReadMessageSequence;
            }
        }
        if (!prevProps.isVisible &&
            this.props.isVisible &&
            this.props.messages.length === 0 &&
            this.props.unfoldWhenEmpty) {
            this.handleOnEnterUnfoldHeader();
        }
        if (!_isEmpty(aggregateStateChanges)) {
            this.setState(aggregateStateChanges);
        }
    };
    MessagesList.prototype.fetchCompleted = function(nextProps) {
        var existingMessageId = this.props.messages &&
            this.props.messages.length &&
            this.props.messages[0].id;
        var nextMessageId = nextProps.messages &&
            nextProps.messages.length &&
            nextProps.messages[0].id;
        return existingMessageId !== nextMessageId;
    };
    MessagesList.prototype.scrollDown = function(toBottom) {
        if (toBottom === void 0) {
            toBottom = false;
        }
        var container = document.querySelector("#chat-messages-list");
        var unreadAnchor = document.querySelector("#chat-unread-anchor-wrapper");
        var messages = document.querySelectorAll(".chat-list-item");
        var typingIndication = document.querySelector("#typing-indication");
        unreadAnchor && !toBottom ?
            this.scrollToUnreadAnchor(container, unreadAnchor) :
            this.scrollToBottom(container, messages, typingIndication);
    };
    MessagesList.prototype.shouldScroll = function(prevProps, currProps) {
        var prevMessages = prevProps.messages,
            prevLastReadMessageSequence = prevProps.lastReadMessageSequence,
            prevUnreadCount = prevProps.unreadCount,
            prevHeaderExists = prevProps.headerExists,
            prevIsVisible = prevProps.isVisible,
            prevTypingStatus = prevProps.typingStatus;
        var currMessages = currProps.messages,
            currLastReadMessageSequence = currProps.lastReadMessageSequence,
            currUnreadCount = currProps.unreadCount,
            currHeaderExists = currProps.headerExists,
            currIsVisible = currProps.isVisible,
            currTypingStatus = currProps.typingStatus;
        var hasTypingChanged = prevTypingStatus !== currTypingStatus;
        if (this.isUnreadMessagesButtonExperimentOn()) {
            // tslint:disable-next-line:no-collapsible-if
            if (!this.state.isScrollBottomBeforeReceiveMessage) {
                return false;
            }
        }
        return (prevMessages.length !== currMessages.length ||
            prevLastReadMessageSequence !== currLastReadMessageSequence ||
            prevUnreadCount !== currUnreadCount ||
            prevHeaderExists !== currHeaderExists ||
            prevIsVisible !== currIsVisible ||
            (hasTypingChanged && this.state.isScrollBottomBeforeReceiveMessage));
    };
    MessagesList.prototype.scrollToBottom = function(container, messages, typingIndication) {
        if (messages.length > 0) {
            var lastMessage = typingIndication ?
                typingIndication :
                messages.item(messages.length - 1);
            var containerPaddingBottom = parseInt(getComputedStyle(container, null).paddingBottom || '0', 10);
            scrollIntoView(lastMessage, container, {
                alignWithTop: false,
                offsetBottom: containerPaddingBottom,
            });
        }
    };
    MessagesList.prototype.scrollToUnreadAnchor = function(container, unreadAnchor) {
        scrollIntoView(unreadAnchor, container, {
            alignWithTop: true
        });
    };
    MessagesList.prototype.isTimestampTooltipDisabled = function(position) {
        var isSystemMessage = position === Constants.MessageDirections.System;
        if (this.props.timestampTooltipConfig) {
            return (this.props.timestampTooltipConfig === TimestampTooltipPosition.NONE ||
                isSystemMessage);
        }
        return this.props.appMode !== AppMode.FullApp || isSystemMessage;
    };
    MessagesList.prototype.getTimestampTooltipPosition = function(messagePosition) {
        var position = this.props.timestampTooltipConfig;
        var defaultPosition = messagePosition === Constants.MessageDirections.Incoming ?
            'right' :
            'left';
        return position && position !== TimestampTooltipPosition.NONE ?
            position :
            defaultPosition;
    };
    MessagesList.prototype.isFullApp = function() {
        return this.props.appMode === AppMode.FullApp;
    };
    MessagesList.prototype.isFullWidth = function(rawMessage) {
        return MessageUtils.isEmail(rawMessage) && this.isFullApp();
    };
    MessagesList.prototype.renderBubbleByType = function(messageWithProps, instanceId) {
        var _this = this;
        var position = messageWithProps.position,
            groupPosition = messageWithProps.groupPosition,
            messagePart = messageWithProps.messagePart,
            senderUserId = messageWithProps.senderUserId,
            message = messageWithProps.message,
            wrapWithBubble = messageWithProps.wrapWithBubble,
            formattedTimestamp = messageWithProps.formattedTimestamp,
            title = messageWithProps.title,
            transit = messageWithProps.transit,
            isCustomType = messageWithProps.isCustomType,
            type = messageWithProps.type,
            rawMessage = messageWithProps.rawMessage;
        var _a = this.props,
            chatAppsRegistry = _a.chatAppsRegistry,
            theme = _a.theme,
            sendersData = _a.sendersData,
            onSendAgain = _a.onSendAgain,
            messageDisplayOption = _a.messageDisplayOption,
            useAvatarTooltip = _a.useAvatarTooltip,
            eventHooks = _a.eventHooks,
            isGroupChat = _a.isGroupChat,
            onButtonInteraction = _a.onButtonInteraction,
            getIndicationData = _a.getIndicationData,
            compactView = _a.compactView;
        var messageData = messagePart ? {
            messagePart: messagePart
        } : {
            message: message
        };
        var emphasisBubble = this.isFullApp() && type === Constants.MessageTypes.Templates.Standard;
        var whiteBubble = type === Constants.MessageTypes.Templates.Minimal ||
            type === Constants.MessageTypes.Templates.Standard;
        var fontFamily = _get(theme, 'room.fontFamily');
        var tooltipStyledTimestamp = (React.createElement("span", {
            style: {
                fontFamily: fontFamily
            }
        }, formattedTimestamp));
        var _b = message && message.templateData ? message.templateData : {},
            _c = _b.appData,
            appData = _c === void 0 ? {} : _c,
            _d = _b.appName,
            appName = _d === void 0 ? undefined : _d, // tslint:disable-line:no-unnecessary-initializer
            _e = _b.orientation, // tslint:disable-line:no-unnecessary-initializer
            orientation = _e === void 0 ? undefined : _e;
        var isRegisteredChatApp = isCustomType && chatAppsRegistry.isAppRegistered(appName);
        var chatAppOptions = isRegisteredChatApp ?
            chatAppsRegistry.getConfigByApp(appName) :
            {};
        var PluginComponent = isRegisteredChatApp ?
            chatAppsRegistry.getComponentByApp(appName) :
            null;
        var isChatAppWithOption = function(optionKey) {
            return isRegisteredChatApp &&
                !_isEmpty(chatAppOptions) &&
                !_isUndefined(chatAppOptions[optionKey]);
        };
        var WrappedComponent = PluginComponent || this.getComponentByType(type, orientation);
        if (!WrappedComponent) {
            return null;
        }
        var titleToPresent = function() {
            if (title === _this.latestTitleKey &&
                groupPosition !== 'start' &&
                groupPosition !== 'single') {
                return;
            }
            _this.latestTitleKey = title;
            return title;
        };
        var renderTitle = titleToPresent();
        return (React.createElement(MessageEntry, {
                wrapWithBubble: isChatAppWithOption('wrapWithBubble') ?
                    chatAppOptions.wrapWithBubble :
                    wrapWithBubble,
                position: isChatAppWithOption('position') ? chatAppOptions.position : position,
                groupPosition: isChatAppWithOption('groupPosition') ?
                    chatAppOptions.groupPosition :
                    groupPosition,
                title: renderTitle,
                separateTitle: isTypeHasSeparatedTitle(type),
                sendersData: sendersData,
                senderUserId: senderUserId,
                transit: transit,
                rawMessage: rawMessage,
                messagePart: messagePart,
                onSendAgain: onSendAgain,
                messageDisplayOption: isChatAppWithOption('messageDisplayOption') ?
                    chatAppOptions.messageDisplayOption :
                    messageDisplayOption,
                useAvatarTooltip: isChatAppWithOption('useAvatarTooltip') ?
                    chatAppOptions.useAvatarTooltip :
                    useAvatarTooltip,
                emphasisBubble: emphasisBubble,
                whiteBubble: whiteBubble,
                isLastMessage: this.isLastMessage(messageWithProps),
                eventHooks: eventHooks,
                isGroupChat: isGroupChat,
                getIndicationData: getIndicationData,
                compactView: compactView,
                isFullWidth: this.isFullWidth(rawMessage)
            },
            React.createElement(Tooltip, {
                    dataHook: "timestamp-tooltip",
                    content: tooltipStyledTimestamp,
                    disabled: isChatAppWithOption('withTimestampTooltip') ?
                        !chatAppOptions.withTimestampTooltip :
                        this.isTimestampTooltipDisabled(position),
                    placement: this.getTimestampTooltipPosition(position),
                    textAlign: "center"
                },
                React.createElement("div", null,
                    React.createElement(WrappedComponent, __assign({
                        instanceId: instanceId
                    }, messageData, appData, {
                        transit: transit,
                        eventHooks: eventHooks,
                        title: renderTitle,
                        titleExists: !!renderTitle,
                        onButtonInteraction: onButtonInteraction
                    }))))));
    };
    MessagesList.prototype.messageListItem = function(WrappedComponent, key, groupPosition) {
        var theme = this.props.theme;
        var marginBetweenMessages = _get(theme, 'room.marginBetweenMessages');
        var marginBetweenGroupMessages = _get(theme, 'room.marginBetweenGroupMessages');
        var isEndOrMiddle = groupPosition === 'end' || groupPosition === 'middle';
        var marginTop = isEndOrMiddle ?
            marginBetweenGroupMessages :
            marginBetweenMessages;
        var marginStyle = marginTop ? {
            marginTop: marginTop
        } : {};
        return (React.createElement("div", {
            key: key,
            "data-hook": "message-list-item",
            className: styles.listItem + " " + styles[groupPosition || 'standalone'] + " chat-list-item",
            style: marginStyle
        }, WrappedComponent));
    };
    MessagesList.prototype.renderTyping = function() {
        var _a = this.props,
            _b = _a.typingStatus,
            typingStatus = _b === void 0 ? [] : _b,
            isGroupChat = _a.isGroupChat;
        if (!typingStatus.length) {
            return;
        }
        if (isGroupChat) {
            return React.createElement(TypingMessage, {
                usersTyping: typingStatus
            });
        }
        return (React.createElement("div", {
                "data-hook": "typing-indication",
                id: "chat-typing-indication",
                className: styles.typingIndication
            },
            React.createElement(MessageEntry, {
                    wrapWithBubble: true,
                    position: Constants.MessageDirections.Incoming,
                    groupPosition: 'single',
                    sendersData: this.props.sendersData,
                    senderUserId: typingStatus[0].userId,
                    messageDisplayOption: this.props.messageDisplayOption,
                    eventHooks: this.props.eventHooks
                },
                React.createElement("div", null, this.renderTypingAnimation()))));
    };
    MessagesList.prototype.renderTypingAnimation = function() {
        var customTypingAnimation = this.props.customTypingAnimation;
        // for custom animation
        var pointsColor = _get(this.props.theme, 'room.typingIndication.pointsColor');
        var pointStyle = pointsColor ? {
            background: pointsColor
        } : {};
        // for preset animation by `look`
        var incomingTextColor = _get(this.props.theme, 'room.message.incomingTextColor');
        var animationLook = _get(this.props.theme, 'room.typingIndication.look');
        var lookAnimation = animationLook && (typingStyles === null || typingStyles === void 0 ? void 0 : typingStyles[animationLook]) && (React.createElement("div", {
            "data-hook": "typing-animation-look",
            className: typingStyles[animationLook],
            style: {
                color: getRgbA(incomingTextColor || '#000000', 0.6)
            }
        }));
        return customTypingAnimation ? (customTypingAnimation) : lookAnimation ? (lookAnimation) : (React.createElement("div", {
                className: typingStyles.typingAnimation
            },
            React.createElement("div", {
                    className: typingStyles.points
                },
                React.createElement("div", {
                    "data-hook": "typing-indication-point",
                    className: typingStyles.arrow + " " + typingStyles.bounce + " " + typingStyles.point1,
                    style: pointStyle
                }),
                React.createElement("div", {
                    "data-hook": "typing-indication-point",
                    className: typingStyles.arrow + " " + typingStyles.bounce + " " + typingStyles.point2,
                    style: pointStyle
                }),
                React.createElement("div", {
                    "data-hook": "typing-indication-point",
                    className: typingStyles.arrow + " " + typingStyles.bounce + " " + typingStyles.point3,
                    style: pointStyle
                }))));
    };
    /* eslint-enable */
    MessagesList.prototype._filterAutoMessagesIfNecessary = function(messageList) {
        var disableAutoMessages = this.props.disableAutoMessages;
        return messageList.filter(function(message) {
            var isAutoMessageAndShouldFilter = disableAutoMessages && message.isAutoMessage;
            return !isAutoMessageAndShouldFilter;
        });
    };
    MessagesList.prototype.render = function() {
        var _this = this;
        var _a, _b;
        var _c = this.props,
            messages = _c.messages,
            unreadCount = _c.unreadCount,
            theme = _c.theme,
            userId = _c.userId,
            appMode = _c.appMode,
            messageDirectionOverride = _c.messageDirectionOverride,
            instanceId = _c.instanceId,
            isGroupChat = _c.isGroupChat,
            containerStyle = _c.containerStyle,
            t = _c.t,
            sendersData = _c.sendersData,
            messageDisplayOption = _c.messageDisplayOption;
        var backgroundColor = _get(theme, 'room.background');
        var backgroundImage = _get(theme, 'room.pattern.asset');
        var backgroundSize = _get(theme, 'room.pattern.backgroundSize');
        var fontFamily = _get(theme, 'room.fontFamily');
        var hideTimestampStroke = _get(theme, 'room.timestamp.hideStroke');
        var timestampLook = _get(theme, 'room.timestamp.look');
        var timestampThemeStyle = !timestampLook ?
            {
                color: _get(theme, 'room.timestamp.color'),
                fontFamily: fontFamily,
            } :
            {};
        var padding = _get(theme, 'room.padding');
        var paddingStyle = padding ? {
            padding: padding
        } : {};
        var style = {
            style: __assign(__assign({}, containerStyle), paddingStyle)
        };
        if (backgroundColor) {
            Object.assign(style.style, {
                backgroundColor: backgroundColor
            });
        }
        if (backgroundImage) {
            if (backgroundColor && backgroundColor.includes('gradient')) {
                Object.assign(style.style, {
                    background: backgroundImage + " center " + backgroundSize.split(' ')[0] + ", " + backgroundColor,
                });
            } else {
                Object.assign(style.style, {
                    backgroundImage: backgroundImage
                }, {
                    backgroundSize: backgroundSize
                }, {
                    backgroundPosition: 'center center'
                });
            }
        }
        var listWithProps = new MessageUtils({
            messages: messages,
            userId: userId,
            lastReadMessageSequence: this.state.anchorPosition,
            unreadCount: unreadCount,
            messageDirectionOverride: messageDirectionOverride,
            includeTitle: isGroupChat || (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.titleOption) !== TitleConfig.NONE,
            appMode: appMode,
            sendersData: sendersData,
        }).getListWithProps();
        var messageList = this._filterAutoMessagesIfNecessary(listWithProps);
        return (React.createElement("div", {
                className: styles.messagesListRoot
            },
            React.createElement("div", __assign({}, style, {
                    className: classNames(styles.messagesList, styles[appMode]),
                    "data-hook": "message-list",
                    id: "chat-messages-list",
                    onWheel: this.onWheel,
                    onScroll: this.onScroll,
                    ref: function(ref) {
                        return (_this.container = ref);
                    },
                    role: "log",
                    tabIndex: 0,
                    "aria-label": this.props.t('messages.title.aria-label')
                }),
                this.state.fetching && (React.createElement("div", {
                        "data-hook": "fetch-more-loader",
                        className: styles.fetchMoreLoader
                    },
                    React.createElement(Loader, {
                        size: "small"
                    }))),
                React.createElement(Waypoint, {
                    key: "fetch-more-waypoint",
                    onEnter: this.handleOnEnterTopArea,
                    onLeave: this.handleOnLeaveTopArea
                }),
                messageList.map(function(item, index) {
                    if (item.unreadCount) {
                        var anchorText = _this.isUnreadMessagesButtonExperimentOn() ?
                            t('unread.messages.anchor') :
                            t(item.unreadCount > 1 ?
                                'unread.messages.old_anchor_plural' :
                                'unread.messages.old_anchor', {
                                    count: item.unreadCount
                                });
                        return _this.messageListItem(React.createElement(UnreadAnchor, {
                            anchorText: anchorText
                        }), (item.message && item.message.id) || index);
                    }
                    if (item.timestamp) {
                        return _this.messageListItem(React.createElement("div", {
                                className: classNames(styles.timestamp, styles[timestampLook]),
                                style: timestampThemeStyle,
                                "data-hook": "timestamp-anchor"
                            }, !hideTimestampStroke && (React.createElement("div", {
                                className: styles.timestampLine,
                                "data-hook": "timestamp-line"
                            })),
                            React.createElement("div", {
                                className: styles.timestampText
                            }, item.timestamp), !hideTimestampStroke && (React.createElement("div", {
                                className: styles.timestampLine,
                                "data-hook": "timestamp-line"
                            }))), (item.message && item.message.id) || index);
                    }
                    return _this.messageListItem(_this.renderBubbleByType(item, instanceId), (item.message && item.message.id) || index, item.groupPosition);
                }),
                this.renderTyping(), (_b = (_a = this.props).getFooter) === null || _b === void 0 ? void 0 :
                _b.call(_a)),
            this.state.showUnreadButton && this.renderUnreadMessagesButton()));
    };
    return MessagesList;
}(React.Component));
export default withChatAppsRegistry(withDisableAutoMessages(withTheme(withAppMode(translate()(MessagesList)))));
//# sourceMappingURL=MessagesList.js.map