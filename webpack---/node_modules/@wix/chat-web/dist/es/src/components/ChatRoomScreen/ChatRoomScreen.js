import {
    __assign,
    __awaiter,
    __extends,
    __generator
} from "tslib";
import React from 'react';
import webBiLogger from '@wix/web-bi-logger';
import {
    chatSdk,
    chatEventEmitter,
} from '@wix/chat-sdk';
import ChatRoom from '../ChatRoom/ChatRoom';
import withAppProviders from './withAppProviders';
import {
    Experiments
} from '../../constants/experiments';
import _get from 'lodash/get';
import {
    isDocumentVisible,
    listenToVisibilityChange,
    removeListenerForVisibilityChange,
} from '../../services/visibility-change/visibility-change';
var ChatRoomScreen = /** @class */ (function(_super) {
    __extends(ChatRoomScreen, _super);

    function ChatRoomScreen(props) {
        var _this = _super.call(this, props) || this;
        _this.onInitialFetchDone = function(room) {
            _this._setUnreadDisplay(room);
            chatSdk.setMessagesRead({
                chatroomId: _this.props.chatroomId
            });
            _this.setState({
                initialFetchDone: true,
            });
            _this.props.eventHooks &&
                _this.props.eventHooks.onInitialFetchDone &&
                _this.props.eventHooks.onInitialFetchDone();
        };
        _this._clearUnreadDisplay = function() {
            _this.setState({
                displayLastReadMessageSequence: undefined,
                displayUnreadCount: 0,
            });
        };
        _this.onRoomChanged = function(newChatroom) {
            var messages = newChatroom.messages;
            var chatroom = _this.state.chatroom;
            var oldMessages = chatroom.messages;
            if (_this._bothArrayEmpty(messages, oldMessages)) {
                delete newChatroom.messages; //to avoid wasted render
            }
            var prevMessagesAmount = chatroom.messages ? chatroom.messages.length : 0;
            var messagesAmount = messages ? messages.length : 0;
            if (prevMessagesAmount !== messagesAmount) {
                var shouldFoldHeader = messages && messages.length > 0;
                shouldFoldHeader && _this.props.foldHeader && _this.props.foldHeader();
            }
            _this.props.onRoomChanged && _this.props.onRoomChanged(newChatroom);
            if (chatSdk.isExperimentOn(Experiments.UnreadMessagesButtonDesktop)) {
                _this._setUnreadDisplay(newChatroom);
            }
            _this.setState(function(prevState) {
                return ({
                    chatroom: __assign(__assign({}, prevState.chatroom), newChatroom),
                });
            });
            var participants = newChatroom.participants;
            if (participants && participants.length) {
                var newSendersData_1 = [];
                participants.forEach(function(participant) {
                    var newSender = {
                        id: participant.id,
                        profileImage: _get(participant, 'displayData.image.url', ''),
                        userName: _get(participant, 'displayData.name', ''),
                    };
                    newSendersData_1.push(newSender);
                });
                _this.setState({
                    enrichSendersData: newSendersData_1
                });
            }
        };
        _this.setMessagesRead = function() {
            var chatroom = _this.state.chatroom;
            if (chatSdk.isExperimentOn(Experiments.UnreadMessagesButtonDesktop)) {
                // tslint:disable-next-line:no-collapsible-if
                if (chatroom.unreadCount && _this.isChatOnFocus()) {
                    chatSdk.setMessagesRead({
                        chatroomId: _this.props.chatroomId
                    });
                }
            }
        };
        _this.onTyping = function(text) {
            var id = _this.state.chatroom.id;
            if (id) {
                chatSdk.notifyTyping(id, text);
            }
            var _a = _this.props.eventHooks.onTyping,
                onTyping = _a === void 0 ? function() {} : _a;
            onTyping();
        };
        _this.onVisibilityChangeHandler = function() {
            if (isDocumentVisible() &&
                !chatSdk.isExperimentOn(Experiments.UnreadMessagesButtonDesktop)) {
                chatSdk.setMessagesRead({
                    chatroomId: _this.props.chatroomId
                });
                _this._setUnreadDisplay({
                    unreadCount: _this.state.displayUnreadCount,
                    lastReadMessageSequence: _this.state.displayLastReadMessageSequence,
                });
            }
        };
        _this.handleAddMessage = function(message) {
            return __awaiter(_this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.props.isVisible) {
                                this.sendErrorBI();
                                return [2 /*return*/ ];
                            }
                            return [4 /*yield*/ , chatSdk.addMessage(message)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/ ];
                    }
                });
            });
        };
        _this.prepareChatroomToSendMessage = function(chatroomId) {
            _this._clearUnreadDisplay();
            _this._clearDraftForChatroom(chatroomId);
            _this.setMessagesRead();
        };
        _this.handleSendMessage = function(message) {
            return __awaiter(_this, void 0, void 0, function() {
                var _a, chatroomId, isVisible, dummyMode, _b, _c, _d, onSendMessage, _e, onSendMessageSuccess;
                return __generator(this, function(_f) {
                    switch (_f.label) {
                        case 0:
                            _a = this.props, chatroomId = _a.chatroomId, isVisible = _a.isVisible, dummyMode = _a.dummyMode, _b = _a.eventHooks, _c = _b === void 0 ? {} : _b, _d = _c.onSendMessage, onSendMessage = _d === void 0 ? function() {} : _d, _e = _c.onSendMessageSuccess, onSendMessageSuccess = _e === void 0 ? function() {} : _e;
                            if (!isVisible) {
                                this.sendErrorBI();
                                return [2 /*return*/ ];
                            }
                            onSendMessage(message.dto);
                            if (!!dummyMode) return [3 /*break*/ , 2];
                            this.prepareChatroomToSendMessage(chatroomId);
                            return [4 /*yield*/ , chatSdk.sendMessage(message)];
                        case 1:
                            _f.sent();
                            _f.label = 2;
                        case 2:
                            onSendMessageSuccess(message);
                            return [2 /*return*/ ];
                    }
                });
            });
        };
        _this.handleButtonInteraction = function(button) {
            return __awaiter(_this, void 0, void 0, function() {
                var _a, chatroomId, dummyMode, _b, _c, onButtonInteraction;
                return __generator(this, function(_d) {
                    switch (_d.label) {
                        case 0:
                            _a = this.props, chatroomId = _a.chatroomId, dummyMode = _a.dummyMode, _b = _a.eventHooks, _c = (_b === void 0 ? {} : _b).onButtonInteraction, onButtonInteraction = _c === void 0 ? function() {} : _c;
                            onButtonInteraction(button);
                            if (!!dummyMode) return [3 /*break*/ , 2];
                            this.prepareChatroomToSendMessage(chatroomId);
                            return [4 /*yield*/ , chatSdk.buttonInteraction(button, chatroomId)];
                        case 1:
                            _d.sent();
                            _d.label = 2;
                        case 2:
                            return [2 /*return*/ ];
                    }
                });
            });
        };
        _this.sendErrorBI = function() {
            _this.logger.log({
                evid: 572,
                tagId: 'sendDisabledBug',
                description: 'widget should be closed! How this message was sent??',
            });
        };
        _this.handleSendAgain = function(message) {
            return chatSdk.sendMessage(message);
        };
        _this._bothArrayEmpty = function(arr, arrOther) {
            return arr && arrOther && arr.length === 0 && arrOther.length === 0;
        };
        _this.loadMore = function() {
            return _this.room && _this.room.fetchMore(_this.state.chatroom.cursor);
        };
        _this.state = {
            chatroom: {
                messages: [],
            },
            //   ^^^
            // Hacky way of providing a default messages array in case it's not yet present
            enrichSendersData: [],
            initialFetchDone: false,
            hasError: false,
            error: null,
        };
        //NOTE - this logger is temporary to find a production issue. If you wish to use a logger here,
        // please set event consts in sdk and change the endpoint accordingly
        _this.logger = webBiLogger
            .factory({
                endpoint: 'chat'
            })
            .updateDefaults({
                src: 5
            })
            .logger();
        return _this;
    }
    ChatRoomScreen.prototype._setUnreadDisplay = function(_a) {
        var lastReadMessageSequence = _a.lastReadMessageSequence,
            unreadCount = _a.unreadCount;
        if (unreadCount) {
            this.setState({
                displayLastReadMessageSequence: lastReadMessageSequence,
                displayUnreadCount: unreadCount,
            });
        }
    };
    ChatRoomScreen.prototype._clearDraftForChatroom = function(chatroomId) {
        chatSdk.notifyTypingTextChange(chatroomId, '', false);
    };
    ChatRoomScreen.prototype.isChatOnFocus = function() {
        return isDocumentVisible();
    };
    ChatRoomScreen.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
        var chatroomId = nextProps.chatroomId;
        if (nextProps.chatroomId !== this.props.chatroomId) {
            this.unsubscribe();
            this.subscribeToRoom({
                chatroomId: chatroomId
            });
        }
    };
    ChatRoomScreen.prototype.unsubscribe = function() {
        if (this.room) {
            this.room.unsubscribe();
        }
        if (this.unsubscribeFromRealtimeMessage) {
            this.unsubscribeFromRealtimeMessage();
            this.unsubscribeFromRealtimeMessage = undefined;
        }
    };
    ChatRoomScreen.prototype.subscribeToRoom = function(_a) {
        var _this = this;
        var chatroomId = _a.chatroomId;
        this.setState({
            hasError: false,
            error: null
        });
        this.room = chatSdk.subscribeToChatRoom({
            chatroomId: chatroomId,
            onChange: this.onRoomChanged,
            onInitialFetchDone: this.onInitialFetchDone,
            onError: function(err) {
                return _this.setState({
                    hasError: true,
                    error: err
                });
            },
        });
        var handleRealtimeMessage = function(message) {
            if (message.chatroomId === chatroomId) {
                _this.onNewMessage();
            }
        };
        chatEventEmitter.addListener(chatEventEmitter.CHAT_EVENTS.NEW_REALTIME_MESSAGE, handleRealtimeMessage);
        this.unsubscribeFromRealtimeMessage = function() {
            chatEventEmitter.removeListener(chatEventEmitter.CHAT_EVENTS.NEW_REALTIME_MESSAGE, handleRealtimeMessage);
        };
    };
    ChatRoomScreen.prototype.onNewMessage = function() {
        var _a = this.props.eventHooks.onMessageReceived,
            onMessageReceived = _a === void 0 ? function() {} : _a;
        onMessageReceived();
        if (this.isChatOnFocus()) {
            if (!chatSdk.isExperimentOn(Experiments.UnreadMessagesButtonDesktop)) {
                this._clearUnreadDisplay();
                chatSdk.setMessagesRead({
                    chatroomId: this.props.chatroomId
                });
            }
        } else {
            this._setUnreadDisplay({
                unreadCount: this.state.displayUnreadCount,
                lastReadMessageSequence: this.state.displayLastReadMessageSequence,
            });
        }
    };
    ChatRoomScreen.prototype.componentDidMount = function() {
        var _a;
        var _b = this.props,
            chatroomId = _b.chatroomId,
            dummyMode = _b.dummyMode,
            eventHooks = _b.eventHooks;
        if (!dummyMode) {
            this.subscribeToRoom({
                chatroomId: chatroomId
            });
            listenToVisibilityChange(this.onVisibilityChangeHandler);
            (_a = eventHooks === null || eventHooks === void 0 ? void 0 : eventHooks.onChatroomScreenLoaded) === null || _a === void 0 ? void 0 : _a.call(eventHooks, chatroomId);
        }
    };
    ChatRoomScreen.prototype.componentDidUpdate = function(prevProps) {
        if (this.collapsing(prevProps) && this.isChatOnFocus()) {
            this._clearUnreadDisplay();
        }
    };
    ChatRoomScreen.prototype.collapsing = function(_a) {
        var isVisible = _a.isVisible;
        return isVisible && !this.props.isVisible;
    };
    ChatRoomScreen.prototype.componentWillUnmount = function() {
        this.unsubscribe && this.unsubscribe();
        removeListenerForVisibilityChange(this.onVisibilityChangeHandler);
    };
    ChatRoomScreen.prototype.render = function() {
        var _this = this;
        var _a = this.props,
            header = _a.header,
            eventHooks = _a.eventHooks,
            className = _a.className,
            disabled = _a.disabled,
            isVisible = _a.isVisible,
            messageDirectionOverride = _a.messageDirectionOverride,
            sendOnEnter = _a.sendOnEnter,
            instanceId = _a.instanceId,
            foldHeader = _a.foldHeader,
            unfoldHeader = _a.unfoldHeader,
            isHeaderFolded = _a.isHeaderFolded,
            isMobile = _a.isMobile,
            isCollapsedAndRounded = _a.isCollapsedAndRounded,
            shouldApplyExpandAnimation = _a.shouldApplyExpandAnimation,
            shouldApplyCollapseAnimation = _a.shouldApplyCollapseAnimation,
            sendersData = _a.sendersData,
            getInputSendViaIndication = _a.getInputSendViaIndication,
            banner = _a.banner,
            unfoldWhenEmpty = _a.unfoldWhenEmpty,
            getInputOverrideComponent = _a.getInputOverrideComponent,
            messageDisplayOption = _a.messageDisplayOption,
            timestampTooltipConfig = _a.timestampTooltipConfig,
            customTypingAnimation = _a.customTypingAnimation,
            useAvatarTooltip = _a.useAvatarTooltip,
            inputKeyboards = _a.inputKeyboards,
            inputButtons = _a.inputButtons,
            containerStyle = _a.containerStyle,
            chatroomId = _a.chatroomId,
            onUploadFile = _a.onUploadFile,
            compactView = _a.compactView,
            emptyState = _a.emptyState,
            loadingState = _a.loadingState,
            errorState = _a.errorState,
            getErrorStateComponent = _a.getErrorStateComponent,
            deliveryMethods = _a.deliveryMethods,
            inputPlaceholder = _a.inputPlaceholder,
            showSendButton = _a.showSendButton,
            getIndicationData = _a.getIndicationData,
            getFooter = _a.getFooter,
            subjectStrategy = _a.subjectStrategy;
        var chatroom = this.state.chatroom;
        var typingStatus = this.props.typingStatus ?
            this.props.typingStatus :
            chatroom.typingStatus;
        var errorStateComponent = getErrorStateComponent ?
            getErrorStateComponent(this.state.error) :
            errorState; //todo this.state.error can be null - need to deal with that in the client
        return (React.createElement(ChatRoom, {
            hasMore: !!chatroom.cursor,
            loadMore: this.loadMore,
            className: className,
            disabled: disabled,
            onSendMessage: this.handleSendMessage,
            onAddMessage: this.handleAddMessage,
            onSendAgain: this.handleSendAgain,
            onUploadFile: onUploadFile,
            onClearUnreadDisplay: this._clearUnreadDisplay,
            onButtonInteraction: this.handleButtonInteraction,
            handleTyping: this.onTyping,
            header: header,
            messages: chatroom.messages,
            userId: chatSdk.getUserId(),
            chatroomId: chatroomId,
            unreadCount: this.state.displayUnreadCount,
            lastReadMessageSequence: this.state.displayLastReadMessageSequence,
            eventHooks: eventHooks,
            messageDirectionOverride: messageDirectionOverride ?
                function(message) {
                    return messageDirectionOverride(message, _this.state.chatroom);
                } :
                undefined,
            sendOnEnter: sendOnEnter,
            instanceId: instanceId,
            isVisible: isVisible,
            isGroupChat: !chatroom.isPrivate,
            foldHeader: foldHeader,
            unfoldHeader: unfoldHeader,
            isHeaderFolded: isHeaderFolded,
            isMobile: isMobile,
            isCollapsedAndRounded: isCollapsedAndRounded,
            shouldApplyExpandAnimation: shouldApplyExpandAnimation,
            shouldApplyCollapseAnimation: shouldApplyCollapseAnimation,
            sendersData: sendersData && sendersData.length ?
                sendersData :
                this.state.enrichSendersData,
            getInputSendViaIndication: getInputSendViaIndication,
            offlineChannels: chatroom.offlineChannels,
            banner: banner,
            unfoldWhenEmpty: unfoldWhenEmpty,
            inputOverrideComponent: getInputOverrideComponent(chatroom),
            inputPlaceholder: inputPlaceholder,
            messageDraft: chatroom.initialMessageDraft,
            messageDisplayOption: messageDisplayOption,
            typingStatus: typingStatus,
            timestampTooltipConfig: timestampTooltipConfig,
            customTypingAnimation: customTypingAnimation,
            useAvatarTooltip: useAvatarTooltip,
            setMessagesRead: this.setMessagesRead,
            containerStyle: containerStyle,
            inputKeyboards: inputKeyboards,
            inputButtons: inputButtons,
            compactView: compactView,
            emptyState: emptyState,
            loadingState: loadingState,
            errorState: errorStateComponent,
            hasError: this.state.hasError,
            initialFetchDone: this.state.initialFetchDone,
            otherParticipantId: chatroom.otherParticipantId,
            deliveryMethods: deliveryMethods,
            showSendButton: showSendButton,
            getIndicationData: getIndicationData,
            getFooter: getFooter,
            subjectStrategy: subjectStrategy
        }));
    };
    ChatRoomScreen.defaultProps = {
        dummyMode: false,
        eventHooks: {},
        isVisible: true,
        isCollapsedAndRounded: false,
        shouldApplyExpandAnimation: false,
        shouldApplyCollapseAnimation: false,
        sendersData: [],
        unfoldWhenEmpty: true,
        getInputOverrideComponent: function() {
            return null;
        },
    };
    return ChatRoomScreen;
}(React.Component));
export default withAppProviders(ChatRoomScreen);
//# sourceMappingURL=ChatRoomScreen.js.map