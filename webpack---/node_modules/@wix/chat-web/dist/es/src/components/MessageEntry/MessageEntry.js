var _a;
import {
    __assign,
    __extends
} from "tslib";
import React, {
    Component
} from 'react';
import {
    Constants,
    IMessageTypes,
    chatSdk,
} from '@wix/chat-sdk';
import styles from './MessageEntry.scss';
import withTheme from '../../providers/theme/withTheme';
import withAppMode from '../../providers/appMode/withAppMode';
import _get from 'lodash/get';
import {
    AppMode,
    AvatarConfig,
    TitleConfig,
} from '../..';
import {
    Text,
    Tooltip
} from 'wix-style-react';
import {
    translate
} from 'react-i18next';
import classNames from 'classnames';
import WithMessageIndications from '../WithMessageIndications/WithMessageIndications';
import {
    getPaletteColorByString
} from '../../services/paletteColor';
import AvatarWrapper from '../AvatarWrapper/AvatarWrapper';
import {
    getRgbA
} from '../../services/color-utils';
import {
    messageIcons
} from './MessageIcons';
import {
    MimeTypes,
} from '@wix/chat-sdk/lib/src/constants/constants';
import {
    Experiments
} from '../../constants/experiments';
var APP_AVATAR_SIZE_WSR = 'size30';
var WIDGET_AVATAR_SIZE_WSR = 'size30';
var _b = Constants.MessageDirections,
    Incoming = _b.Incoming,
    Outgoing = _b.Outgoing,
    System = _b.System;
var positionToClass = (_a = {},
    _a[Outgoing] = 'right',
    _a[System] = 'center',
    _a[Incoming] = 'left',
    _a);
var MessageEntry = /** @class */ (function(_super) {
    __extends(MessageEntry, _super);

    function MessageEntry() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isFullApp = function() {
            return _this.props.appMode === AppMode.FullApp;
        };
        _this.isImage = function() {
            var _a;
            return ((_a = _this.props.messagePart) === null || _a === void 0 ? void 0 : _a.mimeType) === MimeTypes.Image;
        };
        _this.isFile = function() {
            var _a;
            return ((_a = _this.props.messagePart) === null || _a === void 0 ? void 0 : _a.mimeType) === MimeTypes.File;
        };
        _this.onClickOnDrillInMessageIndications = function(messageId) {
            _this.props.eventHooks &&
                _this.props.eventHooks.onClickOnDrillInMessageIndications &&
                _this.props.eventHooks.onClickOnDrillInMessageIndications(messageId);
        };
        _this.shouldRenderCustomMessageBadges = function() {
            var _a;
            var _b = _this.props,
                appMode = _b.appMode,
                rawMessage = _b.rawMessage,
                messagePart = _b.messagePart,
                isFullWidth = _b.isFullWidth;
            var isFullApp = appMode === AppMode.FullApp;
            var hasMessageBadge = (_a = rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.badges) === null || _a === void 0 ? void 0 : _a[0];
            var isForm = (rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.messageType) === IMessageTypes.template_form;
            var isCustom = (rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.messageType) === IMessageTypes.template_custom;
            var messageMimeType = messagePart === null || messagePart === void 0 ? void 0 : messagePart.mimeType;
            var isPlainText = messageMimeType === MimeTypes.PlainText;
            return (hasMessageBadge &&
                isFullApp &&
                (isForm || isFullWidth || isPlainText || isCustom));
        };
        _this.getMessageBadge = function() {
            var rawMessage = _this.props.rawMessage;
            var messageBadge = ((rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.badges) || [])[0];
            return messageBadge;
        };
        _this.renderMessageBadgeIfNecessary = function() {
            var _a;
            var position = _this.props.position;
            var messageBadge = _this.getMessageBadge();
            if (!_this.shouldRenderCustomMessageBadges()) {
                return null;
            }
            var badge = _this.resolveBadgeMessageBadge(messageBadge);
            return (React.createElement("div", {
                    "data-hook": "message-badge-wrapper",
                    className: classNames(styles.messageBadge)
                },
                badge,
                React.createElement(Text, {
                    weight: "normal",
                    size: "tiny",
                    secondary: false,
                    light: position === Outgoing,
                    dataHook: "message-badge-text",
                    className: classNames(styles.messageBadgeText, (_a = {},
                        _a[styles.messageBadgeDark] = _this.isDarkBadge(),
                        _a))
                }, messageBadge.text)));
        };
        return _this;
    }
    MessageEntry.prototype.resolveBadgeMessageBadge = function(badge) {
        var _a, _b;
        var _c;
        var _d = this.props,
            position = _d.position,
            theme = _d.theme;
        return (React.createElement("div", {
            "data-hook": "message-badge-icon-wrapper",
            className: classNames(styles.messageBadgeIconWrapper, (_a = {},
                _a[styles.messageBadgeDark] = this.isDarkBadge(),
                _a))
        }, badge.icon && messageIcons[badge.icon] ? (messageIcons[badge.icon]) : ((_c = badge.image) === null || _c === void 0 ? void 0 : _c.url) ? (React.createElement("div", {
            "data-hook": "message-badge-icon",
            style: {
                backgroundImage: "url(" + _get(badge, 'image.url') + ")",
            },
            className: classNames(styles.imageIcon, (_b = {},
                _b[styles.messageBadgeDark] = this.isDarkBadge(),
                _b))
        })) : null));
    };
    MessageEntry.prototype.isDarkBadge = function() {
        var _a = this.props,
            position = _a.position,
            theme = _a.theme;
        var outgoingBadgeDark = _get(theme, 'room.message.outgoingBadgeDark', undefined);
        return outgoingBadgeDark && position === Outgoing;
    };
    MessageEntry.prototype.getMessageBorder = function() {
        var _a = this.props,
            theme = _a.theme,
            position = _a.position,
            rawMessage = _a.rawMessage;
        var showBorder = (rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.messageType) === Constants.MessageTypes.Message;
        var isOutgoing = position === Outgoing;
        var outgoingBorder = _get(theme, 'room.message.outgoingBorder', undefined);
        var incomingBorder = _get(theme, 'room.message.incomingBorder', undefined);
        return showBorder ?
            isOutgoing ?
            outgoingBorder :
            incomingBorder :
            undefined;
    };
    MessageEntry.prototype.render = function() {
        var _a, _b;
        var _this = this;
        var _c;
        var _d = this.props,
            children = _d.children,
            position = _d.position,
            groupPosition = _d.groupPosition,
            theme = _d.theme,
            wrapWithBubble = _d.wrapWithBubble,
            appMode = _d.appMode,
            title = _d.title,
            separateTitle = _d.separateTitle,
            senderUserId = _d.senderUserId,
            sendersData = _d.sendersData,
            rawMessage = _d.rawMessage,
            onSendAgain = _d.onSendAgain,
            messageDisplayOption = _d.messageDisplayOption,
            useAvatarTooltip = _d.useAvatarTooltip,
            emphasisBubble = _d.emphasisBubble,
            whiteBubble = _d.whiteBubble,
            isLastMessage = _d.isLastMessage,
            getIndicationData = _d.getIndicationData,
            compactView = _d.compactView,
            isFullWidth = _d.isFullWidth;
        var textColor = _get(theme, 'room.message.textColor');
        var background = _get(theme, 'room.message.background');
        var outgoingBackgroundColor = _get(theme, 'room.message.outgoingBackground', background);
        var outgoingTextColor = _get(theme, 'room.message.outgoingTextColor', textColor);
        var incomingBackgroundColor = _get(theme, 'room.message.incomingBackground', undefined);
        var incomingTextColor = _get(theme, 'room.message.incomingTextColor', textColor);
        var outgoingBoxShadow = _get(theme, 'room.message.outgoingBoxShadow', undefined);
        var incomingBoxShadow = _get(theme, 'room.message.incomingBoxShadow', undefined);
        var style = {};
        var wrapperStyle = {};
        if (position === Outgoing) {
            style.background = outgoingBackgroundColor;
            style.color = outgoingTextColor;
        } else {
            style.background = incomingBackgroundColor;
            style.color = incomingTextColor;
        }
        var borderRadius = _get(theme, 'room.message.borderRadius', 12);
        var innerBorderRadius = Math.min(4, borderRadius);
        var fontFamily = _get(theme, 'room.fontFamily');
        var fontSize = _get(theme, 'room.fontSize');
        var messageMinWidth = _get(theme, 'room.message.minWidth');
        var minWidthStyle = messageMinWidth ? {
            minWidth: messageMinWidth
        } : {};
        var messageMaxWidth = _get(theme, 'room.message.maxWidth');
        var maxWidthStyle = messageMinWidth ? {
            maxWidth: messageMaxWidth
        } : {};
        style.minWidth = messageMinWidth;
        style.maxWidth = messageMaxWidth;
        if (isFullWidth) {
            style.maxWidth = 'unset';
            wrapperStyle.maxWidth = messageMaxWidth;
            wrapperStyle.flex = 1;
        }
        var isFirstInGroup = groupPosition === 'start' ||
            groupPosition === 'single' ||
            groupPosition === undefined;
        var isEndInGroup = groupPosition === 'end' || groupPosition === 'single';
        var place = positionToClass[position];
        var isOutgoing = position === Outgoing;
        var isIncoming = position === Incoming;
        var isStandardTemplateV2 = (rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.messageType) === Constants.MessageTypes.Templates.Standard &&
            ((_c = rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.templateData) === null || _c === void 0 ? void 0 : _c.orientation) ===
            Constants.MessageOrientation.Portrait &&
            !this.isFullApp();
        var borderStyle = {
            border: this.getMessageBorder(),
            boxShadow: isOutgoing ? outgoingBoxShadow : incomingBoxShadow,
            borderTopRightRadius: place !== 'right' ||
                (isOutgoing && isFirstInGroup) ||
                isStandardTemplateV2 ?
                borderRadius :
                innerBorderRadius,
            borderTopLeftRadius: place !== 'left' ||
                (isOutgoing && isFirstInGroup) ||
                isStandardTemplateV2 ?
                borderRadius :
                innerBorderRadius,
            borderBottomRightRadius: place !== 'right' || isEndInGroup || isStandardTemplateV2 ?
                borderRadius :
                innerBorderRadius,
            borderBottomLeftRadius: place !== 'left' || isEndInGroup || isStandardTemplateV2 ?
                borderRadius :
                innerBorderRadius,
        };
        var hasSenderData = !!(sendersData && sendersData.length);
        var hasSendersOrMessage = hasSenderData || rawMessage;
        var shouldShowAvatarInGroup = function() {
            var shouldShowOutgoingAvatar = (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.avatarOption) === AvatarConfig.OUTGOING ||
                (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.avatarOption) === AvatarConfig.BOTH;
            var shouldShowIncomingAvatar = (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.avatarOption) === AvatarConfig.INCOMING ||
                (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.avatarOption) === AvatarConfig.BOTH;
            var showAvatarByMessageDirection = (isOutgoing && shouldShowOutgoingAvatar) ||
                (isIncoming && shouldShowIncomingAvatar);
            return hasSendersOrMessage && showAvatarByMessageDirection;
        };
        var renderAvatar = function() {
            var shouldShowAvatar = shouldShowAvatarInGroup() && isFirstInGroup;
            if (!shouldShowAvatar) {
                return;
            }
            var side = isOutgoing ? styles.right : styles.left;
            var sender = sendersData === null || sendersData === void 0 ? void 0 : sendersData.filter(function(senderData) {
                return senderData.id === senderUserId;
            }).pop();
            var senderPicture = sender ?
                sender.profileImage :
                _get(rawMessage, 'senderDisplayData.image.url', '');
            var senderName = sender ?
                sender.userName :
                _get(rawMessage, 'senderDisplayData.name', '');
            var avatarName = title || senderName;
            var avatar = (React.createElement("div", {
                    className: styles.authorAvatar + " " + side,
                    "data-hook": "author-avatar"
                },
                React.createElement("span", {
                    className: styles.srOnly
                }, avatarName),
                React.createElement("div", {
                        "aria-hidden": true
                    },
                    React.createElement(AvatarWrapper, {
                        dataHook: "message-entry-avatar",
                        name: avatarName,
                        size: _this.isFullApp() ? APP_AVATAR_SIZE_WSR : WIDGET_AVATAR_SIZE_WSR,
                        imgProps: {
                            src: senderPicture
                        }
                    }))));
            if (useAvatarTooltip && avatarName) {
                return (React.createElement(Tooltip, {
                    content: avatarName,
                    dataHook: 'author-avatar-tooltip'
                }, avatar));
            }
            return avatar;
        };
        var useMessageColors = _get(theme, 'room.message.title.useMessageColors');
        var inheritFont = _get(theme, 'room.message.title.inheritFont', true);
        var titleFont = inheritFont ? fontFamily : undefined;
        var titleColor = this.props.isGroupChat ?
            getPaletteColorByString(senderUserId ? senderUserId : '') :
            (isIncoming && useMessageColors && getRgbA(incomingTextColor, 0.9)) ||
            (isOutgoing && useMessageColors && getRgbA(outgoingTextColor, 0.9)) ||
            getRgbA(textColor !== null && textColor !== void 0 ? textColor : '#000000', 0.7);
        var renderSeparatedTitle = function() {
            var shouldShowTitle = shouldShowTitleInGroup() && isFirstInGroup;
            if (!title || shouldShowTitle === false) {
                return;
            }
            var separateTitleColor = _this.props.isGroupChat ?
                titleColor :
                getRgbA('#000000', 0.7);
            return (React.createElement("div", {
                    className: styles.separateTitle,
                    "data-hook": "separate-title"
                },
                React.createElement("div", {
                    className: styles.title,
                    "data-hook": "title",
                    style: {
                        fontFamily: titleFont,
                        fontSize: fontSize,
                        color: separateTitleColor,
                    }
                }, title)));
        };
        var shouldShowTitleInGroup = function() {
            var shouldShowOutgoingTitle = (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.titleOption) === TitleConfig.OUTGOING ||
                (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.titleOption) === TitleConfig.BOTH;
            var shouldShowIncomingTitle = (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.titleOption) === TitleConfig.INCOMING ||
                (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.titleOption) === TitleConfig.BOTH;
            var showTitleByMessageDirection = (isOutgoing && shouldShowOutgoingTitle) ||
                (isIncoming && shouldShowIncomingTitle);
            return hasSendersOrMessage && showTitleByMessageDirection;
        };
        var renderSubject = function() {
            if (_this.isImage() ||
                _this.isFile() ||
                !chatSdk.isExperimentOn('specs.chat.emailSubjectLineMobileSide') ||
                !_this.isFullApp() ||
                !(rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.title)) {
                return null;
            }
            return (React.createElement("div", {
                    "data-hook": "message-subject-wrapper",
                    className: styles.subjectWrapper
                },
                React.createElement("div", {
                    className: styles.subject,
                    "data-hook": "message-subject-text"
                }, rawMessage === null || rawMessage === void 0 ? void 0 : rawMessage.title)));
        };
        var renderTitle = function() {
            var _a;
            var shouldShowTitle = shouldShowTitleInGroup() && isFirstInGroup;
            var titleLook = _get(theme, 'room.message.title.look');
            if (!title || shouldShowTitle === false) {
                return;
            }
            return (React.createElement("div", {
                className: classNames((_a = {},
                    _a[styles.title] = true,
                    _a[styles[titleLook]] = true,
                    _a)),
                "data-hook": "title",
                style: {
                    fontFamily: titleFont,
                    fontSize: fontSize,
                    color: titleColor,
                }
            }, title));
        };
        var noAvatarPadding = shouldShowAvatarInGroup() && !isFirstInGroup ?
            styles.noAvatarPadding :
            '';
        var bothAvatarsPadding = this.isFullApp() &&
            (messageDisplayOption === null || messageDisplayOption === void 0 ? void 0 : messageDisplayOption.avatarOption) === AvatarConfig.BOTH ?
            styles.bothAvatarsPadding :
            '';
        var bubbleClasses = classNames(styles.bubble, (_a = {},
            _a[styles.fullApp] = this.isFullApp(),
            _a[styles.emphasisBubble] = emphasisBubble,
            _a[styles.whiteBubble] = whiteBubble,
            _a[styles.hideOverflow] = !chatSdk.isExperimentOn(Experiments.HideBlackOnBlackBorder),
            _a));
        var bubbleWrapperClasses = classNames((_b = {},
            _b[styles.bubbleWrapper] = true,
            _b[styles.emphasisBubble] = emphasisBubble,
            _b[styles.imageBubble] = this.isImage(),
            _b[styles.standardTemplateV2Bubble] = isStandardTemplateV2,
            _b[styles.fullWidth] = !!isFullWidth,
            _b));
        var ariaProps = {};
        if (position === Outgoing) {
            ariaProps['aria-live'] = 'off';
        }
        return (React.createElement("div", {
                "data-hook": "chat-message-wrapper"
            },
            React.createElement("div", __assign({}, ariaProps, {
                    "data-hook": "chat-message",
                    className: styles.message + " " + styles[positionToClass[position]] + " " + styles[appMode] + " " + noAvatarPadding + " " + bothAvatarsPadding,
                    "data-message-position": positionToClass[position]
                }),
                renderAvatar(),
                wrapWithBubble ? (React.createElement(WithMessageIndications, {
                        rawMessage: rawMessage,
                        fullWidth: !!isFullWidth,
                        position: position,
                        isLastMessage: isLastMessage,
                        onSendAgain: onSendAgain,
                        onClickOnDrillInMessageIndications: this.onClickOnDrillInMessageIndications,
                        getIndicationData: getIndicationData,
                        compactView: compactView
                    },
                    separateTitle && renderSeparatedTitle(),
                    React.createElement("div", {
                            "data-hook": "bubble-wrapper",
                            className: bubbleWrapperClasses,
                            style: __assign(__assign(__assign(__assign({}, borderStyle), minWidthStyle), maxWidthStyle), wrapperStyle)
                        },
                        React.createElement("div", {
                                "data-hook": "bubble",
                                style: style,
                                className: bubbleClasses
                            }, !separateTitle && renderTitle(),
                            renderSubject(),
                            children,
                            this.renderMessageBadgeIfNecessary())))) : (React.createElement(WithMessageIndications, {
                    fullWidth: !!isFullWidth,
                    rawMessage: rawMessage,
                    position: position,
                    isLastMessage: isLastMessage,
                    onSendAgain: onSendAgain,
                    onClickOnDrillInMessageIndications: this.onClickOnDrillInMessageIndications
                }, children)))));
    };
    MessageEntry.defaultProps = {
        wrapWithBubble: true,
        messageDisplayOption: {
            avatarOption: AvatarConfig.OUTGOING,
            titleOption: TitleConfig.NONE,
        },
        useAvatarTooltip: false,
        separateTitle: true,
    };
    return MessageEntry;
}(Component));
export default withAppMode(withTheme(translate()(MessageEntry)));
//# sourceMappingURL=MessageEntry.js.map