'use strict';

var _require = require('./utils/isPromise'),
    isPromise = _require.isPromise;

var _require2 = require('./utils/either'),
    sequence = _require2.sequence,
    try_ = _require2.try_;

var createTransition = require('./utils/transition');

var _require3 = require('./effects'),
    isEffect = _require3.isEffect,
    isImmediateEffect = _require3.isImmediateEffect,
    isQueuedEffect = _require3.isQueuedEffect;

var registrar = function registrar(list) {
    return function(fn) {
        list.push(fn);
        return function() {
            var index = list.indexOf(fn);
            if (index >= 0) {
                list.splice(index, 1);
            }
        };
    };
};

var createMiddleware = function createMiddleware() {
    var subscribers = [];
    var idleCallbacks = [];
    var queuePromise = Promise.resolve();

    var middleware = function middleware(store) {
        return function(next) {
            return function(action) {
                var executeEffect = function executeEffect(effect) {
                    var result = try_(function() {
                        return effect.run();
                    });
                    return result.fold(function(error) {
                        var downstreamPromise = effect.resultActionCreator ? store.dispatch(effect.resultActionCreator(true, error)) : Promise.resolve();
                        return [result, downstreamPromise];
                    }, function(value) {
                        if (isPromise(value)) {
                            var downstreamPromise = value.then(function(resolvedValue) {
                                return effect.resultActionCreator ? store.dispatch(effect.resultActionCreator(false, resolvedValue)) : Promise.resolve();
                            }, function(error) {
                                if (effect.resultActionCreator) {
                                    store.dispatch(effect.resultActionCreator(true, error)).catch(function() {});
                                }
                                throw error;
                            });
                            return [result, downstreamPromise];
                        } else {
                            var _downstreamPromise = effect.resultActionCreator ? store.dispatch(effect.resultActionCreator(false, value)) : Promise.resolve();
                            return [result, _downstreamPromise];
                        }
                    });
                };

                var runImmediateEffects = function runImmediateEffects(effects) {
                    var immediateEffects = effects.filter(isImmediateEffect);
                    var promiseTuples = immediateEffects.map(executeEffect);
                    promiseTuples.map(function(tuple) {
                        return tuple[0];
                    }).map(function(result) {
                        return result.fold(function(error) {
                            throw error;
                        }, function(value) {
                            return value;
                        });
                    });
                    promiseTuples.map(function(tuple) {
                        return tuple[1];
                    }).map(function(downstreamPromise) {
                        return downstreamPromise.catch(function() {});
                    });
                    return effects.filter(isQueuedEffect);
                };

                var executeQueuedEffects = function executeQueuedEffects(resolve, reject) {
                    return function(effects) {
                        if (effects.length > 0) {
                            var promiseTuples = effects.filter(isQueuedEffect).map(executeEffect);
                            Promise.all(promiseTuples.map(function(tuple) {
                                return tuple[1];
                            })).then(function() {
                                return resolve();
                            }, reject);

                            return Promise.all(promiseTuples.map(function(tuple) {
                                return tuple[0];
                            }).map(function(result) {
                                return result.fold(function(error) {
                                    return Promise.reject(error);
                                }, function(value) {
                                    return value;
                                });
                            })).catch(reject);
                        } else {
                            resolve();
                            return Promise.resolve();
                        }
                    };
                };

                var scheduleExecution = function scheduleExecution() {
                    var trigger = undefined;
                    var gate = new Promise(function(resolve) {
                        return trigger = resolve;
                    });
                    var promise = new Promise(function(resolve, reject) {
                        var p = queuePromise = queuePromise.then(function() {
                            return gate;
                        }).then(executeQueuedEffects(resolve, reject), reject).catch(reject).then(function() {
                            if (p === queuePromise) {
                                idleCallbacks.slice().forEach(function(cb) {
                                    return cb();
                                });
                            }
                        });
                    });

                    return {
                        promise: promise,
                        trigger: trigger
                    };
                };

                var queueAndRunEffects = function queueAndRunEffects(effects) {
                    var _scheduleExecution = scheduleExecution(),
                        promise = _scheduleExecution.promise,
                        trigger = _scheduleExecution.trigger;

                    return try_(function() {
                        return runImmediateEffects(effects);
                    }).fold(function(e) {
                        trigger([]);
                        throw e;
                    }, function(effects) {
                        trigger(effects);
                        return promise;
                    });
                };

                var from = store.getState();
                var result = next(action);
                var to = store.getState();

                if (from !== to) {
                    var transition = createTransition(from, to);
                    var issuedEffects = sequence(subscribers.slice().map(function(subscriber) {
                        return try_(function() {
                            return subscriber(transition) || [];
                        });
                    }));

                    return issuedEffects.fold(function(e) {
                        throw e;
                    }, function(effects) {
                        return queueAndRunEffects(effects.filter(isEffect));
                    });
                }

                return Promise.resolve(result);
            };
        };
    };

    var subscribe = registrar(subscribers);
    var onIdle = registrar(idleCallbacks);

    return {
        middleware: middleware,
        subscribe: subscribe,
        onIdle: onIdle
    };
};

module.exports = createMiddleware;