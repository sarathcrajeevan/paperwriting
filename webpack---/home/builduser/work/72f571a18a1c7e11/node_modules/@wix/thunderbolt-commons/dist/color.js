"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateGradient = exports.isValidColor = exports.extractRGBA = exports.getColorFromCssStyle = exports.isHexValue = exports.isRgbValues = exports.isThemeColor = exports.isGreyscale = exports.formatColor = exports.getColorClass = exports.getColorAlpha = exports.getHexColor = exports.getSplitRgbValuesStringWithoutAlpha = exports.getSplitRgbValuesString = exports.getFromColorMap = exports.splitColor = exports.getRGBAColorString = exports.extractThemeColor = exports.brighten = exports.isColor = void 0;
var tslib_1 = require("tslib");
var color_1 = (0, tslib_1.__importDefault)(require("color"));
var css_gradient_generator_1 = require("@wix/css-gradient-generator");
var isColor = function(val) {
    return val ? /(^#([a-f\d]{3}){1,2}$)|(^rgba?\(\d+(,\d+){2,3}(\.\d+)?\)$)/i.test(val.replace(/\s/g, '')) : false;
};
exports.isColor = isColor;
var isRgbValues = function(val) {
    return (val ? /^\d+(,\d+){2,3}(\.\d+)?$/.test(val.replace(/\s/g, '')) : false);
};
exports.isRgbValues = isRgbValues;
var isHexValue = function(val) {
    return (val ? /(^#([a-f\d]{3}){1,2}$)/i.test(val.replace(/\s/g, '')) : false);
};
exports.isHexValue = isHexValue;
var rgbToHexString = function(rgb) {
    return "#" + rgb
        .map(function(channel) {
            var hex = channel.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        })
        .join('');
};
var getColor = function(color) {
    if ((0, exports.isColor)(color)) {
        return (0, color_1.default)(color);
    }
    if (isRgbValues(color)) {
        return (0, color_1.default)("rgba(" + color + ")");
    }
    if (color === 'transparent') {
        return color_1.default.rgb(0, 0, 0, 0);
    }
    return null;
};
var isThemeColor = function(color) {
    return /^color_\d+$/.test(color);
};
exports.isThemeColor = isThemeColor;
var brighten = function(colorString, brightnessModifier) {
    if (brightnessModifier === void 0) {
        brightnessModifier = 1;
    }
    var color = getColor(colorString);
    if (!color) {
        return null;
    }
    var hsvColor = color.hsv();
    return hsvColor
        .value(hsvColor.value() * brightnessModifier)
        .rgb()
        .string();
};
exports.brighten = brighten;
var getRGBAColorString = function(color, colorOpacity) {
    if (colorOpacity === void 0) {
        colorOpacity = 1;
    }
    try {
        if (colorOpacity === 'none') {
            return (0, color_1.default)(fixColor(color)).string();
        }
        return (0, color_1.default)(fixColor(color)).alpha(colorOpacity).string();
    } catch (e) {
        return color;
    }
};
exports.getRGBAColorString = getRGBAColorString;
var splitColor = function(rgbString) {
    return (0, color_1.default)(rgbString).array().join(',');
};
exports.splitColor = splitColor;
/**
 * Returns rgb values string from a hex color string input (i.e 255,255,255), null if value given is not a hex color
 * @param value a string value that might be a color
 */
var getSplitRgbValuesString = function(value) {
    var color = getColor(value);
    if (!color) {
        return null;
    }
    return color.rgb().array().join(',');
};
exports.getSplitRgbValuesString = getSplitRgbValuesString;
/**
 * Returns an RGB values from rgb or rgba expressions as a string.
 * If there is an opacity value (alpha) in rgba expression it will be ignored.
 * @param value a string that might be one of the expressions: rgb(r, g, b), or rgba(r, g, b, a)
 */
var getSplitRgbValuesStringWithoutAlpha = function(value) {
    var color = getColor(value);
    if (!color) {
        return null;
    }
    var _a = color.object(),
        r = _a.r,
        g = _a.g,
        b = _a.b;
    return r + "," + g + "," + b;
};
exports.getSplitRgbValuesStringWithoutAlpha = getSplitRgbValuesStringWithoutAlpha;
var getColorAlpha = function(value) {
    var color = getColor(value);
    if (!color) {
        return null;
    }
    return color.alpha();
};
exports.getColorAlpha = getColorAlpha;
/**
 * Given theme color string e.g {color_1} / [color_1] extracts the underlying color - color_1
 * @param str theme color
 */
var extractThemeColor = function(str) {
    return str.replace(new RegExp('[\\[\\]{}]', 'g'), '');
};
exports.extractThemeColor = extractThemeColor;
var getFromColorMap = function(rawColor, colorsMap) {
    if (colorsMap === void 0) {
        colorsMap = [];
    }
    var _a = (0, tslib_1.__read)(extractThemeColor(rawColor).split('_'), 2),
        themeColorIndex = _a[1];
    var i = parseInt(themeColorIndex, 10);
    return isNaN(i) ? rawColor : colorsMap[i];
};
exports.getFromColorMap = getFromColorMap;
var isGreyscale = function(colorObj) {
    return colorObj.red() === colorObj.green() && colorObj.red() === colorObj.blue() && colorObj.red() !== 255;
};
exports.isGreyscale = isGreyscale;
var getHexColor = function(rgbAsString) {
    var color = getColor(rgbAsString);
    return color && color.hex().toString();
};
exports.getHexColor = getHexColor;
var getColorClass = function(className) {
    var findColorClass = /(color_\d+)/;
    var colorClass = findColorClass.exec(className);
    return colorClass && colorClass[1];
};
exports.getColorClass = getColorClass;
var fixColor = function(color) {
    if ((0, exports.isColor)(color)) {
        return color;
    }
    if (typeof color === 'undefined') {
        return color;
    }
    if ((0, exports.isColor)("rgba(" + color + ")")) {
        return "rgba(" + color + ")";
    }
    if ((0, exports.isColor)("rgb(" + color + ")")) {
        return "rgb(" + color + ")";
    }
    return color.replace(';', '');
};
var formatColor = function(value, alpha) {
    var fixedColor = fixColor(value);
    var color = new color_1.default(fixedColor).alpha(Number(alpha));
    var formattedRgbColor = color.rgb().toString().replace(/ /g, '');
    return Number(alpha) !== 1 ?
        formattedRgbColor :
        formattedRgbColor.replace(/^rgb/, 'rgba').replace(')', "," + color.alpha() + ")");
};
exports.formatColor = formatColor;
var getColorFromCssStyle = function(value) {
    var red = value.red,
        green = value.green,
        blue = value.blue,
        alpha = value.alpha;
    var color = new color_1.default(rgbToHexString([red, green, blue]));
    return formatColor(color.toString(), alpha);
};
exports.getColorFromCssStyle = getColorFromCssStyle;
var extractRGBA = function(value) {
    var rgbaRe = /rgba\([^)]+\)/;
    var result = value.match(rgbaRe);
    if (result && result[0]) {
        return result[0];
    }
    return '';
};
exports.extractRGBA = extractRGBA;
var isValidColor = function(color) {
    return (0, exports.isColor)(color) || isRgbValues(color) || isHexValue(color) || isThemeColor(color);
};
exports.isValidColor = isValidColor;
var generateGradient = function(colorLayers, alpha, colorMap) {
    return (0, css_gradient_generator_1.generate)(colorLayers, {
        alpha: alpha,
        resolveColor: function(color) {
            return getFromColorMap(color, colorMap);
        }
    });
};
exports.generateGradient = generateGradient;
//# sourceMappingURL=color.js.map