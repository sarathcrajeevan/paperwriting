"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getProperties = exports.interpolate = void 0;
var tslib_1 = require("tslib");
var svgFiltersParts_1 = require("./svgFiltersParts");

function attrToString(key, value) {
    return value || value === 0 ? key + "=\"" + value + "\"" : '';
}

function attrsObjectToString(attrs) {
    return Object.keys(attrs)
        .map(function(key) {
            return attrToString(key, attrs[key]);
        })
        .join(' ');
}

function filterWrapperTemplate(_a) {
    var id = _a.id,
        content = _a.content,
        _b = _a.attrs,
        attrs = _b === void 0 ? {} : _b;
    // the redundant identity <feComponentTransfer/> in start and end
    // are for fixing old Webkit bug that caused it to ignore color-interpolation-filters="sRGB"
    return "<filter id=\"" + id + "\" color-interpolation-filters=\"sRGB\" " + attrsObjectToString(attrs) + ">\n    <feComponentTransfer result=\"srcRGB\"/>\n    " + content + "\n    <feComponentTransfer/>\n</filter>";
}

function identity(_a) {
    var inAttr = _a.inAttr;
    return "<feColorMatrix " + attrToString('in', inAttr) + "/>";
}

function contrast(_a) {
    var value = _a.value;
    return "<feComponentTransfer>" + (0, svgFiltersParts_1.getContrast)(value) + "</feComponentTransfer>";
}

function brightness(_a) {
    var value = _a.value,
        result = _a.result;
    return "<feComponentTransfer " + attrToString('result', result) + ">" + (0, svgFiltersParts_1.getBrightness)(value) + "</feComponentTransfer>";
}

function saturation(_a) {
    var value = _a.value,
        inAttr = _a.inAttr,
        result = _a.result;
    return "<feColorMatrix type=\"saturate\" values=\"" + value + "\" " + (inAttr ? "in=\"" + inAttr + "\"" : '') + (result ? "result=\"" + result + "\"" : '') + "/>";
}

function sepia(_a) {
    var value = _a.value;
    return "<feColorMatrix type=\"matrix\" values=\"" + (0, svgFiltersParts_1.getSepia)(value) + "\"/>";
}

function hue(_a) {
    var value = _a.value;
    return "<feColorMatrix type=\"hueRotate\" values=\"" + value + "\"/>";
}

function color(_a) {
    var value = _a.value,
        inAttr = _a.inAttr,
        result = _a.result;
    var hexColor = typeof value === 'string' ? value : value.color;
    var opacity = typeof value === 'object' && typeof value.opacity !== 'undefined' ? value.opacity : 1;
    return "<feColorMatrix type=\"matrix\" values=\"" + (0, svgFiltersParts_1.getColor)((0, svgFiltersParts_1.hex2RgbNorm)(hexColor), opacity) + "\" " + (inAttr ? "in=\"" + inAttr + "\"" : '') + (result ? "result=\"" + result + "\"" : '') + "/>";
}

function tint(_a) {
    var value = _a.value;
    return "<feColorMatrix type=\"matrix\" values=\"" + (0, svgFiltersParts_1.getTint)((0, svgFiltersParts_1.hex2RgbNorm)(value)) + "\"/>";
}

function blur(_a) {
    var value = _a.value,
        inAttr = _a.inAttr;
    return "<feGaussianBlur stdDeviation=\"" + value + "\" " + (inAttr ? "in=\"" + inAttr + "\"" : '') + "/>";
}

function alpha(_a) {
    var value = _a.value,
        inAttr = _a.inAttr,
        result = _a.result;
    return "<feComponentTransfer " + attrToString('in', inAttr) + " " + attrToString('result', result) + ">" + (0, svgFiltersParts_1.getAlpha)(value) + "</feComponentTransfer>";
}

function offset(_a) {
    var value = _a.value,
        inAttr = _a.inAttr,
        result = _a.result;
    return "<feOffset dx=\"" + value.x + "\" dy=\"" + value.y + "\" " + (inAttr ? "in=\"" + inAttr + "\"" : '') + (result ? "result=\"" + result + "\"" : '') + "/>";
}

function blend(_a) {
    var value = _a.value,
        inAttr = _a.inAttr,
        in2Attr = _a.in2Attr,
        result = _a.result;
    return "<feBlend mode=\"" + value + "\" in=\"" + inAttr + "\" in2=\"" + in2Attr + "\" " + attrToString('result', result) + "/>";
}

function composite(_a) {
    var value = _a.value,
        inAttr = _a.inAttr,
        in2Attr = _a.in2Attr,
        result = _a.result;
    return "<feComposite operator=\"" + value + "\" in=\"" + inAttr + "\" in2=\"" + in2Attr + "\" " + attrToString('result', result) + "/>";
}

function duotone(_a) {
    var _b = _a.value,
        dark = _b.dark,
        light = _b.light,
        inAttr = _a.inAttr,
        result = _a.result;
    return saturation({
        value: 0
    }) + "\n<feColorMatrix type=\"matrix\" values=\"" + (0, svgFiltersParts_1.getDoutone)((0, svgFiltersParts_1.hex2RgbNorm)(light), (0, svgFiltersParts_1.hex2RgbNorm)(dark)) + "\" " + (inAttr ? "in=\"" + inAttr + "\"" : '') + (result ? "result=\"" + result + "\"" : '') + "/>";
}

function luma(_a) {
    var _b = _a.value,
        dark = _b.dark,
        light = _b.light,
        result = _a.result;
    return "<feColorMatrix type=\"matrix\" values=\"" + (0, svgFiltersParts_1.getLumaMatrix)(light, dark) + "\" " + (result ? "result=\"" + result + "\"" : '') + "/>";
}

function shadow(_a) {
    var _b = _a.value,
        blurRadius = _b.blurRadius,
        mergeGraphic = _b.mergeGraphic,
        rest = (0, tslib_1.__rest)(_b, ["blurRadius", "mergeGraphic"]);
    return blur({
        value: blurRadius,
        inAttr: 'SourceAlpha'
    }) + "\n" + offset({
        value: rest
    }) + "\n" + color({
        value: rest
    }) + "\n" + (mergeGraphic ?
        "<feMerge>\n    <feMergeNode/>\n    <feMergeNode in=\"SourceGraphic\"/>\n</feMerge>" :
        '');
}
var filterComponentTempaltesWithNumber = {
    blur: blur,
    saturation: saturation,
    contrast: contrast,
    brightness: brightness,
    sepia: sepia,
    hue: hue,
    alpha: alpha,
};
var filterComponentTempaltesWithString = {
    blend: blend,
    color: color,
    composite: composite,
    tint: tint,
};
var filterComponentTempaltes = {
    duotone: duotone,
    shadow: shadow,
    color: color,
    offset: offset,
};

function getFilterValue(key, value, overrides) {
    if (key === 'duotone') {
        return {
            light: ('duotoneLight' in overrides && overrides.duotoneLight) || value.light,
            dark: ('duotoneDark' in overrides && overrides.duotoneDark) || value.dark,
        };
    } else if (key in overrides) {
        return overrides[key];
    }
    return value;
}

function interpolate(id, filterDefinition, overrides, attrs) {
    var content = filterDefinition
        .map(function(effect) {
            var key = effect.key,
                value = effect.value;
            var filterValue = getFilterValue(key, value, overrides);
            var arg = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, effect), {
                value: filterValue
            });
            if (typeof filterValue === 'number') {
                return filterComponentTempaltesWithNumber[key](arg);
            } else if (typeof filterValue === 'string') {
                return filterComponentTempaltesWithString[key](arg);
            } else if (key === 'luma') {
                return luma(arg);
            } else if (key === 'identity') {
                return identity(arg);
            } else {
                return filterComponentTempaltes[key](arg);
            }
        })
        .join('\n');
    return filterWrapperTemplate({
        id: id,
        content: content,
        attrs: attrs
    });
}
exports.interpolate = interpolate;

function getProperties(filterDefinition, overrides) {
    return filterDefinition.map(function(effect) {
        var _a;
        var key = effect.key,
            value = effect.value;
        return _a = {}, _a[key] = getFilterValue(key, value, overrides), _a;
    });
}
exports.getProperties = getProperties;
//# sourceMappingURL=svgFiltersTemplates.js.map