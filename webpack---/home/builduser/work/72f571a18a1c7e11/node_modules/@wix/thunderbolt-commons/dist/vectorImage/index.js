"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildSvgUrlFactory = exports.getCSSStrokeAdjustments = exports.getCSSDropShadow = exports.encodeSVG = exports.getSvgContentForMask = exports.replaceSVGMaskAttributes = exports.getScaledSvgViewBox = exports.getFilter = exports.createReactSvgImageWithMask = exports.removeWidthAndHeight = exports.parseSvgString = exports.transformVectorImage = exports.getFontFamilyFontsFromSvg = void 0;
var tslib_1 = require("tslib");
var color_1 = require("../color");
var svgFilters_1 = require("./svgFilters");
Object.defineProperty(exports, "getFilter", {
    enumerable: true,
    get: function() {
        return svgFilters_1.getFilter;
    }
});
var svgParser_1 = require("./svgParser");
Object.defineProperty(exports, "parseSvgString", {
    enumerable: true,
    get: function() {
        return svgParser_1.parseSvgString;
    }
});
var color_2 = (0, tslib_1.__importDefault)(require("color"));
var hoverBoxUtils_1 = require("../hoverBoxUtils");
var pickBy = function(source, predicate) {
    return Object.entries(source).reduce(function(acc, _a) {
        var _b = (0, tslib_1.__read)(_a, 2),
            key = _b[0],
            value = _b[1];
        if (predicate(value, key)) {
            acc[key] = value;
        }
        return acc;
    }, {});
};
var viewBoxMatcher = /viewBox="([^"]*)"/i;
var svgWidthMatcher = /(?:<svg[^>]*)\s(width="[^"]*")/i;
var svgHeightMatcher = /(?:<svg[^>]*)\s(height="[^"]*")/i;
var svgTagMatcher = /(<svg[^>]*)(>)/;
var fillAttributeMatcher = /fill="(.*?)"/gi;
var styleAttributeMatcher = /style="([^"]*)"/i;
var styleTransformMatcher = /transform:([^;]*)/i;
var SVG_TYPES = {
    SHAPE: 'shape',
    TINT: 'tint',
    COLOR: 'color',
    UGC: 'ugc',
};

function replaceSVGMaskAttributes(svgString, svgId) {
    if (!svgString) {
        return svgString;
    }
    var svgTagMatch = svgString.match(/<svg[^>]*>/);
    if (svgTagMatch) {
        var svgTag = svgTagMatch[0];
        var idMatch = svgTag.match(/id="[-\w]+"/);
        var aspectRatioMatch = svgTag.match(/preserveAspectRatio="[-\w\s]+"/);
        if (aspectRatioMatch) {
            svgTag = svgTag.replace(aspectRatioMatch[0], 'preserveAspectRatio="none"');
        } else {
            svgTag = svgTag.replace('<svg ', '<svg preserveAspectRatio="none" ');
        }
        if (idMatch) {
            svgTag = svgTag.replace(idMatch[0], "id=\"" + svgId + "\"");
        } else {
            svgTag = svgTag.replace('<svg ', "<svg id=\"" + svgId + "\" ");
        }
        svgString = svgString.replace(svgTagMatch[0], svgTag);
    }
    return svgString;
}
exports.replaceSVGMaskAttributes = replaceSVGMaskAttributes;
var symbols = /[\r\n%#()<>?[\\\]^`{|}]/g;
/**
 * Returns a data URI SVG encoded for CSS <url> value
 */
function encodeSVG(svg) {
    var escaped = svg
        .replace(/"/g, "'") // Use single quotes instead of double to avoid encoding.
        .replace(/>\s+</g, '><') // trim
        .replace(/\s{2,}/g, ' ') // trim
        .replace(symbols, encodeURIComponent); // encode symbols
    return "url(\"data:image/svg+xml," + escaped + "\")";
}
exports.encodeSVG = encodeSVG;

function transformToTintColors(svgString, resolvedColor) {
    var baseColor = (0, color_2.default)(resolvedColor);
    return svgString.replace(fillAttributeMatcher, function(__, colorToTint) {
        if (colorToTint === 'none') {
            return 'fill="none"';
        }
        var colorObj = (0, color_2.default)(colorToTint);
        if ((0, color_1.isGreyscale)(colorObj)) {
            var tint = 1 - (255 - colorObj.red()) / 255; // eslint-disable-line no-mixed-operators
            var rTint = Math.floor(baseColor.red() + (255 - baseColor.red()) * tint); // eslint-disable-line no-mixed-operators
            var gTint = Math.floor(baseColor.green() + (255 - baseColor.green()) * tint); // eslint-disable-line no-mixed-operators
            var bTint = Math.floor(baseColor.blue() + (255 - baseColor.blue()) * tint); // eslint-disable-line no-mixed-operators
            var tintedColor = (0, color_2.default)({
                r: rTint,
                g: gTint,
                b: bTint
            });
            // return tinted color
            return "fill=\"" + tintedColor.hex().toString() + "\"";
        }
        // no change, return original svg color
        return "fill=\"" + colorToTint + "\"";
    });
}

function removeWidthAndHeight(svgString) {
    if (svgString) {
        var widthMatch = svgString.match(svgWidthMatcher);
        var heightMatch = svgString.match(svgHeightMatcher);
        if (widthMatch && widthMatch.length > 1) {
            svgString = svgString.replace(widthMatch[1], 'width="100%"');
        }
        if (heightMatch && heightMatch.length > 1) {
            svgString = svgString.replace(heightMatch[1], 'height="100%"');
        }
    }
    return svgString;
}
exports.removeWidthAndHeight = removeWidthAndHeight;

function getNoAltA11yAttributes(asString) {
    if (asString === void 0) {
        asString = false;
    }
    var feats = {
        role: 'presentation',
        'aria-hidden': 'true'
    };
    return asString ?
        Object.entries(feats)
        .map(function(_a) {
            var _b = (0, tslib_1.__read)(_a, 2),
                key = _b[0],
                value = _b[1];
            return key + "=" + value;
        })
        .join(' ') :
        feats;
}

function addA11yAttributes(svgString, compId, altText) {
    var a11yFeatures = altText ? "role=\"img\"" : getNoAltA11yAttributes(true);
    var newSvgString = svgString.replace(svgTagMatcher, "$1 " + a11yFeatures + "$2");
    if (typeof altText === 'string') {
        var svgLabelId = compId + "-svgtitle";
        return newSvgString.replace(svgTagMatcher, "$1 aria-labelledby=\"" + svgLabelId + "\"$2<title id=\"" + svgLabelId + "\">" + altText + "</title>");
    }
    return newSvgString;
}

function getFilterRectInPixels(layout, shadow) {
    var blurRadius = shadow.blurRadius,
        x = shadow.x,
        y = shadow.y;
    // STD to pixel ~ STD value * 3 , we are multiplying by 6 for both sides
    var blurSpread = blurRadius * 6;
    var filterAttr = {
        x: Math.min(0, x) - blurSpread / 2,
        y: Math.min(0, y) - blurSpread / 2,
    };
    var res = "x=\"" + filterAttr.x + "\" y=\"" + filterAttr.y + "\"";
    if (layout != null) {
        // In bolt the width and height values are only relevant in the classic editor. In EditorX they end up as NaN
        // In order to have parity with the Bolt implementation, we leave width and height undefined,
        // We avoid NaN values because it results in console errors
        var width = layout.width + blurSpread + Math.abs(x);
        var height = layout.height + blurSpread + Math.abs(y);
        res += " width=\"" + width + "\" height=\"" + height + "\"";
    }
    return res;
}

function getShadowFilter(filterId, shadow, layout, hexColor, mergeGraphic) {
    var filterString = (0, svgFilters_1.getShadow)(filterId, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, shadow), {
        color: hexColor,
        mergeGraphic: mergeGraphic
    }));
    return filterString.replace(/<filter /, "<filter " + getFilterRectInPixels(layout, shadow) + " filterUnits=\"userSpaceOnUse\" ");
}

function getPreserveAspectRatioString(displayMode) {
    var preserveAspectRatio = displayMode !== 'stretch';
    var preserveAspectRatioString = preserveAspectRatio ? 'xMidYMid meet' : 'none';
    return {
        preserveAspectRatio: preserveAspectRatio,
        preserveAspectRatioString: preserveAspectRatioString
    };
}

function getScaledSvgViewBox(svgString, svgInfo, properties) {
    if (properties === void 0) {
        properties = {};
    }
    if (svgString) {
        var svgType = svgInfo.svgType,
            viewBox = svgInfo.viewBox,
            bbox = svgInfo.bbox;
        var preserveViewBox = properties.preserveViewBox,
            displayMode = properties.displayMode;
        var preserveAspectRatioString = getPreserveAspectRatioString(displayMode).preserveAspectRatioString;
        svgString = svgString.replace(/<svg/, "<svg preserveAspectRatio=\"" + preserveAspectRatioString + "\"");
        if (!svgString.match(viewBoxMatcher)) {
            if (svgType === SVG_TYPES.UGC && viewBox) {
                svgString = svgString.replace(/<svg/, "<svg viewBox=\"" + viewBox + "\"");
            }
            if (svgType !== SVG_TYPES.UGC && bbox) {
                svgString = svgString.replace(/<svg/, "<svg viewBox=\"" + bbox + "\"");
            }
        }
        if (svgType !== SVG_TYPES.UGC && !preserveViewBox && bbox) {
            svgString = svgString.replace(viewBoxMatcher, "viewBox=\"" + bbox + "\"");
        }
    }
    return svgString;
}
exports.getScaledSvgViewBox = getScaledSvgViewBox;

function wrapWithShadow(_a) {
    var compId = _a.compId,
        svgString = _a.svgString,
        layout = _a.layout,
        colorsMap = _a.colorsMap,
        shadow = _a.shadow,
        _b = _a.shadowOnly,
        shadowOnly = _b === void 0 ? false : _b;
    if (shadow && shadow.color) {
        var filterId = compId + "-shadow";
        var hexColor = (0, color_1.getFromColorMap)(shadow.color, colorsMap);
        var shadowFilter = getShadowFilter(filterId, shadow, layout, hexColor, !shadowOnly);
        var modifiedContent = removeWidthAndHeight(svgString);
        return "\n          <svg height=\"100%\" width=\"100%\">\n              <defs>" + shadowFilter + "</defs>\n              <g filter=\"url(#" + filterId + ")\">\n                  " + modifiedContent + "\n              </g>\n          </svg>\n      ";
    }
    return svgString;
}

function getCSSDropShadow(shadow, colorsMap) {
    if (shadow && shadow.color && shadow.opacity) {
        var hexColor = (0, color_1.getFromColorMap)(shadow.color, colorsMap);
        var opacity = Math.round(shadow.opacity * 255).toString(16);
        return "drop-shadow(" + shadow.x + "px " + shadow.y + "px " + shadow.blurRadius + "px " + hexColor + opacity.padStart(2, '0') + ")";
    }
    return '';
}
exports.getCSSDropShadow = getCSSDropShadow;

function getCSSStrokeAdjustments(strokeWidth) {
    if (strokeWidth) {
        return {
            svgCalculatedPadding: Math.floor(strokeWidth / 2) + "px " + Math.ceil(strokeWidth / 2) + "px " + Math.ceil(strokeWidth / 2) + "px " + Math.floor(strokeWidth / 2) + "px",
            svgCalculatedWidth: "calc(100% - " + strokeWidth + "px)",
            svgCalculatedHeight: "calc(100% - " + strokeWidth + "px)",
        };
    }
    return {};
}
exports.getCSSStrokeAdjustments = getCSSStrokeAdjustments;
var FLIP_DATA_TO_TRANSFORM = {
    x: 'scale(-1, 1)',
    y: 'scale(1, -1)',
    xy: 'scale(-1, -1)',
    none: '',
};

function getFlippedSVG(svgString, flip) {
    var topSvg = svgString.match(svgTagMatcher);
    var transform = FLIP_DATA_TO_TRANSFORM[flip] || '';
    if (topSvg && transform) {
        var styleMatch = topSvg[0].match(styleAttributeMatcher);
        var replacement = "$1 style=\"transform: " + transform + ";\"$2";
        if (styleMatch) {
            var transformMatch = styleMatch[1].match(styleTransformMatcher);
            if (transformMatch) {
                replacement = topSvg[0].replace(styleMatch[0], styleMatch[0].replace(transformMatch[0], "transform: " + transform + " " + transformMatch[1]));
            } else {
                replacement = topSvg[0].replace(styleMatch[0], "style=\"transform: " + transform + "; " + styleMatch[1] + "\"");
            }
        }
        return svgString.replace(svgTagMatcher, replacement);
    }
    return svgString;
}

function getSvgContentForMask(svgString, svgInfo, flip, mode, colorsMap, compId, layout, shadow) {
    var content = getScaledSvgViewBox(svgString, svgInfo, {
        displayMode: 'stretch'
    });
    // we must have the transform style inlined inside the SVG content
    var svg = getFlippedSVG(content, flip);
    if (mode === 'drop-shadow' && shadow && layout) {
        return wrapWithShadow({
            compId: compId,
            svgString: svg,
            layout: layout,
            colorsMap: colorsMap,
            shadow: shadow,
            shadowOnly: true
        });
    }
    return svg;
}
exports.getSvgContentForMask = getSvgContentForMask;

function addSvgStyleNode(svgString, defsValue) {
    if (!svgString) {
        return svgString;
    }
    return svgString.replace(/(<svg[^>]*>)/, "$1<defs><style>" + defsValue + "</style></defs>");
}
var DEFAULT_COLOR = '#242323';
var pickValidColors = function(obj) {
    return Object.keys(obj).reduce(function(result, key) {
        var colorValue = obj[key];
        if ((0, color_1.isColor)(colorValue) || (0, color_1.isThemeColor)(colorValue)) {
            result[key] = colorValue;
        }
        return result;
    }, {});
};
var transformVectorImage = function(rawSvg, _a) {
    var altText = _a.altText,
        compId = _a.compId,
        svgInfo = _a.svgInfo,
        properties = _a.properties,
        layout = _a.layout,
        shadow = _a.shadow,
        isResponsive = _a.isResponsive,
        colorsMap = _a.colorsMap,
        overrideColorsInuput = _a.overrideColors;
    var overrideColors = pickValidColors(overrideColorsInuput || {});

    function withA11y(svgString) {
        return addA11yAttributes(svgString, compId, altText);
    }

    function withScaledViewBox(svgString) {
        return getScaledSvgViewBox(svgString, svgInfo, properties);
    }

    function withShadowFilter(svgString) {
        return wrapWithShadow({
            compId: compId,
            svgString: svgString,
            layout: isResponsive ? null : layout,
            colorsMap: colorsMap,
            shadow: shadow,
        });
    }

    function withTintColors(svgString) {
        var rawColor = (overrideColors && overrideColors.color1) || DEFAULT_COLOR;
        var color = (0, color_1.getFromColorMap)(rawColor, colorsMap);
        return svgInfo.svgType === SVG_TYPES.TINT ? transformToTintColors(svgString, color) : svgString;
    }

    function withCssOverrides(svgString) {
        var shouldOverrideColors = svgInfo.svgType === SVG_TYPES.COLOR && Object.keys(overrideColors).length > 0;
        if (shouldOverrideColors) {
            var colors = Object.entries(overrideColors)
                .map(function(_a) {
                    var _b = (0, tslib_1.__read)(_a, 2),
                        colorName = _b[0],
                        rawColor = _b[1];
                    var resolvedColor = (0, color_1.getFromColorMap)(rawColor, colorsMap);
                    var index = colorName.replace('color', '');
                    return (0, hoverBoxUtils_1.compIdToCssSelector)(compId, true) + " svg [data-color=\"" + index + "\"] {fill: " + resolvedColor + ";}";
                })
                .join('\n');
            return addSvgStyleNode(svgString, colors);
        }
        return svgString;
    }
    var content = withScaledViewBox(withTintColors(withA11y(rawSvg)));
    return withCssOverrides(isResponsive ? content : withShadowFilter(content));
};
exports.transformVectorImage = transformVectorImage;
var getSvgAttributes = function(componentAttributes, compId) {
    return (0, tslib_1.__assign)({
        ref: "svg" + compId,
        key: "svg" + compId,
        id: "svg" + compId,
        version: '1.1'
    }, componentAttributes);
};
var getMaskFlipTransformAttr = function(flip, imageDimensions) {
    var width = imageDimensions.width;
    var height = imageDimensions.height;
    switch (flip) {
        case 'x':
            return {
                transform: "translate(0 " + height + ") scale(1 -1)"
            };
        case 'y':
            return {
                transform: "translate(" + width + " 0) scale(-1 1)"
            };
        case 'xy':
            return {
                transform: "translate(" + width + " " + height + ") scale(-1 -1)"
            };
        default:
            return {
                transform: null
            };
    }
};
var getSvgImageAttributes = function(filterId, maskId, displayMode) {
    var preserveAspectRatio = (displayMode && getPreserveAspectRatioString(displayMode).preserveAspectRatioString) || 'none';
    var attributes = {
        ref: 'image',
        key: 'image',
        'data-type': 'image',
        width: '100%',
        height: '100%',
        preserveAspectRatio: preserveAspectRatio,
    };
    var mask = maskId && "url(#" + maskId + ")";
    var dataSvgMask = maskId && {
        'data-svg-mask': maskId + "-svg"
    };
    var filter = filterId && "url(#" + filterId + ")";
    return pickBy(Object.assign(attributes, {
        mask: mask,
        filter: filter
    }, dataSvgMask), function(x) {
        return x;
    });
};
// TODO move this to a common place (duplicated)
function stringifyAttrs(attrs) {
    return Object.keys(attrs)
        .map(function(k) {
            return k + "=\"" + attrs[k] + "\"";
        })
        .join(' ');
}
var createElement = function(tag, attrs, children) {
    var attrsString = stringifyAttrs(attrs);
    return children ? "<" + tag + " " + attrsString + ">" + children + "</" + tag + ">" : "<" + tag + " " + attrsString + " />";
};
var getMask = function(maskId, svgId, svg, attributes) {
    var width = attributes.width;
    var height = attributes.height;
    var x = attributes.x;
    var y = attributes.y;
    var transform = attributes.transform;
    var style = attributes.style;
    var transformStr = transform ? " transform=\"" + transform + "\"" : '';
    var styleStr = style ? " style=\"" + style + "\"" : '';
    var filterId = svgId + "-bleach";
    var bleach = "<filter id=\"" + filterId + "\"><feColorMatrix type=\"matrix\"\n\t\t\tvalues=\"0 0 0 0 1\n\t\t\t\t0 0 0 0 1\n\t\t\t\t0 0 0 0 1\n\t\t\t\t0 0 0 1 0\"/></filter>";
    var filterUrl = "filter=\"url(#" + filterId + ")\"";
    return bleach + "\n\t\t\t<mask id=\"" + maskId + "\">\n\t\t\t\t<use " + filterUrl + "\n\t\t\t\tid=\"" + svgId + "-use\" xlink:href=\"#" + svgId + "\" width=\"" + width + "\" height=\"" + height + "\" x=\"" + x + "\" y=\"" + y + "\" " + transformStr + " " + styleStr + "></use>\n\t\t\t</mask>\n\t\t\t" + svg;
};
var createReactSvgImageWithMask = function(compId, imageDimensions, filterId, maskId, maskData, altText, displayMode) {
    var imageAttributes = getSvgImageAttributes(filterId, maskId, displayMode);
    var componentAttributes = (altText ?
        {
            role: 'img',
            'aria-label': altText
        } :
        getNoAltA11yAttributes(false));
    var svgImageAttributes = getSvgAttributes(componentAttributes, compId);
    var svgDomId = maskId + "-svg";
    var svgStringWithId = replaceSVGMaskAttributes(maskData.svgString, svgDomId);
    var svgStringWithIdAndA11y = svgStringWithId
        .replace(/(role="\w+")/, '')
        .replace('<svg', "<svg " + getNoAltA11yAttributes(true));
    var maskAttrs = (0, tslib_1.__assign)({
        width: '100%',
        height: '100%',
        x: 0,
        y: 0
    }, getMaskFlipTransformAttr(maskData.flip, imageDimensions));
    var defsString = "<defs>" + getMask(maskId, svgDomId, svgStringWithIdAndA11y, maskAttrs) + "</defs>";
    var imageString = createElement('image', (0, tslib_1.__assign)({}, imageAttributes), '');
    return createElement('svg', svgImageAttributes, "" + defsString + imageString);
};
exports.createReactSvgImageWithMask = createReactSvgImageWithMask;
var getFontFamilyFontsFromSvg = function(svgString) {
    var regex = /font-family=['"](.*?)['"]/gi;
    var match;
    var fonts = [];
    do {
        match = regex.exec(svgString);
        if (match && match[1]) {
            var font = match[1].split(',').map(function(f) {
                return f.replace(/'/g, '').trim();
            });
            fonts.push(font);
        }
    } while (match);
    return fonts;
};
exports.getFontFamilyFontsFromSvg = getFontFamilyFontsFromSvg;
var buildSvgUrlFactory = function() {
    var addTrailingSlashIfMissing = function(val) {
        return (val.endsWith('/') ? val : val + "/");
    };
    var getSvgBaseUrl = function(mediaRootUrl) {
        return addTrailingSlashIfMissing(mediaRootUrl) + "shapes/";
    };
    var svgIdToUri = function(svgId) {
        var partsArr = svgId.replace(/^.*\//, '').split('.');
        var version = partsArr[1] === 'v1' ? 1 : 2;
        var svgHash = partsArr[2].replace(/svg_/i, '');
        var svgName = partsArr[3];
        return svgHash + (version === 1 ? "_svgshape.v1." + svgName : '') + ".svg";
    };
    return {
        getSvgBaseUrl: getSvgBaseUrl,
        buildSvgUrl: function(mediaRootUrl, svgId) {
            if (/^svgshape\.v[12]/.test(svgId)) {
                var svgUri = svgIdToUri(svgId);
                return "" + getSvgBaseUrl(mediaRootUrl) + svgUri;
            }
            return "" + getSvgBaseUrl(mediaRootUrl) + svgId;
        },
    };
};
exports.buildSvgUrlFactory = buildSvgUrlFactory;
//# sourceMappingURL=index.js.map