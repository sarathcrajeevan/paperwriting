import {
    gradientConstants
} from './constants.js';
var _a = gradientConstants.TYPES,
    GRADIENT_LINEAR = _a.GRADIENT_LINEAR,
    GRADIENT_CONIC = _a.GRADIENT_CONIC,
    GRADIENT_CIRCLE = _a.GRADIENT_CIRCLE;
var _b = gradientConstants.CSS_FUNC,
    RADIAL_GRADIENT = _b.RADIAL_GRADIENT,
    CONIC_GRADIENT = _b.CONIC_GRADIENT,
    LINEAR_GRADIENT = _b.LINEAR_GRADIENT;
var REPEATING = gradientConstants.REPEATING,
    DEG = gradientConstants.DEG,
    AT_CENTER = gradientConstants.AT_CENTER,
    CIRCLE = gradientConstants.CIRCLE,
    ELLIPSE = gradientConstants.ELLIPSE,
    FROM = gradientConstants.FROM,
    PERCENTAGE = gradientConstants.PERCENTAGE;
/**
 *
 * @param {GradientData | GradientData[] | GradientMesh} gradients List of Objects representing gradient's data.
 * @param {number?} options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string} CSS string of gradients
 */
function generate(gradients, options) {
    if (gradients === void 0) {
        gradients = [];
    }
    if (options === void 0) {
        options = {};
    }
    gradients = Array.isArray(gradients) ? gradients : [gradients];
    return gradients
        .map(function(gradient) {
            return generateGradientFromDatum(gradient, options);
        })
        .join(', ');
}
/**
 * Validate if a gradient is valid, currently doing a loose comparison. Will harden the validation if needed
 * @param {any | GradientData | GradientData[] | GradientMesh} gradients List of Objects representing gradient's data.
 * @returns {boolean} Whether the gradients are valid
 */
function validate(gradients) {
    if (gradients === void 0) {
        gradients = [];
    }
    gradients = Array.isArray(gradients) ? gradients : [gradients];
    var types = Object.values(gradientConstants.TYPES);
    return (gradients.length &&
        gradients.every(function(gradient) {
            return gradient &&
                types.includes(gradient.type) &&
                gradient.colorStops &&
                gradient.colorStops.length;
        }));
}
/**
 * Convert hex color (with or withour alpha) and a passed alpha value to an rgba string
 * NOTE: Does not validate the input
 * @param {string} hex color in the format of #FFF #FFFFFF or #FFFFFFFF
 * @param {number?} alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @returns {string} rgba(255,255,255,100)
 */
function hex2rgba(hex, alpha) {
    if (alpha === void 0) {
        alpha = 1;
    }
    var shortHex = hex.length === 4;
    var matcher = shortHex ? /\w/g : /\w\w/g;
    var _a = hex
        .match(matcher)
        .map(function(x) {
            return parseInt(x.repeat(shortHex ? 2 : 1), 16);
        }),
        r = _a[0],
        g = _a[1],
        b = _a[2],
        _b = _a[3],
        a = _b === void 0 ? 255 : _b;
    return "rgba(" + r + "," + g + "," + b + "," + (a / 255) * alpha + ")";
}
/**
 *
 * @param {string} wixRgba r,g,b,a
 * @returns {[string, number]} touple of hex color and alpha
 */
export function wrgba2hex_a(wixRgba) {
    var _a = wixRgba.split(/,\s*/),
        r = _a[0],
        g = _a[1],
        b = _a[2],
        a = _a[3];
    return [
        "#" + ((1 << 24) + (+r << 16) + (+g << 8) + +b)
        .toString(16)
        .slice(1)
        .toUpperCase(), +a,
    ];
}
/**
 * check if value is wix data r,g,b,a format
 * @param {string} color
 * @returns {boolean}
 */
function isWixRgba(color) {
    return /^(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)$/.test(color);
}

function isHex(color) {
    return /^#(?:[0-9a-fA-F]{3}){1,2}$/i.test(color);
}
/**
 *
 * @param {GradientData} gradient
 * @param {number?} options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string}
 */
function generateGradientFromDatum(gradient, options) {
    var gradientRepeat = gradient.repeat ? REPEATING + "-" : '';
    var gradientString = generateGradientByType(gradient);
    var gradientColorStops = generateColorStops(gradient.colorStops, options);
    return "" + gradientRepeat + gradientString + gradientColorStops + ")";
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} gradient type CSS string
 */
function generateGradientByType(gradient) {
    if (gradient.type === GRADIENT_LINEAR) {
        return generateLinear(gradient);
    }
    if (gradient.type === GRADIENT_CONIC) {
        return generateConic(gradient);
    }
    return generateRadial(gradient);
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} linear-gradient string
 */
function generateLinear(_a) {
    var _b = _a.angle,
        angle = _b === void 0 ? 0 : _b;
    var gradientAngle = generateGradientAngle(angle, ', ');
    return LINEAR_GRADIENT + "(" + gradientAngle;
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} radial-gradient string
 */
function generateRadial(_a) {
    var size = _a.size,
        position = _a.position,
        type = _a.type;
    var gradientSize = generateGradientSize(size);
    var gradientPosition = generateGradientPosition(position, type);
    var radialShape = type === GRADIENT_CIRCLE ? CIRCLE : ELLIPSE;
    return RADIAL_GRADIENT + "(" + radialShape + " " + gradientSize + gradientPosition;
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} conic-gradient string
 */
function generateConic(_a) {
    var _b = _a.angle,
        angle = _b === void 0 ? 0 : _b,
        position = _a.position,
        type = _a.type;
    var gradientPosition = generateGradientPosition(position, type);
    var gradientAngle = generateGradientAngle(angle);
    var angleDelimiter = position ? ' ' : ', ';
    return CONIC_GRADIENT + "(" + FROM + " " + gradientAngle + angleDelimiter + gradientPosition;
}
/**
 *
 * @param {UnitLengthPercentage} data
 * @return {string} background values string
 */
function generateUnitSize(_a) {
    var type = _a.type,
        value = _a.value;
    if (type === PERCENTAGE) {
        return value + "%";
    }
    return "" + value + type;
}
/**
 *
 * @param {number} angle
 * @param {string} [suffix] defaults to `''`.
 * @return {string} gradient angle string
 */
function generateGradientAngle(angle, suffix) {
    if (suffix === void 0) {
        suffix = '';
    }
    return "" + angle + DEG + suffix;
}
/**
 *
 * @param {object} size
 * @return {string} gradient size string
 */
function generateGradientSize(size) {
    if (!size) {
        return '';
    } else if (size.keyword) {
        return size.keyword + " ";
    } else if (size.width) {
        var sizeWidth = generateUnitSize(size.width);
        var sizeHeight = generateUnitSize(size.height);
        return sizeWidth + " " + sizeHeight + " ";
    } else if (size.type === PERCENTAGE) {
        return size.value + "% ";
    }
    return "" + size.value + size.type + " ";
}
/**
 *
 * @param {{x: number, y: number}} gradient
 * @param {string} type
 * @return {string} gradient position string
 */
function generateGradientPosition(position, type) {
    if (!position) {
        if (type === GRADIENT_CONIC) {
            return '';
        }
        return AT_CENTER + ", ";
    }
    var xPosition = generateUnitSize(position.x);
    var yPosition = generateUnitSize(position.y);
    return "at " + xPosition + " " + yPosition + ", ";
}
/**
 *
 * @param {ColorStop[]} colorStops
 * @param {number?} options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string} gradient colorStops string
 */
function generateColorStops(colorStops, options) {
    if (colorStops === void 0) {
        colorStops = [];
    }
    return colorStops
        .map(function(colorStop) {
            return generateColorStop(colorStop, options);
        })
        .join(', ');
}
/**
 *
 * @param {string?} color hex color or an 'r,g,b,a' string, a ignored is opacity !== undefined
 * @param {number?} opacity 0...1
 * @param {{type: string, value: number}} size
 * @param {number?} alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string} gradient colorStop string
 */
function generateColorStop(_a, _b) {
    var color = _a.color,
        opacity = _a.opacity,
        size = _a.size;
    var _c = _b.alpha,
        alpha = _c === void 0 ? 1 : _c,
        resolveColor = _b.resolveColor;
    var colorStopColor = '';
    var colorStopSize = '';
    if (color) {
        if (resolveColor) {
            color = resolveColor(color);
        }
        if (isHex(color)) {
            opacity !== null && opacity !== void 0 ? opacity : (opacity = 1);
            colorStopColor =
                opacity * alpha < 1 ? hex2rgba(color, opacity * alpha) : color;
        } else if (isWixRgba(color)) {
            var _d = wrgba2hex_a(color),
                colorHex = _d[0],
                colorAlpha = _d[1];
            opacity !== null && opacity !== void 0 ? opacity : (opacity = colorAlpha);
            colorStopColor = hex2rgba(colorHex, opacity * alpha);
        } else {
            colorStopColor = color;
        }
    }
    if (size) {
        var type = size.type,
            value = size.value;
        if (type === PERCENTAGE) {
            colorStopSize = value + "%";
        } else {
            colorStopSize = "" + value + type;
        }
    }
    if (color && size) {
        return colorStopColor + " " + colorStopSize;
    } else if (color) {
        return colorStopColor;
    }
    return colorStopSize;
}
/**
 * @typedef {Object} GradientData
 * @property {'GradientLinear'|'GradientCircle'|'GradientEllipse'|'GradientConic'} type
 * @property {boolean} repeat
 * @property {number} [angle]
 * @property {Object} [position]
 * @property {Object} [size]
 * @property {ColorStop[]} colorStops
 *
 * @typedef {Object} ColorStop
 * @property {string} color
 * @property {UnitLengthPercentage | UnitAngle} size
 *
 * @typedef {Object} UnitLengthPercentage
 * @property {number} value
 * @property {'px' | 'em' | 'rem' | 'fr' | 'percentage' | 'vh' | 'vw'} type
 *
 * @typedef {Object} UnitAngle
 * @property {number} value
 * @property {'deg' | 'percentage'} type
 */
export {
    generate,
    validate
};
//# sourceMappingURL=index.js.map