import {
    fromValue,
    fromString
} from 'long';
var cloneDeep = require('lodash.clonedeep');
export var fromJson = function(typeName, payload, pathInPayload) {
    var clonedPayload = cloneDeep(payload);
    serializer[typeName].fromJson(clonedPayload, pathInPayload);
    return clonedPayload;
};
export var toJson = function(typeName, payload, pathInPayload) {
    var clonedPayload = cloneDeep(payload);
    serializer[typeName].toJson(clonedPayload, pathInPayload);
    return clonedPayload;
};
export var batchFromJson = function(payload, serializationRequests) {
    var clonedPayload = cloneDeep(payload);
    serializationRequests.forEach(function(serializationRequest) {
        serializer[serializationRequest.typeName].fromJson(clonedPayload, serializationRequest.pathInPayload);
    });
    return clonedPayload;
};
export var batchToJson = function(payload, serializationRequests) {
    var clonedPayload = cloneDeep(payload);
    serializationRequests.forEach(function(serializationRequest) {
        serializer[serializationRequest.typeName].toJson(clonedPayload, serializationRequest.pathInPayload);
    });
    return clonedPayload;
};
export var NULL_VALUE_SERIALIZATION_KEY = 'google.protobuf.NullValue';
export var DURATION_SERIALIZATION_KEY = 'google.protobuf.Duration';
export var TIMESTAMP_SERIALIZATION_KEY = 'google.protobuf.Timestamp';
export var FIELD_MASK_SERIALIZATION_KEY = 'google.protobuf.FieldMask';
export var FIELD_MASK_ARRAY_SERIALIZATION_KEY = 'google.protobuf.FieldMaskArray';
export var INT_64_SERIALIZATION_KEY = 'int64';
export var FIXED_64_SERIALIZATION_KEY = 'fixed64';
export var SFIXED_64_SERIALIZATION_KEY = 'sfixed64';
export var UINT_64_SERIALIZATION_KEY = 'uint64';
export var SINT_64_SERIALIZATION_KEY = 'sint64';
export var UINT_64_VALUE_SERIALIZATION_KEY = 'google.protobuf.UInt64Value';
export var BYTES_SERIALIZATION_KEY = 'bytes';
export var INT_64_VALUE_SERIALIZATION_KEY = 'google.protobuf.Int64Value';
var typeTransformer = function(jsonSerializer, jsonDeserializer) {
    return {
        toJson: function(payload, pathInPayload) {
            return updatePathRecursively(payload, pathInPayload, jsonSerializer);
        },
        fromJson: function(payload, pathInPayload) {
            return updatePathRecursively(payload, pathInPayload, jsonDeserializer);
        },
    };
};
var jsonDeserializeLong = function(longAsString) {
    return (longAsString !== undefined ? fromValue(longAsString) : undefined);
};
var jsonSerializeLong = function(longObject) {
    return longObject !== undefined ? longObject.toString() : undefined;
};
var longTransformer = typeTransformer(jsonSerializeLong, jsonDeserializeLong);
var jsonSerializeTimestamp = function(dateObject) {
    return dateObject ? dateObject.toISOString() : undefined;
};
var jsonDeserializeTimestamp = function(dateString) {
    return dateString ? new Date(Date.parse(dateString.toString())) : undefined;
};
var jsonSerializeNullValue = function() {
    return null;
};
var jsonDeserializeNullValue = function() {
    return null;
};
var jsonSerializeFieldMask = function(fieldMaskObject) {
    return fieldMaskObject;
};
var jsonDeserializeFieldMask = function(fieldMaskString) {
    return fieldMaskString;
};
var jsonSerializeFieldMaskArray = function(fieldMaskObject) {
    return fieldMaskObject && Array.isArray(fieldMaskObject) ?
        fieldMaskObject.join(',') :
        undefined;
};
var jsonDeserializeFieldMaskArray = function(fieldMaskString) {
    return fieldMaskString ? fieldMaskString.split(',') : undefined;
};
var jsonDeserializeBytes = function(bytes64bitEncodedString) {
    var asCharCode = function(c) {
        return c.charCodeAt(0);
    };
    var decode = function(chars) {
        return Uint8Array.from(atob(chars), asCharCode);
    };
    return decode(bytes64bitEncodedString);
};
var jsonSerializeBytes = function(bytesArray) {
    var output = [];
    for (var i = 0, length_1 = bytesArray.length; i < length_1; i++) {
        output.push(String.fromCharCode(bytesArray[i]));
    }
    return btoa(output.join(''));
};
var jsonSerializeDuration = function(durationObject) {
    if (durationObject &&
        durationObject.seconds !== undefined &&
        durationObject.nanos !== undefined) {
        var nanosString = durationObject.nanos.toString().length < 9 ?
            '000000000'.substr(0, 9 - durationObject.nanos.toString().length) +
            durationObject.nanos.toString() :
            durationObject.nanos.toString();
        return durationObject.seconds.toString() + "." + nanosString + "s";
    }
    return undefined;
};
var jsonDeserializeDuration = function(durationString) {
    return durationString ?
        {
            seconds: fromString(durationString.substr(0, durationString.indexOf('.'))),
            nanos: Number.parseInt(durationString.substr(durationString.indexOf('.') + 1, durationString.length - 1), 10),
        } :
        undefined;
};
/**
 * traverse the payload recursively and apply the transformation on the end of the path.
 * in case we have an array as part of the path we assume the array elements are all of the same type and we apply the
 * transformation on all the path continuations of all the array elements
 * @param payload
 * @param pathToUpdate
 * @param applyTransformation
 */
var updatePathRecursively = function(payload, pathToUpdate, applyTransformation) {
    if (pathToUpdate.length === 1) {
        // recursion end condition
        if (payload !== undefined && payload !== null) {
            // all the fields are optional so only if we have an object we will update it.
            var transformedPayload = applyTransformation(payload[pathToUpdate[0]]);
            if (transformedPayload !== undefined && transformedPayload !== null) {
                payload[pathToUpdate[0]] = transformedPayload;
            }
        }
    } else {
        // go down one level deep in the recursion
        if (payload !== undefined && payload !== null) {
            // all the fields are optional so only if we have an object we will continue the recursion.
            var currentPayloadSubTree = payload[pathToUpdate[0]];
            if (Array.isArray(currentPayloadSubTree)) {
                // traverse arrays
                currentPayloadSubTree.forEach(function(objectArrayElement) {
                    return updatePathRecursively(objectArrayElement, pathToUpdate.slice(1), applyTransformation);
                });
            } else {
                // traverse object with the rest of the path
                updatePathRecursively(currentPayloadSubTree, pathToUpdate.slice(1), applyTransformation);
            }
        }
    }
};
var serializer = {};
serializer[NULL_VALUE_SERIALIZATION_KEY] = typeTransformer(jsonSerializeNullValue, jsonDeserializeNullValue);
serializer[DURATION_SERIALIZATION_KEY] = typeTransformer(jsonSerializeDuration, jsonDeserializeDuration);
serializer[INT_64_VALUE_SERIALIZATION_KEY] = longTransformer;
serializer[INT_64_SERIALIZATION_KEY] = longTransformer;
serializer[FIXED_64_SERIALIZATION_KEY] = longTransformer;
serializer[SFIXED_64_SERIALIZATION_KEY] = longTransformer;
serializer[UINT_64_SERIALIZATION_KEY] = longTransformer;
serializer[SINT_64_SERIALIZATION_KEY] = longTransformer;
serializer[UINT_64_VALUE_SERIALIZATION_KEY] = longTransformer;
serializer[TIMESTAMP_SERIALIZATION_KEY] = typeTransformer(jsonSerializeTimestamp, jsonDeserializeTimestamp);
serializer[FIELD_MASK_SERIALIZATION_KEY] = typeTransformer(jsonSerializeFieldMask, jsonDeserializeFieldMask);
serializer[FIELD_MASK_ARRAY_SERIALIZATION_KEY] = typeTransformer(jsonSerializeFieldMaskArray, jsonDeserializeFieldMaskArray);
serializer[BYTES_SERIALIZATION_KEY] = typeTransformer(jsonSerializeBytes, jsonDeserializeBytes);
//# sourceMappingURL=index.js.map