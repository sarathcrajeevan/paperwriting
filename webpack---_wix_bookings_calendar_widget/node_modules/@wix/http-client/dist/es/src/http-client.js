import {
    __assign,
    __awaiter,
    __generator
} from "tslib";
import axios from 'axios';
import {
    buildOptions
} from './options';
import {
    HttpError
} from './error';
import {
    silent,
    isHttpMockServerEnabled,
    shouldAllowUnmocked,
    extractProp,
    resolveHost,
    getGlobalConfig,
    resolveProtocol,
} from './utils';
import {
    NO_SCENARIO_FOUND,
    SSR_HOST,
    SSR_PROTOCOL
} from './constants';
import {
    isNode
} from './env-util';
import {
    requestIdOrEmptyString
} from './headers';
var HttpClient = /** @class */ (function() {
    function HttpClient(opts) {
        if (opts === void 0) {
            opts = {};
        }
        this.opts = opts;
        this.opts = defaultClientOptions(this.opts);
        this.client = axios.create(this.opts);
    }
    HttpClient.isHttpError = function(payload) {
        return !!(payload === null || payload === void 0 ? void 0 : payload.isWixHttpError);
    };
    HttpClient.prototype.request = function(requestOptionsOrFactory) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function() {
            var host, protocol, urlObject, requestOptions, signedInstance, options;
            var _this = this;
            return __generator(this, function(_c) {
                host = resolveHost(this.opts);
                protocol = resolveProtocol(this.opts);
                urlObject = {
                    protocol: protocol,
                    host: host
                };
                requestOptions = typeof requestOptionsOrFactory === 'function' ?
                    requestOptionsOrFactory({
                        isSSR: this.opts.isSSR,
                        host: host
                    }) :
                    requestOptionsOrFactory;
                signedInstance = ((_b = (_a = this.opts).getAppToken) === null || _b === void 0 ? void 0 : _b.call(_a)) || '';
                options = buildOptions({
                    requestOptions: requestOptions,
                    urlObject: urlObject,
                    wixHeadersOpts: {
                        signedInstance: signedInstance,
                        artifactId: this.opts.artifactId,
                        csrf: false /* axios handles xsrf */ ,
                    },
                    globalConfig: getGlobalConfig(),
                });
                if (this.opts.isSSR) {
                    options.baseURL = SSR_PROTOCOL + "://" + SSR_HOST;
                }
                return [2 /*return*/ , this.client
                    .request(options)
                    .catch(function(err) {
                        return _this.maybeFallbackRequest(err, requestOptions, urlObject, signedInstance);
                    })
                    .catch(function(err) {
                        return _this.handleRequestError(err, options);
                    })
                    .then(function(res) {
                        return _this.transformResponse(res, requestOptions);
                    })
                ];
            });
        });
    };
    HttpClient.prototype.get = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'GET'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.delete = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'DELETE'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.head = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'HEAD'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.options = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'OPTIONS'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.post = function(url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    data: data,
                    method: 'POST'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.put = function(url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    data: data,
                    method: 'PUT'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.patch = function(url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    data: data,
                    method: 'PATCH'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.handleRequestError = function(error, requestOptions) {
        var requestError = new HttpError(error);
        silent(function() {
            var _a;
            return (_a = requestOptions.onError) === null || _a === void 0 ? void 0 : _a.call(requestOptions, requestError);
        });
        throw requestError;
    };
    HttpClient.prototype.maybeFallbackRequest = function(err, requestOptions, urlObject, signedInstance) {
        var _a, _b, _c;
        var shouldFallbackRequest = isHttpMockServerEnabled() &&
            shouldAllowUnmocked() &&
            ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 404 &&
            ((_c = (_b = err.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.msg) === NO_SCENARIO_FOUND;
        if (shouldFallbackRequest) {
            var prodOptions = buildOptions({
                requestOptions: requestOptions,
                urlObject: urlObject,
                wixHeadersOpts: {
                    signedInstance: signedInstance,
                    artifactId: this.opts.artifactId,
                },
            });
            return this.client.request(prodOptions);
        }
        throw err;
    };
    HttpClient.prototype.transformResponse = function(res, requestOptions) {
        var requestId = requestIdOrEmptyString(res);
        var data = transformData(res, requestOptions);
        return __assign(__assign({}, res), {
            data: data,
            requestId: requestId
        });
    };
    HttpClient.CancelToken = axios.CancelToken;
    HttpClient.isCancel = axios.isCancel;
    return HttpClient;
}());
export {
    HttpClient
};

function defaultClientOptions(opts) {
    var adapter;
    var useHttpAdapter = isNode();
    // https://github.com/webpack/webpack/issues/5939#issue-272316127
    if (useHttpAdapter) {
        var requireFunc = typeof __webpack_require__ === 'function' ?
            __non_webpack_require__ :
            require;
        adapter = requireFunc('axios/lib/adapters/http');
    }
    return __assign({
        adapter: adapter,
        isSSR: false
    }, opts);
}

function transformData(res, requestOptions) {
    var resData = res.data;
    if (requestOptions._pickResponseBody) {
        resData = extractProp(res.data, requestOptions._pickResponseBody);
    }
    if (requestOptions._logs) {
        var logs = extractProp(res.data, requestOptions._logs);
        if (logs === null || logs === void 0 ? void 0 : logs.length) {
            logs.map(function(log) {
                return console.log.apply(console, log);
            });
        }
    }
    return resData;
}
//# sourceMappingURL=http-client.js.map