"use strict";
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.merge = void 0;
var Identifiers_1 = require("../types/Identifiers");
var identify_1 = require("./utils/identify");
var get_simplified_tag_label_1 = require("../tags/advanced/get-simplified-tag-label");
var filter_duplicate_custom_tags_1 = require("../tags/filters/filter-duplicate-custom-tags");
var robots_tag_1 = require("../tags/robots-tag/robots-tag");
var get_by_identifier_1 = require("../tags/values/get-by-identifier");
var getIdentifier = function(tag, _a) {
    var _b;
    var _c = (_a === void 0 ? {} : _a).logError,
        logError = _c === void 0 ? function() {} : _c;
    var identifier = identify_1.identify(tag);
    if (identifier === Identifiers_1.IDENTIFIERS.STRUCTURED_DATA) {
        if ((_b = tag === null || tag === void 0 ? void 0 : tag.meta) === null || _b === void 0 ? void 0 : _b.schemaType) {
            return tag.meta.schemaType + " - " + tag.meta.selectedVariant;
        }
        try {
            var jsonData = JSON.parse(tag.children);
            var scriptType = jsonData && jsonData['@type'];
            return identifier + " - " + scriptType;
        } catch (error) {
            logError({
                error: error,
                data: {
                    value: tag.children
                }
            });
        }
    }
    if (!identifier && tag.props && !tag.custom) {
        var simplifiedTagLabel = get_simplified_tag_label_1.getSimplifiedTagLabel(tag);
        var simplifiedTagIdentifier = getSimplifiedTagIdentifier(simplifiedTagLabel);
        if (simplifiedTagIdentifier) {
            return simplifiedTagIdentifier;
        }
    }
    return identifier;
};
var getSimplifiedTagIdentifier = function(simplifiedTagLabel) {
    var simplifiedIdentifier = Object.values(Identifiers_1.IDENTIFIERS).find(function(identifier) {
        return simplifiedTagLabel === identifier.toLowerCase();
    });
    return simplifiedIdentifier || simplifiedTagLabel;
};
var identifierToMergeLogic = (_a = {}, _a[Identifiers_1.IDENTIFIERS.ROBOTS] = robots_tag_1.mergeRobotsTags, _a);

function merge(allTags, currentTags, options) {
    if (options === void 0) {
        options = {
            logError: function() {}
        };
    }
    var tags = [];
    var uniqueTagCache = new Map();
    allTags = Array.isArray(allTags) ? allTags : [];
    currentTags = Array.isArray(currentTags) ? currentTags : [];
    var tagsWithoutDuplicateCustom = filter_duplicate_custom_tags_1.filterDuplicateCustomTags(allTags, currentTags);
    var mergedTags = []
        .concat(currentTags.some(function(tag) {
                return tag.allowMultiple;
            }) ?
            tagsWithoutDuplicateCustom.filter(function(tag) {
                return !tag.allowMultiple;
            }) :
            tagsWithoutDuplicateCustom)
        .concat(currentTags)
        .reverse();
    for (var _i = 0, mergedTags_1 = mergedTags; _i < mergedTags_1.length; _i++) {
        var tag = mergedTags_1[_i];
        var identifier = getIdentifier(tag, options);
        var allowMultiple = Boolean(tag.allowMultiple);
        var isCached = uniqueTagCache.has(identifier);
        if (allowMultiple || !isCached) {
            var specificMergeLogic = identifierToMergeLogic[identifier];
            if (specificMergeLogic) {
                var matchedTags = get_by_identifier_1.getTagsByIdentifier(mergedTags, identifier);
                if (matchedTags.length) {
                    var mergedTag = matchedTags.reduce(specificMergeLogic);
                    tags.push(mergedTag);
                }
            } else {
                tags.push(tag);
            }
            var isGeneralIdentifier = Identifiers_1.GENERAL_IDENTIFIERS[identifier];
            if (!allowMultiple && identifier && !isGeneralIdentifier) {
                uniqueTagCache.set(identifier);
            }
        }
    }
    return tags.reverse();
}
exports.merge = merge;