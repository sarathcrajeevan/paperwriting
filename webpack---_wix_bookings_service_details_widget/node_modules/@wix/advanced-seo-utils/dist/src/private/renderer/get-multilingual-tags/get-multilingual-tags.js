"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function(mod) {
    return (mod && mod.__esModule) ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hasMultilingualTags = exports.getMultilingualTags = exports.getMultilingualSchemaFromContext = void 0;
var builders_1 = require("../../types/builders");
var consts_1 = require("../../consts");
var Props_1 = __importDefault(require("../../types/Props"));
var safely_parse_json_data_1 = require("../utils/safely-parse-json-data");
var get_by_identifier_1 = require("../../tags/values/get-by-identifier");
var robots_tag_1 = require("../../tags/robots-tag/robots-tag");
var Identifiers_1 = require("../../types/Identifiers");
var REL = Props_1.default.REL,
    HREF = Props_1.default.HREF,
    HREFLANG = Props_1.default.HREFLANG;

function getMultilingualSchemaFromContext(data, _a) {
    var _b = _a === void 0 ? {} : _a,
        _c = _b.currentSchemas,
        currentSchemas = _c === void 0 ? [] : _c,
        _d = _b.translationsData,
        translationsData = _d === void 0 ? {} : _d;
    var schemesHasMultilingualTags = currentSchemas.some(function(schema) {
        return hasMultilingualTags(schema === null || schema === void 0 ? void 0 : schema.tags);
    });
    if (schemesHasMultilingualTags) {
        return {
            tags: []
        };
    }
    var _e = (data || {}).context,
        _f = _e === void 0 ? {} : _e,
        siteLanguages = _f.siteLanguages,
        siteUrl = _f.siteUrl;
    if (!(siteLanguages === null || siteLanguages === void 0 ? void 0 : siteLanguages.length)) {
        return {
            tags: []
        };
    }
    var languages = __spreadArrays([{
        url: siteUrl,
        languageCode: consts_1.X_DEFAULT
    }], siteLanguages);
    var tags = getMultilingualTags(languages, translationsData);
    return {
        tags: tags
    };
}
exports.getMultilingualSchemaFromContext = getMultilingualSchemaFromContext;
/**
 *
 * @param {Array<{
 * url: string,
 * langCode: string,
 * languageCode: string
 * seoLang: string,
 * }>} siteLanguages
 */
function getMultilingualTags(siteLanguages, translationsData) {
    if (translationsData === void 0) {
        translationsData = {};
    }
    var tagsMap = new Map();
    var shouldAddTag = function(hreflang, href) {
        return !tagsMap.has(hreflang) &&
            shouldRenderLanguage({
                translationsData: translationsData,
                hreflang: hreflang,
                href: href
            });
    };
    return (siteLanguages || [])
        .map(function(_a) {
            var url = _a.url,
                linkToPage = _a.linkToPage,
                langCode = _a.langCode,
                languageCode = _a.languageCode,
                language = _a.language,
                seoLang = _a.seoLang;
            var href = url || linkToPage;
            var hreflang = seoLang || langCode || languageCode || language;
            if (languageCode === consts_1.X_DEFAULT || langCode === consts_1.X_DEFAULT) {
                hreflang = consts_1.X_DEFAULT;
            }
            var tag = href && hreflang ? builders_1.buildMultilingualLink(href, hreflang) : undefined;
            return tag;
        })
        .filter(Boolean)
        .reverse()
        .reduce(function(tags, tag) {
            var _a = (tag === null || tag === void 0 ? void 0 : tag.props) || {},
                _b = HREFLANG,
                hreflang = _a[_b],
                _c = HREF,
                href = _a[_c];
            if (shouldAddTag(hreflang, href)) {
                tagsMap.set(hreflang);
                return __spreadArrays([tag], tags);
            } else {
                return tags;
            }
        }, []);
}
exports.getMultilingualTags = getMultilingualTags;

function hasMultilingualTags(tags) {
    if (!Array.isArray(tags)) {
        return false;
    }
    return tags.some(function(tag) {
        var _a = (tag === null || tag === void 0 ? void 0 : tag.props) || {},
            _b = REL,
            rel = _a[_b],
            _c = HREF,
            href = _a[_c],
            _d = HREFLANG,
            hreflang = _a[_d];
        return Boolean(rel && href && hreflang);
    });
}
exports.hasMultilingualTags = hasMultilingualTags;

function shouldRenderLanguage(_a) {
    var translationsData = _a.translationsData,
        href = _a.href,
        hreflang = _a.hreflang;
    var languagesTagsJson = translationsData[hreflang];
    if (!languagesTagsJson) {
        return true;
    }
    var tags = safely_parse_json_data_1.safelyParseJsonData(languagesTagsJson).tags;
    var _b = [
            Identifiers_1.IDENTIFIERS.ROBOTS,
            Identifiers_1.IDENTIFIERS.CANONICAL,
        ].map(function(identifier) {
            return get_by_identifier_1.getValueByIdentifier(tags, identifier);
        }),
        robotsValue = _b[0],
        canonicalValue = _b[1];
    var shouldIndex = !robotsValue ||
        !robots_tag_1.isRobotsDirectiveExists(robotsValue, robots_tag_1.ROBOTS_DIRECTIVES.NOINDEX);
    var isCanonicalEqual = !canonicalValue || canonicalValue === href;
    return shouldIndex && isCanonicalEqual;
}