"use strict";
var __assign = (this && this.__assign) || function() {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isRobotsTagValueSupported = exports.formatRobotsTagForRendering = exports.getRobotsTagValueWithoutDirective = exports.getRobotsTagValueWithDirective = exports.getDirectiveValue = exports.isRobotsDirectiveExists = exports.mergeRobotsTags = exports.REMOVE_ROBOTS_DIRECTIVE_OVERRIDE_VALUE = exports.MAX_VIDEO_PREVIEW_DEFAULT_VALUE = exports.MAX_SNIPPET_DEFAULT_VALUE = exports.MAX_IMAGE_PREVIEW_VALUES = exports.ROBOTS_DIRECTIVES = void 0;
var Identifiers_1 = require("../../types/Identifiers");
var TagSchemas_1 = require("../../types/TagSchemas");
var get_by_identifier_1 = require("../values/get-by-identifier");
var update_by_identifier_1 = require("../values/update-by-identifier");
var ROBOTS_DIRECTIVE_NAME_VALUE_SEPARATOR = ':';
exports.ROBOTS_DIRECTIVES = {
    NOINDEX: 'noindex',
    NOFOLLOW: 'nofollow',
    NOSNIPPET: 'nosnippet',
    NOARCHIVE: 'noarchive',
    NOIMAGEINDEX: 'noimageindex',
    MAX_IMAGE_PREVIEW: 'max-image-preview',
    MAX_SNIPPET: 'max-snippet',
    MAX_VIDEO_PREVIEW: 'max-video-preview',
};
exports.MAX_IMAGE_PREVIEW_VALUES = {
    NONE: 'none',
    STANDARD: 'standard',
    LARGE: 'large',
};
exports.MAX_SNIPPET_DEFAULT_VALUE = '-1';
exports.MAX_VIDEO_PREVIEW_DEFAULT_VALUE = '-1';
var INDEX = 'index';
var noindexRelatedDirectiveNames = new Set([
    exports.ROBOTS_DIRECTIVES.NOINDEX,
    INDEX,
]);
exports.REMOVE_ROBOTS_DIRECTIVE_OVERRIDE_VALUE = '$remove$';
var robotsTagSchema = TagSchemas_1.TAG_SCHEMAS[Identifiers_1.IDENTIFIERS.ROBOTS];
var toCanonicalForm = function(directive) {
    return directive.toLowerCase();
};
var sortDirectives = function(directives) {
    return __spreadArrays(directives).sort(function(firstDirective, otherDirective) {
        return firstDirective.localeCompare(otherDirective);
    });
};
var removeTrailingComma = function(directive) {
    return directive.replace(/,$/g, '');
};
var getDirectiveNameValuePair = function(directive) {
    if (directive === undefined) {
        return [undefined, undefined];
    }
    var nameValueSeparatorIndex = directive.lastIndexOf(ROBOTS_DIRECTIVE_NAME_VALUE_SEPARATOR);
    if (nameValueSeparatorIndex === -1) {
        return [directive, undefined];
    }
    return [
        directive.slice(0, nameValueSeparatorIndex),
        directive.slice(nameValueSeparatorIndex + 1),
    ];
};
var createDirective = function(directive, value) {
    return value !== undefined ?
        "" + directive + ROBOTS_DIRECTIVE_NAME_VALUE_SEPARATOR + value :
        directive;
};
var getDirectiveNameFromDirective = function(directive) {
    return getDirectiveNameValuePair(directive)[0];
};
var getDirectiveValueFromDirective = function(directive) {
    return getDirectiveNameValuePair(directive)[1];
};
var getDirectives = function(robotsTagValue) {
    return (robotsTagValue !== null && robotsTagValue !== void 0 ? robotsTagValue : '')
        .split(' ')
        .filter(function(directive) {
            return directive !== '';
        })
        .map(removeTrailingComma)
        .map(toCanonicalForm);
};
var getRobotsTagValue = function(directives) {
    return sortDirectives(directives)
        .filter(function(directive) {
            return directive !== '';
        })
        .map(removeTrailingComma)
        .map(toCanonicalForm)
        .join(', ');
};
var isVariable = function(directive) {
    return directive && directive.startsWith('{{');
};
var mergeDirectives = function(specificDirectives, generalDirectives) {
    var directiveNameToDirective = new Map();
    var allDirectives = __spreadArrays(generalDirectives, specificDirectives);
    allDirectives.forEach(function(directive) {
        if (isVariable(directive)) {
            // if the directive is a variable, remove all existing variables
            Array.from(directiveNameToDirective.values()).forEach(function(currentDirective) {
                if (isVariable(currentDirective)) {
                    directiveNameToDirective.delete(getDirectiveNameFromDirective(currentDirective));
                }
            });
        }
        var directiveName = getDirectiveNameFromDirective(directive);
        if (noindexRelatedDirectiveNames.has(directiveName)) {
            // if the directive is related to noindex, remove all existing directives related to noindex
            noindexRelatedDirectiveNames.forEach(function(relatedDirectiveName) {
                directiveNameToDirective.delete(relatedDirectiveName);
            });
        }
        directiveNameToDirective.set(getDirectiveNameFromDirective(directive), directive);
    });
    var mergedDirectives = Array.from(directiveNameToDirective.values());
    if (mergedDirectives.some(function(directive) {
            return !isVariable(directive);
        })) {
        // if there's at least one non-variable directive remove all variables
        return mergedDirectives.filter(function(directive) {
            return !isVariable(directive);
        });
    }
    return mergedDirectives;
};
exports.mergeRobotsTags = function(specificRobotsTag, generalRobotsTag) {
    var generalDirectives = getDirectives(robotsTagSchema.getValue(generalRobotsTag));
    var specificDirectives = getDirectives(robotsTagSchema.getValue(specificRobotsTag));
    var mergedDirectives = mergeDirectives(specificDirectives, generalDirectives);
    var mergedValue = getRobotsTagValue(mergedDirectives);
    var mergedTag = __assign({}, specificRobotsTag);
    robotsTagSchema.setValue(mergedTag, mergedValue);
    return mergedTag;
};
exports.isRobotsDirectiveExists = function(robotsTagValue, directiveName) {
    return getDirectives(robotsTagValue).some(function(currentDirective) {
        var _a = getDirectiveNameValuePair(currentDirective),
            name = _a[0],
            value = _a[1];
        return (name === directiveName && value !== exports.REMOVE_ROBOTS_DIRECTIVE_OVERRIDE_VALUE);
    });
};
exports.getDirectiveValue = function(robotsTagValue, directiveName) {
    var directive = getDirectives(robotsTagValue).find(function(currentDirective) {
        return getDirectiveNameFromDirective(currentDirective) === directiveName;
    });
    return directive && getDirectiveValueFromDirective(directive);
};
exports.getRobotsTagValueWithDirective = function(robotsTagValue, directiveName, directiveValue) {
    if (directiveValue === void 0) {
        directiveValue = undefined;
    }
    var newDirective = createDirective(directiveName, directiveValue);
    var existingDirectives = getDirectives(robotsTagValue);
    var newDirectives = mergeDirectives([newDirective], existingDirectives);
    return getRobotsTagValue(newDirectives);
};
exports.getRobotsTagValueWithoutDirective = function(robotsTagValue, directiveName) {
    var newDirectives = getDirectives(robotsTagValue).filter(function(directive) {
        return getDirectiveNameFromDirective(directive) !== directiveName;
    });
    return getRobotsTagValue(newDirectives);
};
exports.formatRobotsTagForRendering = function(tags) {
    var robotsTagValue = get_by_identifier_1.getValueByIdentifier(tags, Identifiers_1.IDENTIFIERS.ROBOTS);
    var directives = getDirectives(robotsTagValue)
        .filter(function(directive) {
            return getDirectiveNameFromDirective(directive) !== '';
        })
        .filter(function(directive) {
            return getDirectiveValueFromDirective(directive) !==
                exports.REMOVE_ROBOTS_DIRECTIVE_OVERRIDE_VALUE;
        });
    var updatedValue = getRobotsTagValue(directives);
    return update_by_identifier_1.updateValueByIdentifier(tags, Identifiers_1.IDENTIFIERS.ROBOTS, updatedValue);
};
exports.isRobotsTagValueSupported = function(robotsTagValue) {
    var supportedRobotDirectives = new Set(__spreadArrays(Array.from(Object.values(exports.ROBOTS_DIRECTIVES)), [
        INDEX,
    ]));
    return getDirectives(robotsTagValue).every(function(directive) {
        var directiveName = getDirectiveNameFromDirective(directive);
        return supportedRobotDirectives.has(directiveName) || isVariable(directive);
    });
};