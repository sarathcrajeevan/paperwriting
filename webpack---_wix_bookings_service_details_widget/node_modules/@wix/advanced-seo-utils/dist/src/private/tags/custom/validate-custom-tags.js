"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateCustomTags = void 0;
var identify_1 = require("../../renderer/utils/identify");
var parse_1 = require("../../renderer/utils/parse");
var Errors_1 = require("../../types/Errors");
var Validators_1 = require("../../types/Validators");
var Identifiers_1 = require("../../types/Identifiers");

function validateCustomTags(htmlString, excludedIdentifiers) {
    if (excludedIdentifiers === void 0) {
        excludedIdentifiers = Object.keys(Identifiers_1.TWITTER_IDENTIFIERS);
    }
    if (htmlString === '') {
        return {
            isValid: true
        };
    }
    var errors = [];
    var tags = parse_1.parse(htmlString);
    if (!tags.length || !Validators_1.validateBrokenTags(htmlString).isValid) {
        errors.push(new Errors_1.ERRORS.INVALID_TAG_STRUCTURE());
    }
    var invalidAttributes = [];
    tags.forEach(function(tag) {
        var validationResult = Validators_1.validateIsInWhiteList(tag);
        if (!validationResult.isValid) {
            errors.push(validationResult.error);
        }
        var attrValidationResult = Validators_1.validateAttributeIsInBlacklist(tag);
        if (!attrValidationResult.isValid) {
            invalidAttributes = invalidAttributes.concat(attrValidationResult.error.duplicates);
        }
    });
    if (invalidAttributes.length) {
        errors.push(new Errors_1.ERRORS.TAG_CONTAINS_BLACKLISTED_ATTRIBUTE(invalidAttributes));
    }
    var identifiedTags = getIdentifiedTags(tags, excludedIdentifiers);
    if (identifiedTags.length) {
        var types = identifiedTags
            .map(function(tag) {
                return tag.props &&
                    (tag.props.property || tag.props.content || tag.props.href);
            })
            .filter(function(prop) {
                return prop;
            });
        if (types.length) {
            errors.push(new Errors_1.ERRORS.TAG_ALREADY_EXISTS(types));
        }
    }
    if (errors.length) {
        return {
            isValid: false,
            errors: errors
        };
    }
    return {
        isValid: true
    };
}
exports.validateCustomTags = validateCustomTags;

function getIdentifiedTags(tags, ignoreList) {
    if (ignoreList === void 0) {
        ignoreList = [];
    }
    return tags.filter(function(tag) {
        return identify_1.identify(tag, ignoreList);
    });
}