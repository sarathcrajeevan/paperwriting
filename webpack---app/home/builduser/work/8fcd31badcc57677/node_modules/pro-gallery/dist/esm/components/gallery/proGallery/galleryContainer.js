import {
    __assign,
    __extends
} from "tslib";
/* eslint-disable prettier/prettier */
import React from 'react';
import {
    GALLERY_CONSTS,
    window,
    utils,
    isEditMode,
    isSEOMode,
    isPreviewMode,
    isSiteMode,
} from 'pro-gallery-lib';
import {
    ItemsHelper
} from 'pro-layouts';
import GalleryView from './galleryView';
import SlideshowView from './slideshowView';
import {
    scrollToItemImp,
    scrollToGroupImp
} from '../../helpers/scrollHelper';
import ScrollIndicator from './galleryScrollIndicator';
import {
    createCssLayouts
} from '../../helpers/cssLayoutsHelper.js';
import {
    cssScrollHelper
} from '../../helpers/cssScrollHelper.js';
import VideoScrollHelperWrapper from '../../helpers/videoScrollHelperWrapper';
import findNeighborItem from '../../helpers/layoutUtils';
import ImageRenderer from '../../item/imageRenderer';
var GalleryContainer = /** @class */ (function(_super) {
    __extends(GalleryContainer, _super);

    function GalleryContainer(props) {
        var _this = _super.call(this, props) || this;
        _this.findNeighborItem = function(itemIdx, dir) {
            return findNeighborItem(itemIdx, dir, _this.state.structure.items);
        }; // REFACTOR BLUEPRINTS - this makes the function in the layouter irrelevant (unless the layouter is used as a stand alone with this function, maybe the layouter needs to be split for bundle size as well...)
        if (utils.isVerbose()) {
            console.count('[OOISSR] galleryContainer constructor', window.isMock);
        }
        _this.getMoreItemsIfNeeded = _this.getMoreItemsIfNeeded.bind(_this);
        _this.setGotFirstScrollIfNeeded = _this.setGotFirstScrollIfNeeded.bind(_this);
        _this.toggleLoadMoreItems = _this.toggleLoadMoreItems.bind(_this);
        _this.scrollToItem = _this.scrollToItem.bind(_this);
        _this.scrollToGroup = _this.scrollToGroup.bind(_this);
        _this._scrollingElement = _this.getScrollingElement();
        _this.eventsListener = _this.eventsListener.bind(_this);
        _this.onGalleryScroll = _this.onGalleryScroll.bind(_this);
        _this.setPlayingIdxState = _this.setPlayingIdxState.bind(_this);
        _this.getVisibleItems = _this.getVisibleItems.bind(_this);
        _this.findNeighborItem = _this.findNeighborItem.bind(_this);
        _this.setCurrentSlideshowViewIdx =
            _this.setCurrentSlideshowViewIdx.bind(_this);
        _this.getIsScrollLessGallery = _this.getIsScrollLessGallery.bind(_this);
        _this.onMouseEnter = _this.onMouseEnter.bind(_this);
        _this.onMouseLeave = _this.onMouseLeave.bind(_this);
        _this.videoScrollHelper = new VideoScrollHelperWrapper(_this.setPlayingIdxState);
        var initialState = {
            pgScroll: 0,
            showMoreClickedAtLeastOnce: false,
            initialGalleryHeight: undefined,
            needToHandleShowMoreClick: false,
            gotFirstScrollEvent: (props.activeIndex >= 0),
            playingVideoIdx: -1,
            viewComponent: null,
            firstUserInteractionExecuted: false,
            isInHover: false,
        };
        _this.state = initialState;
        _this.layoutCss = [];
        _this.initialGalleryState = {};
        try {
            var galleryState = _this.propsToState(props);
            if (Object.keys(galleryState).length > 0) {
                _this.initialGalleryState = galleryState;
            }
        } catch (_e) {
            console.warn('Cannot create initial state from props', _e);
        }
        _this.state = __assign(__assign({}, initialState), _this.initialGalleryState);
        return _this;
        //not sure if there needs to be a handleNEwGalleryStructure here with the intial state. currently looks like not
    }
    GalleryContainer.prototype.initializeScrollPosition = function() {
        if (this.props.activeIndex > 0) {
            this.scrollToItem(this.props.activeIndex, false, true, 0);
            var currentItem = this.galleryStructure.items[this.props.activeIndex];
            this.onGalleryScroll(currentItem.offset);
        }
    };
    GalleryContainer.prototype.componentDidMount = function() {
        this.initializeScrollPosition();
        this.handleNewGalleryStructure();
        this.eventsListener(GALLERY_CONSTS.events.APP_LOADED, {});
        this.videoScrollHelper.initializePlayState();
        try {
            if (typeof window.CustomEvent === 'function') {
                this.currentHoverChangeEvent = new CustomEvent('current_hover_change');
            } else {
                //IE (new CustomEvent is not supported in IE)
                this.currentHoverChangeEvent =
                    window.document.createEvent('CustomEvent'); // MUST be 'CustomEvent'
                this.currentHoverChangeEvent.initCustomEvent('current_hover_change', false, false, null);
            }
        } catch (e) {
            console.error("could not create 'current_hover_change' customEvent. Error =", e);
        }
        if (this.props.id) {
            this.currentHoverChangeEvent.galleryId = this.props.id;
        }
    };
    GalleryContainer.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
        var _this = this;
        if (!this.currentHoverChangeEvent.galleryId && nextProps.id) {
            this.currentHoverChangeEvent.galleryId = nextProps.id;
        }
        if (this.props.activeIndex !== nextProps.activeIndex &&
            nextProps.activeIndex !== this.currentSlideshowViewIdx) {
            this.scrollToItem(nextProps.activeIndex, false, true, 0);
        }
        var reCreateGallery = function() {
            var galleryState = _this.propsToState(nextProps);
            if (Object.keys(galleryState).length > 0) {
                _this.setState(galleryState, _this.handleNewGalleryStructure);
            }
        };
        var getSignificantProps = function(props) {
            var id = props.id,
                options = props.options,
                container = props.container,
                items = props.items,
                isInDisplay = props.isInDisplay;
            return {
                id: id,
                options: options,
                container: container,
                items: items,
                isInDisplay: isInDisplay
            };
        };
        if (this.reCreateGalleryTimer) {
            clearTimeout(this.reCreateGalleryTimer);
        }
        var hasPropsChanged = true;
        try {
            var currentSignificantProps = getSignificantProps(this.props);
            var nextSignificantProps = getSignificantProps(nextProps);
            hasPropsChanged =
                JSON.stringify(currentSignificantProps) !==
                JSON.stringify(nextSignificantProps);
            if (utils.isVerbose() && hasPropsChanged) {
                console.log('New props arrived', utils.printableObjectsDiff(currentSignificantProps, nextSignificantProps));
            }
        } catch (e) {
            console.error('Cannot compare props', e);
        }
        if (hasPropsChanged) {
            reCreateGallery();
            if (this.props.isInDisplay !== nextProps.isInDisplay) {
                this.handleNavigation(nextProps.isInDisplay);
            }
        } else {
            //this is a hack, because in fullwidth, new props arrive without any changes
            // this.reCreateGalleryTimer = setTimeout(reCreateGallery, 1000);
        }
    };
    GalleryContainer.prototype.handleNavigation = function(isInDisplay) {
        if (isInDisplay) {
            this.videoScrollHelper.trigger.INIT_SCROLL();
        } else {
            this.videoScrollHelper.stop();
        }
    };
    GalleryContainer.prototype.handleNewGalleryStructure = function() {
        //should be called AFTER new state is set
        var _a = this.state,
            container = _a.container,
            needToHandleShowMoreClick = _a.needToHandleShowMoreClick,
            initialGalleryHeight = _a.initialGalleryHeight;
        var options = this.props.options;
        var numOfItems = this.state.items.length;
        var layoutHeight = this.props.structure.height;
        var layoutItems = this.props.structure.items;
        var isInfinite = this.containerInfiniteGrowthDirection() === 'vertical';
        var updatedHeight = false;
        var needToUpdateHeightNotInfinite = !isInfinite && needToHandleShowMoreClick;
        if (needToUpdateHeightNotInfinite) {
            var showMoreContainerHeight = 138; //according to the scss
            updatedHeight =
                container.height + (initialGalleryHeight - showMoreContainerHeight);
        }
        var onGalleryChangeData = {
            numOfItems: numOfItems,
            container: container,
            options: options,
            layoutHeight: layoutHeight,
            layoutItems: layoutItems,
            isInfinite: isInfinite,
            updatedHeight: updatedHeight,
        };
        if (utils.isVerbose()) {
            console.log('handleNewGalleryStructure', onGalleryChangeData);
        }
        this.eventsListener(GALLERY_CONSTS.events.GALLERY_CHANGE, onGalleryChangeData);
        if (needToHandleShowMoreClick) {
            this.setState({
                needToHandleShowMoreClick: false
            });
        }
    };
    GalleryContainer.prototype.isVerticalGallery = function() {
        return (this.state.options.scrollDirection ===
            GALLERY_CONSTS.scrollDirection.VERTICAL);
    };
    GalleryContainer.prototype.getIsScrollLessGallery = function(options) {
        var scrollDirection = options.scrollDirection,
            slideAnimation = options.slideAnimation;
        return (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL &&
            slideAnimation !== GALLERY_CONSTS.slideAnimations.SCROLL);
    };
    GalleryContainer.prototype.getVisibleItems = function(items, container) {
        var gotFirstScrollEvent = this.state.gotFirstScrollEvent;
        var scrollY = window.scrollY;
        var galleryHeight = container.galleryHeight,
            scrollBase = container.scrollBase,
            galleryWidth = container.galleryWidth;
        if (utils.isSSR() ||
            isSEOMode() ||
            isEditMode() ||
            gotFirstScrollEvent ||
            scrollY > 0 ||
            this.props.activeIndex > 0) {
            return items;
        }
        var visibleItems = items;
        try {
            var windowHeight = window.innerHeight;
            var isInfinite = this.isVerticalGallery() &&
                this.containerInfiniteGrowthDirection() === 'vertical';
            var galleryBottom = isInfinite ? Infinity : scrollBase + galleryHeight;
            var windowBottom = scrollY + windowHeight;
            var maxItemTop_1 = Math.min(galleryBottom, windowBottom) - scrollBase;
            if (maxItemTop_1 < 0) {
                //gallery is below the fold
                visibleItems = [];
            } else if (this.isVerticalGallery()) {
                visibleItems = items.filter(function(item) {
                    return item.offset.top < maxItemTop_1;
                });
            } else {
                visibleItems = items.filter(function(item) {
                    return item.left <= galleryWidth + 20;
                });
            }
            if (visibleItems.length < 2 && visibleItems.length < items.length) {
                //dont render less then 2 items (otherwise slide show Arrow will be removed)
                visibleItems = items.slice(0, 2);
            }
        } catch (e) {
            console.error('Could not calculate visible items, returning original items', e);
            visibleItems = items;
        }
        return visibleItems;
    };
    GalleryContainer.prototype.propsToState = function(_a) {
        var items = _a.items,
            options = _a.options,
            structure = _a.structure,
            container = _a.container,
            id = _a.id,
            createMediaUrl = _a.createMediaUrl,
            isPrerenderMode = _a.isPrerenderMode,
            customComponents = _a.customComponents;
        items = items || this.props.items;
        options = options || this.props.options;
        container = container || this.props.container;
        structure = structure || this.props.structure;
        id = id || this.props.id;
        createMediaUrl = createMediaUrl || this.props.createMediaUrl;
        if (typeof customComponents.customImageRenderer === 'function') {
            ImageRenderer.customImageRenderer = customComponents.customImageRenderer;
        }
        this.galleryStructure = ItemsHelper.convertToGalleryItems(structure, {
            // TODO use same objects in the memory when the galleryItems are changed
            thumbnailSize: options.thumbnailSize,
            sharpParams: options.sharpParams,
            createMediaUrl: createMediaUrl,
        });
        // // ------------ TODO. This is using GalleryItem and I am leaving it here for now ---------- //
        var shouldUseScrollCss = !isSEOMode() &&
            (isEditMode() ||
                this.state.gotFirstScrollEvent ||
                this.state.showMoreClickedAtLeastOnce);
        if (shouldUseScrollCss) {
            this.getScrollCss({
                id: id,
                items: this.galleryStructure.galleryItems,
                options: options,
                container: container,
            });
        }
        var scrollHelperNewGalleryStructure = {
            galleryStructure: this.galleryStructure,
            galleryWidth: container.galleryWidth,
            scrollBase: container.scrollBase,
            videoPlay: options.videoPlay,
            videoLoop: options.videoLoop,
            itemClick: options.itemClick,
            scrollDirection: options.scrollDirection,
            cb: this.setPlayingIdxState,
        };
        this.videoScrollHelper.updateGalleryStructure(scrollHelperNewGalleryStructure, !utils.isSSR(), items);
        var layoutParams = {
            items: items,
            container: container,
            styleParams: options,
            gotScrollEvent: true,
            options: {
                showAllItems: true,
                skipVisibilitiesCalc: true,
                useLayoutStore: false,
                createLayoutOnInit: false,
            },
        };
        this.createCssLayoutsIfNeeded(layoutParams);
        this.createDynamicStyles(options, isPrerenderMode);
        var newState = {
            items: items,
            options: options,
            container: container,
            structure: structure,
        };
        return newState;
    };
    GalleryContainer.prototype.getScrollingElement = function() {
        var _this = this;
        var horizontal = function() {
            return window.document.querySelector("#pro-gallery-" + _this.props.id + " #gallery-horizontal-scroll");
        };
        var vertical = this.props.scrollingElement ?
            function() {
                return _this.props.scrollingElement;
            } :
            function() {
                return window;
            };
        return {
            vertical: vertical,
            horizontal: horizontal
        };
    };
    GalleryContainer.prototype.scrollToItem = function(itemIdx, fixedScroll, isManual, durationInMS, scrollMarginCorrection, isContinuousScrolling) {
        if (durationInMS === void 0) {
            durationInMS = 0;
        }
        if (isContinuousScrolling === void 0) {
            isContinuousScrolling = false;
        }
        if (itemIdx >= 0) {
            if (!this.state.gotFirstScrollEvent) {
                this.setState({
                    gotFirstScrollEvent: true,
                });
            }
            if (this.getIsScrollLessGallery(this.state.options)) {
                return;
            }
            var scrollingElement = this._scrollingElement;
            var horizontalElement = scrollingElement.horizontal();
            try {
                var scrollParams = {
                    scrollMarginCorrection: scrollMarginCorrection,
                    isRTL: this.state.options.isRTL,
                    scrollDirection: this.state.options.scrollDirection,
                    galleryWidth: this.state.container.galleryWidth,
                    galleryHeight: this.state.container.galleryHeight,
                    top: 0,
                    items: this.galleryStructure.items,
                    totalWidth: this.galleryStructure.width,
                    itemIdx: itemIdx,
                    fixedScroll: fixedScroll,
                    isManual: isManual,
                    scrollingElement: scrollingElement,
                    horizontalElement: horizontalElement,
                    durationInMS: durationInMS,
                    slideTransition: this.state.options.slideTransition,
                    isContinuousScrolling: isContinuousScrolling,
                    autoSlideshowContinuousSpeed: this.state.options.autoSlideshowContinuousSpeed,
                    imageMargin: this.state.options.imageMargin,
                };
                return scrollToItemImp(scrollParams);
            } catch (e) {
                //added console.error to debug sentry error 'Cannot read property 'isRTL' of undefined in pro-gallery-statics'
                console.error('error:', e, ' pro-gallery, scrollToItem, cannot get scrollParams, ', 'isEditMode =', isEditMode(), ' isPreviewMode =', isPreviewMode(), ' isSiteMode =', isSiteMode(), ' this.state.options =', this.state.options, ' this.state.container =', this.state.container, ' this.galleryStructure =', this.galleryStructure);
            }
        }
    };
    GalleryContainer.prototype.scrollToGroup = function(groupIdx, fixedScroll, isManual, durationInMS, scrollMarginCorrection, isContinuousScrolling) {
        if (durationInMS === void 0) {
            durationInMS = 0;
        }
        if (isContinuousScrolling === void 0) {
            isContinuousScrolling = false;
        }
        if (groupIdx >= 0) {
            var scrollingElement = this._scrollingElement;
            var horizontalElement = scrollingElement.horizontal();
            try {
                var scrollParams = {
                    scrollMarginCorrection: scrollMarginCorrection,
                    isRTL: this.state.options.isRTL,
                    scrollDirection: this.state.options.scrollDirection,
                    galleryWidth: this.state.container.galleryWidth,
                    galleryHeight: this.state.container.galleryHeight,
                    top: 0,
                    groups: this.galleryStructure.groups,
                    totalWidth: this.galleryStructure.width,
                    groupIdx: groupIdx,
                    fixedScroll: fixedScroll,
                    isManual: isManual,
                    scrollingElement: scrollingElement,
                    horizontalElement: horizontalElement,
                    durationInMS: durationInMS,
                    slideTransition: this.state.options.slideTransition,
                    isContinuousScrolling: isContinuousScrolling,
                    autoSlideshowContinuousSpeed: this.state.options.autoSlideshowContinuousSpeed,
                    imageMargin: this.state.options.imageMargin,
                };
                return scrollToGroupImp(scrollParams);
            } catch (e) {
                //added console.error to debug sentry error 'Cannot read property 'isRTL' of undefined in pro-gallery-statics'
                console.error('error:', e, ' pro-gallery, scrollToGroup, cannot get scrollParams, ', 'isEditMode =', isEditMode(), ' isPreviewMode =', isPreviewMode(), ' isSiteMode =', isSiteMode(), ' this.state.options =', this.state.options, ' this.state.container =', this.state.container, ' this.galleryStructure =', this.galleryStructure);
            }
        }
    };
    GalleryContainer.prototype.containerInfiniteGrowthDirection = function(options) {
        if (options === void 0) {
            options = false;
        }
        var _options = options || this.props.options;
        // return the direction in which the gallery can grow on it's own (aka infinite scroll)
        var enableInfiniteScroll = this.props.options.enableInfiniteScroll; //TODO - props or "raw" options
        var showMoreClickedAtLeastOnce = this.state.showMoreClickedAtLeastOnce;
        var scrollDirection = _options.scrollDirection,
            loadMoreAmount = _options.loadMoreAmount;
        if (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL) {
            return 'horizontal';
        } else if (!enableInfiniteScroll) {
            //vertical gallery with showMore button enabled
            if (showMoreClickedAtLeastOnce && loadMoreAmount === 'all') {
                return 'vertical';
            } else {
                return 'none';
            }
        } else {
            return 'vertical';
        }
    };
    GalleryContainer.prototype.setPlayingIdxState = function(playingVideoIdx) {
        this.setState({
            playingVideoIdx: playingVideoIdx,
        });
    };
    GalleryContainer.prototype.onGalleryScroll = function(_a) {
        var top = _a.top,
            left = _a.left;
        this.eventsListener(GALLERY_CONSTS.events.GALLERY_SCROLLED, {
            top: top,
            left: left
        });
        this.videoScrollHelper.trigger.SCROLL({
            top: top,
            left: left,
        });
    };
    GalleryContainer.prototype.createDynamicStyles = function(_a, isPrerenderMode) {
        var overlayBackground = _a.overlayBackground;
        var useSSROpacity = isPrerenderMode && !this.props.settings.disableSSROpacity;
        this.dynamicStyles = ("\n      " + (!useSSROpacity ?
            '' :
            "#pro-gallery-" + this.props.id + " .gallery-item-container { opacity: 0 }") + "\n      " + (!overlayBackground ?
            '' :
            "#pro-gallery-" + this.props.id + " .gallery-item-hover::before { background: " + overlayBackground + " !important}") + "\n    ").trim();
    };
    GalleryContainer.prototype.createCssLayoutsIfNeeded = function(layoutParams) {
        var _a = this.props.settings,
            settings = _a === void 0 ? {} : _a;
        var avoidInlineStyles = settings.avoidInlineStyles;
        if (avoidInlineStyles) {
            this.layoutCss = createCssLayouts({
                layoutParams: layoutParams,
                isMobile: utils.isMobile(),
                id: this.props.id,
                galleryItems: this.galleryStructure.galleryItems,
            });
        }
    };
    GalleryContainer.prototype.getScrollCss = function(_a) {
        var id = _a.id,
            items = _a.items,
            options = _a.options,
            container = _a.container;
        this.scrollCss = cssScrollHelper.calcScrollCss({
            items: items,
            options: options,
            id: id,
            container: container,
        });
    };
    GalleryContainer.prototype.toggleLoadMoreItems = function() {
        var _this = this;
        this.eventsListener(GALLERY_CONSTS.events.LOAD_MORE_CLICKED, this.galleryStructure.galleryItems);
        var showMoreClickedAtLeastOnce = true;
        var needToHandleShowMoreClick = true;
        //before clicking "load more" at the first time
        if (!this.state.showMoreClickedAtLeastOnce) {
            this.getScrollCss({
                id: this.props.id,
                items: this.galleryStructure.galleryItems,
                options: this.state.options,
                container: this.state.container,
            });
            var initialGalleryHeight = this.state.container.height; //container.height before clicking "load more" at the first time
            this.setState({
                showMoreClickedAtLeastOnce: showMoreClickedAtLeastOnce,
                initialGalleryHeight: initialGalleryHeight,
                needToHandleShowMoreClick: needToHandleShowMoreClick,
            }, function() {
                _this.handleNewGalleryStructure();
            });
        } else {
            //from second click
            this.setState({
                needToHandleShowMoreClick: needToHandleShowMoreClick,
            }, function() {
                _this.handleNewGalleryStructure();
            });
        }
    };
    GalleryContainer.prototype.setGotFirstScrollIfNeeded = function() {
        if (!this.state.gotFirstScrollEvent) {
            this.getScrollCss({
                id: this.props.id,
                items: this.galleryStructure.galleryItems,
                options: this.state.options,
                container: this.state.container,
            });
            this.setState({
                gotFirstScrollEvent: true,
            });
        }
    };
    GalleryContainer.prototype.setCurrentSlideshowViewIdx = function(idx) {
        this.currentSlideshowViewIdx = idx;
    };
    GalleryContainer.prototype.simulateScrollToItem = function(item) {
        (item === null || item === void 0 ? void 0 : item.offset) && this.onGalleryScroll(item.offset);
    };
    GalleryContainer.prototype.eventsListener = function(eventName, eventData, event) {
        this.videoScrollHelper.handleEvent({
            eventName: eventName,
            eventData: eventData,
        });
        if (eventName === GALLERY_CONSTS.events.HOVER_SET) {
            this.currentHoverChangeEvent.currentHoverIdx = eventData;
            window.dispatchEvent(this.currentHoverChangeEvent);
        }
        if (eventName === GALLERY_CONSTS.events.CURRENT_ITEM_CHANGED) {
            this.setCurrentSlideshowViewIdx(eventData.idx);
            if (this.getIsScrollLessGallery(this.state.options)) {
                this.simulateScrollToItem(this.galleryStructure.items[eventData.idx]);
            }
        }
        if (!this.state.firstUserInteractionExecuted) {
            switch (eventName) {
                case GALLERY_CONSTS.events.HOVER_SET:
                case GALLERY_CONSTS.events.LOAD_MORE_CLICKED:
                case GALLERY_CONSTS.events.ITEM_ACTION_TRIGGERED:
                    this.setState({
                        firstUserInteractionExecuted: true
                    });
                    break;
            }
        }
        if (typeof this.props.eventsListener === 'function') {
            this.props.eventsListener(eventName, eventData, event);
        }
    };
    GalleryContainer.prototype.getMoreItemsIfNeeded = function(scrollPos) {
        var _this = this;
        if (this.galleryStructure &&
            this.galleryStructure.galleryItems &&
            this.galleryStructure.galleryItems.length > 0 &&
            !this.gettingMoreItems &&
            this.state.items &&
            this.state.options &&
            this.state.container) {
            //more items can be fetched from the server
            //TODO - add support for horizontal galleries
            var _a = this.state.options,
                scrollDirection = _a.scrollDirection,
                isRTL = _a.isRTL;
            var galleryEnd = this.galleryStructure[scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL ?
                    'width' :
                    'height'] +
                (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL ?
                    0 :
                    this.state.container.scrollBase);
            var screenSize = window.screen[scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL ?
                'width' :
                'height'];
            var scrollEnd = scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL && isRTL ?
                scrollPos - galleryEnd + screenSize :
                scrollPos + screenSize;
            var getItemsDistance = scrollPos ? 3 * screenSize : 0; //first scrollPos is 0 falsy. dont load before a scroll happened.
            if (galleryEnd < getItemsDistance + scrollEnd) {
                //only when the last item turns visible we should try getting more items
                this.gettingMoreItems = true;
                this.eventsListener(GALLERY_CONSTS.events.NEED_MORE_ITEMS, this.state.items.length);
                setTimeout(function() {
                    //wait a bit before allowing more items to be fetched - ugly hack before promises still not working
                    _this.gettingMoreItems = false;
                }, 2000);
            }
        }
    };
    GalleryContainer.prototype.canRender = function() {
        var can = this.props.container && this.props.options && this.state.items;
        if (!can && utils.isVerbose()) {
            console.log('PROGALLERY [CAN_RENDER] GalleryContainer', can, this.props.container, this.props.options, this.state.items);
        }
        return can;
    };
    GalleryContainer.prototype.onMouseEnter = function() {
        this.setState({
            isInHover: true
        });
    };
    GalleryContainer.prototype.onMouseLeave = function() {
        this.setState({
            isInHover: false
        });
    };
    GalleryContainer.prototype.render = function() {
        var _this = this;
        var _a;
        if (!this.canRender()) {
            return null;
        }
        var ViewComponent = this.props.options.scrollDirection ===
            GALLERY_CONSTS.scrollDirection.HORIZONTAL ?
            SlideshowView :
            GalleryView;
        if (utils.isVerbose()) {
            console.count('PROGALLERY [COUNTS] - GalleryContainer (render)');
            console.log('PROGALLERY [RENDER] - GalleryContainer', this.props.container.scrollBase, {
                props: this.props,
                items: this.state.items
            });
        }
        var displayShowMore = this.containerInfiniteGrowthDirection() === 'none';
        return (React.createElement("div", {
                "data-key": "pro-gallery-inner-container",
                key: "pro-gallery-inner-container",
                className: this.props.isPrerenderMode ? 'pro-gallery-prerender' : '',
                onMouseEnter: this.onMouseEnter,
                onMouseLeave: this.onMouseLeave,
                ref: function(e) {
                    return _this.galleryContainerRef = e;
                },
                tabIndex: -1
            },
            React.createElement(ScrollIndicator, {
                id: this.props.id,
                scrollDirection: this.props.options.scrollDirection,
                isRTL: this.props.options.isRTL,
                totalWidth: this.galleryStructure.width,
                scrollBase: this.props.container.scrollBase,
                scrollingElement: this._scrollingElement,
                getMoreItemsIfNeeded: this.getMoreItemsIfNeeded,
                setGotFirstScrollIfNeeded: this.setGotFirstScrollIfNeeded,
                onScroll: this.onGalleryScroll
            }),
            React.createElement(ViewComponent, __assign({
                isInDisplay: this.props.isInDisplay,
                isPrerenderMode: this.props.isPrerenderMode,
                scrollingElement: this._scrollingElement,
                totalItemsCount: this.props.totalItemsCount,
                renderedItemsCount: this.props.renderedItemsCount,
                getMoreItemsIfNeeded: this.getMoreItemsIfNeeded,
                gotFirstScrollEvent: this.state.gotFirstScrollEvent,
                setGotFirstScrollIfNeeded: this.setGotFirstScrollIfNeeded,
                items: this.state.items,
                getVisibleItems: this.getVisibleItems,
                galleryStructure: this.galleryStructure,
                options: this.props.options,
                container: this.props.container,
                settings: this.props.settings,
                displayShowMore: displayShowMore,
                id: this.props.id,
                activeIndex: this.props.activeIndex || 0,
                customComponents: this.props.customComponents,
                playingVideoIdx: this.state.playingVideoIdx,
                noFollowForSEO: this.props.noFollowForSEO,
                proGalleryRegionLabel: this.props.proGalleryRegionLabel,
                proGalleryRole: this.props.proGalleryRole,
                firstUserInteractionExecuted: this.state.firstUserInteractionExecuted,
                isGalleryInHover: this.state.isInHover,
                enableExperimentalFeatures: this.props.enableExperimentalFeatures,
                galleryContainerRef: this.galleryContainerRef,
                outOfViewComponent: this.outOfViewComponent,
                galleryContainerId: "pro-gallery-container-" + this.props.id,
                actions: __assign(__assign({}, this.props.actions), {
                    findNeighborItem: this.findNeighborItem,
                    toggleLoadMoreItems: this.toggleLoadMoreItems,
                    eventsListener: this.eventsListener,
                    setWixHeight: function() {},
                    scrollToItem: this.scrollToItem,
                    scrollToGroup: this.scrollToGroup
                })
            }, this.props.gallery)),
            React.createElement("div", {
                    "data-key": "items-styles",
                    key: "items-styles",
                    style: {
                        display: 'none'
                    }
                },
                (this.layoutCss || []).filter(Boolean).map(function(css, idx) {
                    return (React.createElement("style", {
                        id: "layoutCss-" + idx,
                        key: "layoutCss-" + idx,
                        dangerouslySetInnerHTML: {
                            __html: css
                        }
                    }));
                }),
                (this.scrollCss || []).filter(Boolean).map(function(css, idx) {
                    return (React.createElement("style", {
                        id: "scrollCss_" + idx,
                        key: "scrollCss_" + idx,
                        dangerouslySetInnerHTML: {
                            __html: css
                        }
                    }));
                }), !!this.dynamicStyles && (React.createElement("style", {
                    dangerouslySetInnerHTML: {
                        __html: this.dynamicStyles
                    }
                }))),
            this.props.proGalleryRole === 'application' && (React.createElement("span", {
                ref: function(e) {
                    return _this.outOfViewComponent = e;
                },
                tabIndex: -1,
                className: "sr-only out-of-view-component"
            }, (_a = this.props.translations) === null || _a === void 0 ? void 0 : _a.Accessibility_Left_Gallery))));
    };
    return GalleryContainer;
}(React.Component));
export {
    GalleryContainer
};
export default GalleryContainer;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=galleryContainer.js.map