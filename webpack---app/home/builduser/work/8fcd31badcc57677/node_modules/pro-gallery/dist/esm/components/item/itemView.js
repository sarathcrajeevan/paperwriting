import {
    __assign,
    __extends,
    __rest
} from "tslib";
/* eslint-disable prettier/prettier */
import React from 'react';
import {
    GALLERY_CONSTS,
    featureManager,
    window,
    utils,
    isEditMode,
    isPreviewMode
} from 'pro-gallery-lib';
import MagnifiedImage from './imageWithMagnified.js';
import TextItem from './textItem.js';
import ItemHover from './itemHover.js';
import {
    changeActiveElementIfNeeded,
    onAnchorFocus
} from './itemHelper.js';
import {
    cssScrollHelper
} from '../helpers/cssScrollHelper';
import {
    getOuterInfoStyle,
    getInnerInfoStyle,
    getContainerStyle,
    getImageStyle,
} from './itemViewStyleProvider';
import VideoItemWrapper from './videos/videoItemWrapper';
import {
    getSlideAnimationStyles,
    getCustomInfoRendererProps,
    getLinkParams
} from './pure';
import {
    extractTextItemContent
} from './itemHelper';
var ItemView = /** @class */ (function(_super) {
    __extends(ItemView, _super);

    function ItemView(props) {
        var _this = _super.call(this, props) || this;
        _this.shouldUseDirectLink = function() {
            var directLink = _this.props.directLink;
            var _a = directLink || {},
                url = _a.url,
                target = _a.target;
            var useDirectLink = !!(url &&
                target &&
                _this.props.options.itemClick === 'link');
            var shouldUseDirectLinkOnMobile = _this.shouldShowHoverOnMobile() &&
                _this.isClickOnCurrentHoveredItem() &&
                useDirectLink;
            if (shouldUseDirectLinkOnMobile) {
                _this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
                return true;
            }
            if (useDirectLink && !_this.shouldShowHoverOnMobile()) {
                return true;
            }
            return false;
        };
        _this.isClickOnCurrentHoveredItem = function() {
            return _this.state.isCurrentHover || // this single item was already hovered.
                _this.props.options.hoveringBehaviour ===
                GALLERY_CONSTS.infoBehaviourOnHover.NO_CHANGE;
        }; // all the items are always 'already' hovered
        _this.props.actions.eventsListener(GALLERY_CONSTS.events.ITEM_CREATED, _this.props);
        _this.init();
        _this.state = {
            isCurrentHover: false,
            itemWasHovered: false,
            ariaLabel: '',
        };
        _this.activeElement = '';
        return _this;
    }
    //-------------------------------------------| INIT |--------------------------------------------//
    ItemView.prototype.init = function() {
        this.onItemClick = this.onItemClick.bind(this);
        this.getSlideshowItemInner = this.getSlideshowItemInner.bind(this);
        this.onItemWrapperClick = this.onItemWrapperClick.bind(this);
        this.onItemInfoClick = this.onItemInfoClick.bind(this);
        this.onContainerKeyDown = this.onContainerKeyDown.bind(this);
        this.onAnchorKeyDown = this.onAnchorKeyDown.bind(this);
        this.handleItemMouseDown = this.handleItemMouseDown.bind(this);
        this.handleItemMouseUp = this.handleItemMouseUp.bind(this);
        this.setItemLoaded = this.setItemLoaded.bind(this);
        this.isHighlight = this.isHighlight.bind(this);
        this.getItemHover = this.getItemHover.bind(this);
        this.getImageItem = this.getImageItem.bind(this);
        this.getVideoItem = this.getVideoItem.bind(this);
        this.getTextItem = this.getTextItem.bind(this);
        this.getItemInner = this.getItemInner.bind(this);
        this.getItemContainerStyles = this.getItemContainerStyles.bind(this);
        this.getItemWrapperStyles = this.getItemWrapperStyles.bind(this);
        this.getItemAriaLabel = this.getItemAriaLabel.bind(this);
        this.getItemContainerClass = this.getItemContainerClass.bind(this);
        this.getItemWrapperClass = this.getItemWrapperClass.bind(this);
        this.getItemContainerTabIndex = this.getItemContainerTabIndex.bind(this);
        this.isIconTag = this.isIconTag.bind(this);
        this.onMouseOver = this.onMouseOver.bind(this);
        this.onMouseOut = this.onMouseOut.bind(this);
        this.onFocus = this.onFocus.bind(this);
        this.onBlur = this.onBlur.bind(this);
        this.checkIfCurrentHoverChanged =
            this.checkIfCurrentHoverChanged.bind(this);
    };
    //----------------------------------------| ACTIONS |-------------------------------------------//
    ItemView.prototype.setItemLoaded = function() {
        this.props.actions.eventsListener(GALLERY_CONSTS.events.ITEM_LOADED, this.props);
        this.setState({
            loaded: true,
        });
    };
    ItemView.prototype.isIconTag = function(tagName) {
        return (['button', 'i', 'a', 'svg', 'path'].indexOf(tagName.toLowerCase()) >= 0);
    };
    ItemView.prototype.onMouseOver = function() {
        if (!utils.isMobile()) {
            this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, this.props.idx);
        }
    };
    ItemView.prototype.onMouseOut = function() {
        if (!utils.isMobile()) {
            this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
        }
    };
    ItemView.prototype.onFocus = function() {
        var _a;
        if ((_a = this.props.settings) === null || _a === void 0 ? void 0 : _a.isAccessible) {
            this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, this.props.idx);
        }
        this.props.actions.eventsListener(GALLERY_CONSTS.events.ITEM_FOCUSED, this.props);
    };
    ItemView.prototype.onBlur = function() {
        var _a;
        if ((_a = this.props.settings) === null || _a === void 0 ? void 0 : _a.isAccessible) {
            this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
        }
        this.props.actions.eventsListener(GALLERY_CONSTS.events.ITEM_LOST_FOCUS, this.props);
    };
    ItemView.prototype.onContainerKeyDown = function(e) {
        var clickTarget = 'item-container';
        switch (e.keyCode || e.charCode) {
            case 32: //space
            case 13: //enter
                e.stopPropagation();
                this.onItemClick(e, clickTarget, false); //pressing enter or space always behaves as click on main image, even if the click is on a thumbnail
                if (this.shouldUseDirectLink()) {
                    this.itemAnchor.click(); // when directLink, we want to simulate the 'enter' or 'space' press on an <a> element
                }
                return false;
            default:
                return true;
        }
    };
    ItemView.prototype.onAnchorKeyDown = function(e) {
        // Similar to "onContainerKeyDown()" expect 'shouldUseDirectLink()' part, because we are already on the <a> tag (this.itemAnchor)
        var clickTarget = 'item-container';
        switch (e.keyCode || e.charCode) {
            case 32: //space
            case 13: //enter
                e.stopPropagation();
                this.onItemClick(e, clickTarget, false); //pressing enter or space always behaves as click on main image, even if the click is on a thumbnail
                return false;
            default:
                return true;
        }
    };
    ItemView.prototype.handleGalleryItemAction = function(e) {
        this.props.actions.eventsListener(GALLERY_CONSTS.events.ITEM_ACTION_TRIGGERED, this.props, e);
    };
    ItemView.prototype.onItemWrapperClick = function(e) {
        var clickTarget = 'item-media';
        this.onItemClick(e, clickTarget);
    };
    ItemView.prototype.onItemInfoClick = function(e) {
        var clickTarget = 'item-info';
        this.onItemClick(e, clickTarget);
    };
    ItemView.prototype.onItemClick = function(e, clickTarget, shouldPreventDefault) {
        if (shouldPreventDefault === void 0) {
            shouldPreventDefault = true;
        }
        if (utils.isFunction(utils.get(window, 'galleryWixCodeApi.onItemClicked'))) {
            window.galleryWixCodeApi.onItemClicked(this.props); //TODO remove after OOI is fully integrated
        }
        this.props.actions.eventsListener(GALLERY_CONSTS.events.ITEM_CLICKED, __assign(__assign({}, this.props), {
            clickTarget: clickTarget
        }), e);
        if (this.shouldUseDirectLink()) {
            return;
        }
        if (shouldPreventDefault) {
            e.preventDefault();
        }
        if (this.shouldShowHoverOnMobile()) {
            this.handleHoverClickOnMobile(e);
        } else {
            this.handleGalleryItemAction(e);
        }
    };
    ItemView.prototype.handleHoverClickOnMobile = function(e) {
        if (this.isClickOnCurrentHoveredItem()) {
            this.handleGalleryItemAction(e);
            this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
        } else {
            this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, this.props.idx);
        }
    };
    ItemView.prototype.handleItemMouseDown = function() {
        //check for long press
        // if (utils.isMobile()) {
        //   clearTimeout(this.longPressTimer);
        //   this.longPressTimer = setTimeout(() => {
        //     e.preventDefault(); //prevent default only after a long press (so that scroll will not break)
        //     //do something
        //   }, 500);
        // }
        return true; //make sure the default event behaviour continues
    };
    ItemView.prototype.handleItemMouseUp = function() {
        if (utils.isMobile() && this.longPressTimer) {
            clearTimeout(this.longPressTimer);
        }
        return true; //make sure the default event behaviour continues
    };
    //-----------------------------------------| UTILS |--------------------------------------------//
    ItemView.prototype.shouldShowHoverOnMobile = function() {
        if (utils.isMobile()) {
            var _a = this.props.options,
                titlePlacement = _a.titlePlacement,
                hoveringBehaviour = _a.hoveringBehaviour,
                itemClick = _a.itemClick,
                alwaysShowHover = _a.alwaysShowHover,
                previewHover = _a.previewHover,
                allowDescription = _a.allowDescription,
                allowTitle = _a.allowTitle,
                isStoreGallery = _a.isStoreGallery;
            var isNewMobileSettings = featureManager.supports.mobileSettings;
            if (hoveringBehaviour === GALLERY_CONSTS.infoBehaviourOnHover.NEVER_SHOW) {
                return false;
            }
            if (itemClick === 'nothing' && this.props.type !== 'video') {
                return true;
            } else if (this.props.customComponents.customHoverRenderer &&
                GALLERY_CONSTS.hasHoverPlacement(titlePlacement) &&
                hoveringBehaviour !== GALLERY_CONSTS.infoBehaviourOnHover.NEVER_SHOW &&
                isNewMobileSettings &&
                (allowDescription || allowTitle || isStoreGallery)) {
                return true;
            }
            if (alwaysShowHover) {
                return true;
            }
            if (isEditMode() && previewHover) {
                return true;
            }
        }
        return false;
    };
    ItemView.prototype.isHighlight = function() {
        return (this.props.thumbnailHighlightId &&
            this.props.thumbnailHighlightId === this.props.id);
    };
    ItemView.prototype.shouldHover = function() {
        //see if this could be decided in the preset
        var options = this.props.options;
        var alwaysShowHover = options.alwaysShowHover,
            previewHover = options.previewHover,
            hoveringBehaviour = options.hoveringBehaviour,
            overlayAnimation = options.overlayAnimation;
        var _a = GALLERY_CONSTS.infoBehaviourOnHover,
            NEVER_SHOW = _a.NEVER_SHOW,
            APPEARS = _a.APPEARS;
        var NO_EFFECT = GALLERY_CONSTS.overlayAnimations.NO_EFFECT;
        if (hoveringBehaviour === NEVER_SHOW) {
            return false;
        } else if (alwaysShowHover === true) {
            return true;
        } else if (isEditMode() && previewHover) {
            return true;
        } else if (hoveringBehaviour === APPEARS &&
            overlayAnimation === NO_EFFECT &&
            !this.state.itemWasHovered) {
            //when there is no overlayAnimation, we want to render the itemHover only on first hover and on (and not before)
            //when there is a specific overlayAnimation, to support the animation we should render the itemHover before any hover activity.
            return false;
        } else if (utils.isMobile()) {
            return this.shouldShowHoverOnMobile();
        } else {
            return true;
        }
    };
    //---------------------------------------| COMPONENTS |-----------------------------------------//
    ItemView.prototype.getItemHover = function(imageDimensions) {
        var _this = this;
        var _a = this.props,
            customComponents = _a.customComponents,
            props = __rest(_a, ["customComponents"]);
        var shouldHover = this.shouldHover();
        return (shouldHover && (React.createElement(ItemHover, __assign({}, props, {
            forceShowHover: this.simulateOverlayHover(),
            imageDimensions: imageDimensions,
            itemWasHovered: this.state.itemWasHovered,
            key: "hover",
            actions: {
                handleItemMouseDown: this.handleItemMouseDown,
                handleItemMouseUp: this.handleItemMouseUp,
            },
            renderCustomInfo: customComponents.customHoverRenderer ?
                function() {
                    return customComponents.customHoverRenderer(getCustomInfoRendererProps(_this.props));
                } :
                null
        }))));
    };
    ItemView.prototype.getImageItem = function(imageDimensions) {
        var props = utils.pick(this.props, [
            'gotFirstScrollEvent',
            'calculatedAlt',
            'title',
            'description',
            'id',
            'idx',
            'options',
            'createUrl',
            'createMagnifiedUrl',
            'settings',
            'isPrerenderMode',
            'isTransparent',
            'style',
        ]);
        return (React.createElement(MagnifiedImage, __assign({}, props, {
            key: "imageItem",
            imageDimensions: imageDimensions,
            isThumbnail: !!this.props.thumbnailHighlightId,
            actions: {
                handleItemMouseDown: this.handleItemMouseDown,
                handleItemMouseUp: this.handleItemMouseUp,
                setItemLoaded: this.setItemLoaded,
            }
        })));
    };
    ItemView.prototype.getVideoItem = function(imageDimensions, itemHover) {
        return (React.createElement(VideoItemWrapper, __assign({}, this.props, {
            shouldPlay: this.props.idx === this.props.playingVideoIdx,
            key: 'video' + this.props.idx,
            hover: itemHover,
            imageDimensions: imageDimensions,
            hasLink: this.itemHasLink(),
            actions: __assign(__assign({}, this.props.actions), {
                setItemLoaded: this.setItemLoaded,
                handleItemMouseDown: this.handleItemMouseDown,
                handleItemMouseUp: this.handleItemMouseUp
            })
        })));
    };
    ItemView.prototype.getTextItem = function(imageDimensions) {
        var props = utils.pick(this.props, [
            'id',
            'options',
            'style',
            'html',
            'cropRatio',
            'isPrerenderMode',
        ]);
        return (React.createElement(TextItem, __assign({}, props, {
            key: "textItem",
            imageDimensions: imageDimensions,
            actions: {
                handleItemMouseDown: this.handleItemMouseDown,
                handleItemMouseUp: this.handleItemMouseUp,
                setItemLoaded: this.setItemLoaded,
            }
        })));
    };
    ItemView.prototype.getItemInner = function() {
        var _a = this.props,
            options = _a.options,
            type = _a.type,
            style = _a.style,
            offset = _a.offset;
        var itemInner;
        var width = style.width,
            height = style.height,
            innerWidth = style.innerWidth,
            innerHeight = style.innerHeight;
        var innerTop = offset.innerTop,
            innerLeft = offset.innerLeft;
        var itemStyles = {
            width: innerWidth,
            height: innerHeight,
            marginTop: innerTop,
            marginLeft: innerLeft
        };
        var itemHover = null;
        var isSlideshow = GALLERY_CONSTS.isLayout('SLIDESHOW')(options);
        if (this.shouldHover() || isSlideshow) {
            itemHover = this.getItemHover(itemStyles);
        }
        switch (type) {
            case 'dummy':
                itemInner = React.createElement("div", null);
                break;
            case 'video':
                itemInner = this.getVideoItem(itemStyles, itemHover);
                break;
            case 'text':
                itemInner = [this.getTextItem(itemStyles), itemHover];
                break;
            case 'image':
            case 'picture':
            default:
                if (this.props.isVideoPlaceholder) {
                    itemInner = this.getVideoItem(itemStyles, itemHover);
                } else {
                    itemInner = [this.getImageItem(itemStyles), itemHover];
                }
        }
        if (isSlideshow) {
            return this.getSlideshowItemInner({
                options: options,
                width: width,
                height: height,
                itemInner: itemInner,
                customComponents: this.props.customComponents
            });
        }
        return itemInner;
    };
    ItemView.prototype.getSlideshowItemInner = function(_a) {
        var _this = this;
        var options = _a.options,
            width = _a.width,
            height = _a.height,
            itemInner = _a.itemInner,
            customComponents = _a.customComponents,
            photoId = _a.photoId,
            id = _a.id;
        var customSlideshowInfoRenderer = customComponents.customSlideshowInfoRenderer;
        var slideAnimationStyles = getSlideAnimationStyles(this.props);
        var infoStyle = __assign(__assign({
            height: options.slideshowInfoSize + "px",
            bottom: "-" + options.slideshowInfoSize + "px"
        }, slideAnimationStyles), {
            transition: 'none'
        });
        var slideshowInfo = customSlideshowInfoRenderer ?
            customSlideshowInfoRenderer(getCustomInfoRendererProps(this.props)) :
            null;
        var idx = this.props.idx;
        return (React.createElement("div", null,
            React.createElement("a", __assign({
                ref: function(e) {
                    return (_this.itemAnchor = e);
                },
                "data-id": photoId,
                "data-idx": idx,
                key: 'item-container-link-' + id
            }, getLinkParams(this.props), {
                tabIndex: -1,
                style: __assign(__assign({}, slideAnimationStyles), {
                    width: width,
                    height: height
                })
            }), itemInner),
            React.createElement("div", {
                className: "gallery-slideshow-info",
                "data-hook": "gallery-slideshow-info-buttons",
                style: infoStyle
            }, slideshowInfo)));
    };
    ItemView.prototype.getRightInfoElementIfNeeded = function() {
        if (GALLERY_CONSTS.hasExternalRightPlacement(this.props.options.titlePlacement, this.props.idx)) {
            return this.getExternalInfoElement(GALLERY_CONSTS.placements.SHOW_ON_THE_RIGHT, 'gallery-item-right-info');
        } else {
            return null;
        }
    };
    ItemView.prototype.getLeftInfoElementIfNeeded = function() {
        if (GALLERY_CONSTS.hasExternalLeftPlacement(this.props.options.titlePlacement, this.props.idx)) {
            return this.getExternalInfoElement(GALLERY_CONSTS.placements.SHOW_ON_THE_LEFT, 'gallery-item-left-info');
        } else {
            return null;
        }
    };
    ItemView.prototype.getBottomInfoElementIfNeeded = function() {
        if (GALLERY_CONSTS.hasExternalBelowPlacement(this.props.options.titlePlacement, this.props.idx)) {
            return this.getExternalInfoElement(GALLERY_CONSTS.placements.SHOW_BELOW, 'gallery-item-bottom-info');
        } else {
            return null;
        }
    };
    ItemView.prototype.getTopInfoElementIfNeeded = function() {
        if (GALLERY_CONSTS.hasExternalAbovePlacement(this.props.options.titlePlacement, this.props.idx)) {
            return this.getExternalInfoElement(GALLERY_CONSTS.placements.SHOW_ABOVE, 'gallery-item-top-info');
        } else {
            return null;
        }
    };
    ItemView.prototype.getExternalInfoElement = function(placement, elementName) {
        var _a = this.props,
            options = _a.options,
            customComponents = _a.customComponents,
            style = _a.style;
        if (!customComponents.customInfoRenderer) {
            return null;
        }
        var info = null;
        //if there is no url for videos and images, we will not render the itemWrapper
        //but will render the info element if exists, with the whole size of the item
        var infoHeight = options.textBoxHeight + (this.hasRequiredMediaUrl ? 0 : style.height);
        var infoWidth = style.infoWidth + (this.hasRequiredMediaUrl ? 0 : style.width);
        var itemExternalInfo = customComponents.customInfoRenderer(getCustomInfoRendererProps(this.props), placement);
        info = (React.createElement("div", {
                style: getOuterInfoStyle(placement, options, style.height, options.textBoxHeight)
            },
            React.createElement("div", {
                style: getInnerInfoStyle(placement, options, infoHeight, infoWidth),
                className: 'gallery-item-common-info ' + elementName,
                onClick: this.onItemInfoClick
            }, itemExternalInfo)));
        return info;
    };
    ItemView.prototype.simulateHover = function() {
        return (this.state.isCurrentHover ||
            this.props.options.alwaysShowHover === true ||
            (isEditMode() && this.props.options.previewHover));
    };
    ItemView.prototype.simulateOverlayHover = function() {
        return (this.simulateHover() ||
            this.props.options.hoveringBehaviour ===
            GALLERY_CONSTS.infoBehaviourOnHover.NO_CHANGE);
    };
    ItemView.prototype.itemHasLink = function() {
        var _a = this.props,
            linkData = _a.linkData,
            linkUrl = _a.linkUrl;
        var itemDoesntHaveLink = linkData.type === undefined && (linkUrl === undefined || linkUrl === ''); //when itemClick is 'link' but no link was added to this specific item
        return !itemDoesntHaveLink;
    };
    ItemView.prototype.getItemContainerStyles = function() {
        var _a = this.props,
            idx = _a.idx,
            activeIndex = _a.activeIndex,
            offset = _a.offset,
            style = _a.style,
            options = _a.options,
            _b = _a.settings,
            settings = _b === void 0 ? {} : _b;
        var scrollDirection = options.scrollDirection,
            imageMargin = options.imageMargin,
            itemClick = options.itemClick,
            isRTL = options.isRTL,
            slideAnimation = options.slideAnimation;
        var containerStyleByoptions = getContainerStyle(options);
        var itemDoesntHaveLink = !this.itemHasLink(); //when itemClick is 'link' but no link was added to this specific item
        var isSlideshow = GALLERY_CONSTS.isLayout('SLIDESHOW')(this.props.options);
        var itemStyles = {
            overflowY: isSlideshow ? 'visible' : 'hidden',
            position: 'absolute',
            bottom: 'auto',
            margin: scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL ?
                imageMargin / 2 + 'px' :
                0,
            cursor: itemClick === GALLERY_CONSTS.itemClick.NOTHING ||
                (itemClick === GALLERY_CONSTS.itemClick.LINK && itemDoesntHaveLink) ?
                'default' :
                'pointer',
        };
        var avoidInlineStyles = settings.avoidInlineStyles;
        var hideOnSSR = this.props.isPrerenderMode && !this.props.settings.disableSSROpacity;
        var opacityStyles = avoidInlineStyles ?
            {} :
            {
                opacity: hideOnSSR ? 0 : 1,
                display: hideOnSSR ? 'none' : 'block',
                transition: 'opacity .2s ease',
            };
        var layoutStyles = avoidInlineStyles ?
            {} :
            {
                top: offset.top,
                left: isRTL ? 'auto' : offset.left,
                right: !isRTL ? 'auto' : offset.left,
                width: style.width + style.infoWidth,
                height: style.height + style.infoHeight,
            };
        var slideAnimationStyles;
        switch (slideAnimation) {
            case GALLERY_CONSTS.slideAnimations.FADE:
                slideAnimationStyles = {
                    left: isRTL ? 'auto' : 0,
                    right: !isRTL ? 'auto' : 0,
                    pointerEvents: activeIndex === idx ? 'auto' : 'none',
                    zIndex: activeIndex === idx ? 0 : 1,
                };
                break;
            case GALLERY_CONSTS.slideAnimations.DECK:
                slideAnimationStyles = {
                    left: isRTL ? 'auto' : 0,
                    right: !isRTL ? 'auto' : 0,
                    pointerEvents: activeIndex === idx ? 'auto' : 'none',
                    zIndex: Math.sign(activeIndex - idx),
                };
                break;
            default:
                slideAnimationStyles = {};
        }
        var transitionStyles = this.state.loaded && (isEditMode() || isPreviewMode()) ?
            {
                transition: 'all .4s ease',
                transitionProperty: 'top, left, width, height, opacity',
            } :
            {
                transition: 'none',
            };
        var itemContainerStyles = __assign(__assign(__assign(__assign(__assign(__assign({}, itemStyles), layoutStyles), containerStyleByoptions), transitionStyles), opacityStyles), slideAnimationStyles);
        return itemContainerStyles;
    };
    ItemView.prototype.getItemWrapperStyles = function() {
        var _a = this.props,
            options = _a.options,
            style = _a.style,
            type = _a.type;
        var height = style.height,
            width = style.width;
        var styles = {};
        if (type === 'text') {
            styles.backgroundColor =
                options.cubeType !== 'fit' ? 'transparent' : 'inherit';
        } else {
            styles.backgroundColor =
                (options.cubeType !== 'fit' ? style.bgColor : 'inherit') ||
                'transparent';
        }
        styles.height = height + 'px';
        styles.width = width + 'px';
        styles.margin = -options.itemBorderWidth + 'px';
        var isSlideshow = GALLERY_CONSTS.isLayout('SLIDESHOW')(options);
        var itemWrapperStyles = __assign(__assign({}, styles), (!isSlideshow && getSlideAnimationStyles(this.props)));
        return itemWrapperStyles;
    };
    ItemView.prototype.getItemAriaLabel = function() {
        var _a = this.props,
            type = _a.type,
            alt = _a.alt,
            options = _a.options;
        var mapTypeToLabel = {
            'dummy': '',
            'text': extractTextItemContent(this.props.html),
            'video': alt || 'Untitled video',
        };
        var label = mapTypeToLabel[type] || alt || 'Untitled image';
        return label + (options.isStoreGallery ? ', Buy Now' : '');
    };
    ItemView.prototype.getItemContainerClass = function() {
        var options = this.props.options;
        var isNOTslideshow = !GALLERY_CONSTS.isLayout('SLIDESHOW')(options);
        var imagePlacementAnimation = options.imagePlacementAnimation;
        var overlayAnimation = options.overlayAnimation;
        var imageHoverAnimation = options.imageHoverAnimation;
        var classNames = {
            'gallery-item-container': true,
            visible: true,
            highlight: this.isHighlight(),
            clickable: options.itemClick !== 'nothing',
            'simulate-hover': this.simulateHover(),
            'hide-hover': !this.simulateHover() && utils.isMobile(),
            'invert-hover': options.hoveringBehaviour ===
                GALLERY_CONSTS.infoBehaviourOnHover.DISAPPEARS,
            //animations
            'animation-slide': isNOTslideshow &&
                imagePlacementAnimation ===
                GALLERY_CONSTS.imagePlacementAnimations.SLIDE,
            //overlay animations
            'hover-animation-fade-in': isNOTslideshow &&
                overlayAnimation === GALLERY_CONSTS.overlayAnimations.FADE_IN,
            'hover-animation-expand': isNOTslideshow &&
                overlayAnimation === GALLERY_CONSTS.overlayAnimations.EXPAND,
            'hover-animation-slide-up': isNOTslideshow &&
                overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_UP,
            'hover-animation-slide-right': isNOTslideshow &&
                overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_RIGHT,
            'hover-animation-slide-down': isNOTslideshow &&
                overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_DOWN,
            'hover-animation-slide-left': isNOTslideshow &&
                overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_LEFT,
            //image hover animations
            'zoom-in-on-hover': isNOTslideshow &&
                imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.ZOOM_IN,
            'blur-on-hover': isNOTslideshow &&
                imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.BLUR,
            'grayscale-on-hover': isNOTslideshow &&
                imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.GRAYSCALE,
            'shrink-on-hover': isNOTslideshow &&
                imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.SHRINK,
            'invert-on-hover': isNOTslideshow &&
                imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.INVERT,
            'color-in-on-hover': isNOTslideshow &&
                imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.COLOR_IN,
            'darkened-on-hover': isNOTslideshow &&
                imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.DARKENED,
            'pro-gallery-mobile-indicator': utils.isMobile(),
        };
        var strClass = Object.entries(classNames)
            .map(function(_a) {
                var classname = _a[0],
                    isNeeded = _a[1];
                return (isNeeded ? classname : false);
            })
            .filter(Boolean)
            .join(' ');
        return strClass;
    };
    ItemView.prototype.getItemWrapperClass = function() {
        var _a = this.props,
            options = _a.options,
            type = _a.type;
        var classes = ['gallery-item-wrapper', 'visible'];
        if (options.cubeImages) {
            classes.push('cube-type-' + options.cubeType);
        }
        if (type === 'text') {
            classes.push('gallery-item-wrapper-text');
        }
        return classes.join(' ');
    };
    ItemView.prototype.getItemContainerTabIndex = function() {
        var tabIndex = this.isHighlight() ?
            utils.getTabIndex('currentThumbnail') :
            this.props.activeIndex === this.props.idx ?
            utils.getTabIndex('currentGalleryItem') :
            -1;
        return tabIndex;
    };
    //-----------------------------------------| REACT |--------------------------------------------//
    ItemView.prototype.componentDidMount = function() {
        if (utils.isMobile() && typeof React.initializeTouchEvents === 'function') {
            try {
                React.initializeTouchEvents(true);
            } catch (e) {
                console.error(e);
            }
        }
        window.addEventListener('current_hover_change', this.checkIfCurrentHoverChanged);
        this.setState({
            ariaLabel: this.getItemAriaLabel(),
        });
    };
    ItemView.prototype.componentWillUnmount = function() {
        clearTimeout(this.itemLoadedTimeout);
        window.removeEventListener('current_hover_change', this.checkIfCurrentHoverChanged);
    };
    ItemView.prototype.componentDidUpdate = function(prevProps) {
        changeActiveElementIfNeeded({
            prevProps: prevProps,
            currentProps: this.props,
            itemContainer: this.itemContainer
        });
    };
    ItemView.prototype.checkIfCurrentHoverChanged = function(e) {
        if (e.galleryId === this.props.galleryId) {
            if (!this.state.isCurrentHover && e.currentHoverIdx === this.props.idx) {
                this.setState({
                    isCurrentHover: true,
                    itemWasHovered: true,
                });
            } else if (this.state.isCurrentHover &&
                e.currentHoverIdx !== this.props.idx) {
                this.setState({
                    isCurrentHover: false,
                });
            }
        }
    };
    ItemView.prototype.onContextMenu = function(e) {
        if (!utils.isDev() && !this.props.options.allowContextMenu) {
            e.preventDefault(e);
        }
    };
    ItemView.prototype.getItemAriaRole = function() {
        switch (this.props.options.itemClick) {
            case 'expand':
            case 'fullscreen':
                return 'button';
            case 'link':
                return 'link';
            default:
                return '';
        }
    };
    ItemView.prototype.composeItem = function() {
        var _this = this;
        var _a = this.props,
            photoId = _a.photoId,
            id = _a.id,
            hash = _a.hash,
            idx = _a.idx,
            options = _a.options,
            type = _a.type,
            url = _a.url;
        //if (there is an url for video items and image items) OR text item (text item do not use media url)
        this.hasRequiredMediaUrl = url || type === 'text';
        //if titlePlacement !== SHOW_ON_HOVER and !this.hasRequiredMediaUrl, we will NOT render the itemWrapper (but will render the info element with the whole size of the item)
        var isItemWrapperEmpty = options.titlePlacement !== GALLERY_CONSTS.placements.SHOW_ON_HOVER &&
            !this.hasRequiredMediaUrl;
        var innerDiv = (React.createElement("div", {
                className: this.getItemContainerClass(),
                onContextMenu: function(e) {
                    return _this.onContextMenu(e);
                },
                id: cssScrollHelper.getSellectorDomId(this.props),
                ref: function(e) {
                    return (_this.itemContainer = e);
                },
                onMouseOver: this.onMouseOver,
                onMouseOut: this.onMouseOut,
                onFocus: this.onFocus,
                onBlur: this.onBlur,
                onKeyDown: this.onContainerKeyDown,
                tabIndex: this.getItemContainerTabIndex(),
                "aria-label": this.state.ariaLabel,
                "data-hash": hash,
                "data-id": photoId,
                "data-idx": idx,
                role: this.getItemAriaRole(),
                "data-hook": "item-container",
                key: 'item-container-' + id,
                style: this.getItemContainerStyles()
            },
            this.getTopInfoElementIfNeeded(),
            this.getLeftInfoElementIfNeeded(),
            React.createElement("div", {
                style: __assign(__assign(__assign({}, (!this.props.options.isSlideshow &&
                    getImageStyle(this.props.options))), (GALLERY_CONSTS.hasExternalRightPlacement(this.props.options.titlePlacement, this.props.idx) && {
                    float: 'left'
                })), (GALLERY_CONSTS.hasExternalLeftPlacement(this.props.options.titlePlacement, this.props.idx) && {
                    float: 'right'
                }))
            }, !isItemWrapperEmpty && (React.createElement("div", {
                "data-hook": "item-wrapper",
                className: this.getItemWrapperClass(),
                key: 'item-wrapper-' + id,
                id: 'item-wrapper-' + id,
                style: this.getItemWrapperStyles(),
                onClick: this.onItemWrapperClick
            }, this.getItemInner()))),
            this.getRightInfoElementIfNeeded(),
            this.getBottomInfoElementIfNeeded()));
        var isSlideshow = GALLERY_CONSTS.isLayout('SLIDESHOW')(options);
        if (isSlideshow) {
            return innerDiv;
        } else {
            return (React.createElement("a", __assign({
                ref: function(e) {
                    return (_this.itemAnchor = e);
                },
                "data-id": photoId,
                "data-idx": idx,
                key: 'item-container-link-' + id,
                onFocus: function() {
                    onAnchorFocus({
                        itemAnchor: _this.itemAnchor,
                        enableExperimentalFeatures: _this.props.enableExperimentalFeatures,
                        itemContainer: _this.itemContainer,
                    });
                }
            }, getLinkParams(this.props), {
                tabIndex: -1,
                onKeyDown: function(e) {
                    /* Relvenat only for Screen-Reader case:
                    Screen-Reader ignores the tabIdex={-1} and therefore stops and focuses on the <a> tag keyDown event,
                    so it will not go deeper to the item-container keyDown event.
                    */
                    _this.onAnchorKeyDown(e);
                }
            }), innerDiv));
        }
    };
    //-----------------------------------------| RENDER |--------------------------------------------//
    ItemView.prototype.render = function() {
        return this.composeItem();
    };
    return ItemView;
}(React.Component));
export default ItemView;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=itemView.js.map