import {
    __extends
} from "tslib";
import React from 'react';
import {
    GALLERY_CONSTS,
    isEditMode,
    utils
} from 'pro-gallery-lib';
var ItemHover = /** @class */ (function(_super) {
    __extends(ItemHover, _super);

    function ItemHover() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ItemHover.prototype.getHoverClass = function() {
        var _a = this.props,
            options = _a.options,
            forceShowHover = _a.forceShowHover;
        var hoverClass = ['gallery-item-hover'];
        hoverClass.push('fullscreen-' + (options.fullscreen ? 'enabled' : 'disabled'));
        if (utils.isUndefined(options.itemOpacity)) {
            //if gallery was just added to the page, and it's settings were never opened,
            //the options of opacity and background were not set (are undefined),
            //so we are using the default background & opacity (is scss under .gallery-item-hover.default)
            hoverClass.push('default');
        }
        if (forceShowHover) {
            //in mobile, when item is hovered (tapped, with all the right configurations), forceShowHover is true
            hoverClass.push('force-hover');
        } else if (utils.isMobile()) {
            hoverClass.push('hide-hover');
        }
        return hoverClass.join(' ');
    };
    ItemHover.prototype.shouldRenderHoverInnerIfExist = function() {
        var _a = this.props,
            itemWasHovered = _a.itemWasHovered,
            options = _a.options;
        var hoveringBehaviour = options.hoveringBehaviour,
            overlayAnimation = options.overlayAnimation,
            alwaysShowHover = options.alwaysShowHover,
            previewHover = options.previewHover;
        var APPEARS = GALLERY_CONSTS.infoBehaviourOnHover.APPEARS;
        var NO_EFFECT = GALLERY_CONSTS.overlayAnimations.NO_EFFECT;
        if (alwaysShowHover) {
            return true;
        }
        if (isEditMode() && previewHover) {
            return true;
        }
        if (hoveringBehaviour === APPEARS && overlayAnimation !== NO_EFFECT) {
            //when there is a specific overlayAnimation, to support the animation we render the itemHover before any hover activity (see 'shouldHover()' in itemView).
            //so in this specific case, the itemHover exists right away, but we do'nt want to render yet the hover-inner,
            //the hover-inner will be rendered only after (at) the first hover an on, and not before.
            return itemWasHovered;
        }
        return true;
    };
    ItemHover.prototype.getOverlayStyle = function() {
        var _a = this.props,
            options = _a.options,
            imageDimensions = _a.imageDimensions;
        var style = {};
        var overlayPosition = options.overlayPosition,
            requiredOverlaySize = options.overlaySize,
            overlaySizeType = options.overlaySizeType,
            overlayPadding = options.overlayPadding;
        var isHorizontal = overlayPosition === GALLERY_CONSTS.overlayPositions.LEFT ||
            overlayPosition === GALLERY_CONSTS.overlayPositions.RIGHT ||
            overlayPosition === GALLERY_CONSTS.overlayPositions.CENTERED_HORIZONTALLY;
        var _b = this.calcHeightAndWidth({
                isHorizontal: isHorizontal,
                overlayPadding: overlayPadding,
                requiredOverlaySize: requiredOverlaySize,
                imageDimensions: imageDimensions,
                overlaySizeType: overlaySizeType,
            }),
            width = _b.width,
            height = _b.height;
        var margin = overlayPadding;
        Object.assign(style, {
            width: width,
            height: height,
            margin: margin,
            position: 'relative',
        });
        return style;
    };
    ItemHover.prototype.calcHeightAndWidth = function(_a) {
        var _b;
        var isHorizontal = _a.isHorizontal,
            overlayPadding = _a.overlayPadding,
            requiredOverlaySize = _a.requiredOverlaySize,
            imageDimensions = _a.imageDimensions,
            overlaySizeType = _a.overlaySizeType;
        var calculatedField = isHorizontal ? 'width' : 'height';
        var calculatedOppositeField = isHorizontal ? 'height' : 'width';
        var overlaySizeCalc = this.calcOverlaySize(imageDimensions[calculatedField], requiredOverlaySize, overlaySizeType, overlayPadding);
        return _b = {},
            _b[calculatedField] = overlaySizeCalc,
            _b[calculatedOppositeField] = imageDimensions[calculatedOppositeField] - 2 * overlayPadding,
            _b;
    };
    ItemHover.prototype.calcOverlaySize = function(widthOrHeight, requiredOverlaySize, overlaySizeType, overlayPadding) {
        var widthOrHeightCalc = widthOrHeight + -2 * overlayPadding;
        var overlaySize = Math.min(widthOrHeightCalc, overlaySizeType === 'PERCENT' ?
            widthOrHeightCalc * (requiredOverlaySize / 100) :
            requiredOverlaySize);
        return Math.max(0, overlaySize);
    };
    ItemHover.prototype.getOverlayPositionByFlex = function() {
        var _a = this.props,
            options = _a.options,
            imageDimensions = _a.imageDimensions;
        var overlayPosition = options.overlayPosition;
        var width = imageDimensions.width,
            height = imageDimensions.height,
            marginTop = imageDimensions.marginTop,
            marginLeft = imageDimensions.marginLeft;
        var style = {
            width: width,
            height: height,
            marginTop: marginTop,
            marginLeft: marginLeft,
            display: 'flex',
            position: 'absolute',
            top: 0,
            left: 0,
        };
        switch (overlayPosition) {
            case GALLERY_CONSTS.overlayPositions.RIGHT:
                Object.assign(style, {
                    justifyContent: 'flex-end',
                });
                break;
            case GALLERY_CONSTS.overlayPositions.BOTTOM:
                Object.assign(style, {
                    alignItems: 'flex-end',
                });
                break;
            case GALLERY_CONSTS.overlayPositions.CENTERED_HORIZONTALLY:
                Object.assign(style, {
                    justifyContent: 'center',
                });
                break;
            case GALLERY_CONSTS.overlayPositions.CENTERED_VERTICALLY:
                Object.assign(style, {
                    alignItems: 'center',
                });
                break;
        }
        return style;
    };
    ItemHover.prototype.render = function() {
        var _a = this.props,
            actions = _a.actions,
            idx = _a.idx,
            renderCustomInfo = _a.renderCustomInfo;
        var hoverClass = this.getHoverClass();
        var overlayStyle = this.getOverlayStyle();
        var overlayPositionCalc = this.getOverlayPositionByFlex();
        return (React.createElement("div", {
                className: 'item-hover-flex-container',
                style: overlayPositionCalc
            },
            React.createElement("div", {
                key: 'item-hover-' + idx,
                "data-hook": 'item-hover-' + idx,
                "aria-hidden": true,
                className: hoverClass,
                onTouchStart: actions.handleItemMouseDown,
                onTouchEnd: actions.handleItemMouseUp,
                style: overlayStyle
            }, this.shouldRenderHoverInnerIfExist() && renderCustomInfo ? (React.createElement("div", {
                className: "gallery-item-hover-inner"
            }, renderCustomInfo())) : null)));
    };
    return ItemHover;
}(React.Component));
export default ItemHover;
//# sourceMappingURL=itemHover.js.map