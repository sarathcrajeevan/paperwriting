import {
    __assign,
    __awaiter,
    __extends,
    __generator
} from "tslib";
/* eslint-disable prettier/prettier */
import React from 'react';
import {
    GALLERY_CONSTS,
    window,
    utils,
    isEditMode,
    isPreviewMode,
} from 'pro-gallery-lib';
import GroupView from '../../group/groupView.js';
import GalleryDebugMessage from './galleryDebugMessage.js';
import {
    isGalleryInViewport
} from './galleryHelpers.js';
import PlayIcon from '../../svgs/components/play';
import PauseIcon from '../../svgs/components/pause';
import TextItem from '../../item/textItem.js';
import {
    getArrowsRenderData,
    shouldRenderNavArrows,
} from '../../helpers/navigationArrowUtils';
var SKIP_SLIDES_MULTIPLIER = 1.5;

function getDirection(code) {
    var reverse = [33, 37, 38];
    var direct = [32, 34, 39, 40];
    if (reverse.includes(code))
        return -1;
    else if (direct.includes(code))
        return 1;
    throw new Error("no direction is defined for charCode: " + code);
}
var SlideshowView = /** @class */ (function(_super) {
    __extends(SlideshowView, _super);

    function SlideshowView(props) {
        var _this = _super.call(this, props) || this;
        _this.autoScrollToNextItem = function() {
            if (!isEditMode() &&
                (isGalleryInViewport(_this.props.container) || isPreviewMode())) {
                var options = _this.props.options;
                var direction = options.isRTL ? -1 : 1;
                if (options.autoSlideshowType ===
                    GALLERY_CONSTS.autoSlideshowTypes.CONTINUOUS) {
                    _this._next({
                        direction: direction,
                        isAutoTrigger: true,
                        isContinuousScrolling: true,
                    });
                } else if (options.autoSlideshowType ===
                    GALLERY_CONSTS.autoSlideshowTypes.INTERVAL) {
                    _this._next({
                        direction: direction,
                        isAutoTrigger: true,
                        scrollDuration: 800,
                    });
                }
            }
        };
        _this.navigationOutHandler = _this.navigationOutHandler.bind(_this);
        _this.navigationInHandler = _this.navigationInHandler.bind(_this);
        _this.scrollToThumbnail = _this.scrollToThumbnail.bind(_this);
        _this.clearAutoSlideshowInterval = _this.clearAutoSlideshowInterval.bind(_this);
        _this.onFocus = _this.onFocus.bind(_this);
        _this.onBlur = _this.onBlur.bind(_this);
        _this.onAutoSlideShowButtonClick =
            _this.onAutoSlideShowButtonClick.bind(_this);
        _this.startAutoSlideshowIfNeeded =
            _this.startAutoSlideshowIfNeeded.bind(_this);
        _this.blockAutoSlideshowIfNeeded =
            _this.blockAutoSlideshowIfNeeded.bind(_this);
        _this.canStartAutoSlideshow = _this.canStartAutoSlideshow.bind(_this);
        _this.handleSlideshowKeyPress = _this.handleSlideshowKeyPress.bind(_this);
        _this.onAutoSlideshowAutoPlayKeyPress =
            _this.onAutoSlideshowAutoPlayKeyPress.bind(_this);
        _this.setCurrentItemByScroll = _this.setCurrentItemByScroll.bind(_this);
        _this._setCurrentItemByScroll = utils
            .throttle(_this.setCurrentItemByScroll, 600)
            .bind(_this);
        _this._next = utils.throttle(_this.next.bind(_this), 400).bind(_this);
        _this.state = {
            activeIndex: props.activeIndex || 0,
            isInView: true,
            pauseAutoSlideshowClicked: false,
            hideLeftArrow: !props.isRTL,
            hideRightArrow: props.isRTL,
            shouldBlockAutoSlideshow: false,
            isInFocus: false,
        };
        _this.lastCurrentItem = undefined;
        _this.shouldCreateSlideShowPlayButton = false;
        _this.skipFromSlide = Math.round(_this.props.totalItemsCount * SKIP_SLIDES_MULTIPLIER); // Used in infinite loop
        return _this;
    }
    SlideshowView.prototype.isFirstItem = function() {
        return this.state.activeIndex === 0;
    };
    SlideshowView.prototype.isScrollStart = function() {
        var slideAnimation = this.props.options.slideAnimation;
        if (slideAnimation !== GALLERY_CONSTS.slideAnimations.SCROLL || !this.scrollElement) {
            return false;
        }
        return this.scrollPosition() <= 1;
    };
    SlideshowView.prototype.isScrollEnd = function() {
        var _a = this.props.options,
            slideshowLoop = _a.slideshowLoop,
            slideAnimation = _a.slideAnimation;
        if (slideshowLoop ||
            slideAnimation === GALLERY_CONSTS.slideAnimations.FADE ||
            slideAnimation === GALLERY_CONSTS.slideAnimations.DECK) {
            return false;
        }
        return (this.isAllItemsLoaded() &&
            this.scrollPositionAtTheAndOfTheGallery() >= Math.floor(this.getScrollElementWidth()));
    };
    SlideshowView.prototype.isAllItemsLoaded = function() {
        var _a = this.props,
            totalItemsCount = _a.totalItemsCount,
            getVisibleItems = _a.getVisibleItems,
            galleryStructure = _a.galleryStructure,
            container = _a.container;
        var visibleItemsCount = getVisibleItems(galleryStructure.galleryItems, container).length;
        return visibleItemsCount >= totalItemsCount;
    };
    SlideshowView.prototype.getScrollElementWidth = function() {
        var galleryStructure = this.props.galleryStructure;
        var imageMargin = this.props.options.imageMargin;
        return galleryStructure.width - imageMargin / 2;
    };
    SlideshowView.prototype.isFirstItemFullyVisible = function() {
        return !this.props.options.slideshowLoop && this.isScrollStart();
    };
    SlideshowView.prototype.isLastItemFullyVisible = function() {
        return !this.props.options.slideshowLoop && this.isScrollEnd();
    };
    SlideshowView.prototype.isLastItem = function() {
        return (!this.props.options.slideshowLoop &&
            this.state.activeIndex >= this.props.totalItemsCount - 1);
    };
    //__________________________________Slide show loop functions_____________________________________________
    SlideshowView.prototype.createNewItemsForSlideshowLoopThumbnails = function() {
        var items = this.props.items;
        var biasedItems = [];
        var numOfThumbnails = Math.ceil(this.props.container.galleryWidth / this.props.options.thumbnailSize);
        // need to create new item ! not just to copy the last once - the react view refferce one of them
        Object.keys(items).forEach(function(idx) {
            var _idx = Number(idx);
            var biasIdx;
            //bias all items idx by the number of added items
            biasIdx = _idx + numOfThumbnails;
            biasedItems[biasIdx] = __assign({}, items[idx]);
            //create the first copy of items
            if (_idx > items.length - numOfThumbnails - 1) {
                biasIdx = _idx - items.length + numOfThumbnails;
                biasedItems[biasIdx] = __assign({}, items[idx]);
            }
            //create the end items
            if (_idx < numOfThumbnails) {
                biasIdx = _idx + numOfThumbnails + items.length;
                biasedItems[biasIdx] = __assign({}, items[idx]);
            }
        });
        biasedItems.forEach(function(item, index) {
            item.loopIndex = index;
        });
        this.ItemsForSlideshowLoopThumbnails = biasedItems;
        this.numOfThumbnails = numOfThumbnails;
    };
    //__________________________________end of slide show loop functions__________________________
    SlideshowView.prototype.shouldBlockNext = function(_a) {
        var scrollingUpTheGallery = _a.scrollingUpTheGallery;
        return ((scrollingUpTheGallery && this.isLastItem()) ||
            (!scrollingUpTheGallery && this.isFirstItem()));
    };
    SlideshowView.prototype.shouldNotAllowScroll = function(_a) {
        var scrollingUpTheGallery = _a.scrollingUpTheGallery;
        return ((scrollingUpTheGallery && this.isLastItemFullyVisible()) ||
            (!scrollingUpTheGallery && this.isFirstItemFullyVisible()));
    };
    SlideshowView.prototype.next = function(_a) {
        var _b;
        var direction = _a.direction,
            isAutoTrigger = _a.isAutoTrigger,
            scrollDuration = _a.scrollDuration,
            _c = _a.isKeyboardNavigation,
            isKeyboardNavigation = _c === void 0 ? false : _c,
            _d = _a.isContinuousScrolling,
            isContinuousScrolling = _d === void 0 ? false : _d;
        var scrollingUpTheGallery = this.props.options.isRTL ?
            direction <= -1 :
            direction >= 1;
        if (this.shouldBlockNext({
                scrollingUpTheGallery: scrollingUpTheGallery
            })) {
            this.clearAutoSlideshowInterval();
            return;
        }
        direction *= this.props.options.isRTL ? -1 : 1;
        var activeElement = document.activeElement;
        var galleryItemIsFocused = activeElement.className &&
            activeElement.className.includes('gallery-item-container');
        var avoidIndividualNavigation = !isKeyboardNavigation ||
            !(((_b = this.props.settings) === null || _b === void 0 ? void 0 : _b.isAccessible) && galleryItemIsFocused);
        var ignoreScrollPosition = false;
        if (this.props.options.slideAnimation !==
            GALLERY_CONSTS.slideAnimations.SCROLL) {
            scrollDuration = 0;
            ignoreScrollPosition = true;
        }
        if (avoidIndividualNavigation && this.props.options.groupSize > 1) {
            this.nextGroup({
                direction: direction,
                scrollDuration: scrollDuration,
                isContinuousScrolling: isContinuousScrolling,
                scrollingUpTheGallery: scrollingUpTheGallery
            }); //if its not in accessibility that requieres individual nav and we are in a horizontal(this file) collage(layout 0) - use group navigation
        } else {
            if (avoidIndividualNavigation &&
                GALLERY_CONSTS.isLayout('GRID')(this.props.options) &&
                this.props.options.numberOfImagesPerCol) {
                direction *= this.props.options.numberOfImagesPerCol;
            }
            this.nextItem({
                direction: direction,
                isAutoTrigger: isAutoTrigger,
                scrollDuration: scrollDuration,
                avoidIndividualNavigation: avoidIndividualNavigation,
                ignoreScrollPosition: ignoreScrollPosition,
                isContinuousScrolling: isContinuousScrolling,
                scrollingUpTheGallery: scrollingUpTheGallery,
            });
        }
        this.removeArrowsIfNeeded();
    };
    SlideshowView.prototype.getNextItemOrGroupToScrollTo = function(initiator, direction, ignoreScrollPosition, avoidIndividualNavigation, isAutoTrigger) {
        this.isSliding = true;
        var nextIndex;
        if (initiator === 'nextGroup' ||
            (initiator === 'nextItem' &&
                !ignoreScrollPosition &&
                avoidIndividualNavigation &&
                !(this.props.options.groupSize > 1))) {
            var key = initiator === 'nextGroup' ? 'groups' : 'galleryItems';
            nextIndex =
                this.getCenteredItemOrGroupIdxByScroll(key) + direction;
        } else if (initiator === 'nextItem') {
            if (ignoreScrollPosition || !isAutoTrigger) {
                nextIndex = this.state.activeIndex;
            } else {
                nextIndex = this.setCurrentItemByScroll();
            }
            nextIndex += direction;
            if (!this.props.options.slideshowLoop) {
                nextIndex = Math.min(this.props.galleryStructure.items.length - 1, nextIndex);
                nextIndex = Math.max(0, nextIndex);
            }
        }
        this.isAutoScrolling = true;
        return nextIndex;
    };
    SlideshowView.prototype.nextItem = function(_a) {
        var direction = _a.direction,
            isAutoTrigger = _a.isAutoTrigger,
            scrollDuration = _a.scrollDuration,
            avoidIndividualNavigation = _a.avoidIndividualNavigation,
            ignoreScrollPosition = _a.ignoreScrollPosition,
            isContinuousScrolling = _a.isContinuousScrolling,
            scrollingUpTheGallery = _a.scrollingUpTheGallery;
        return __awaiter(this, void 0, void 0, function() {
            var nextItem, itemToScroll, skipToSlide, e_1;
            return __generator(this, function(_b) {
                switch (_b.label) {
                    case 0:
                        if (this.isSliding) {
                            return [2 /*return*/ ];
                        }
                        nextItem = this.getNextItemOrGroupToScrollTo('nextItem', direction, ignoreScrollPosition, avoidIndividualNavigation, isAutoTrigger);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, , 6]);
                        itemToScroll = ignoreScrollPosition ? 0 : nextItem;
                        return [4 /*yield*/ , this.scrollToItemOrGroup(this.props.actions.scrollToItem, itemToScroll, isContinuousScrolling, scrollDuration, scrollingUpTheGallery)];
                    case 2:
                        _b.sent();
                        if (!(this.props.options.groupSize === 1)) return [3 /*break*/ , 4];
                        skipToSlide = this.skipFromSlide - this.props.totalItemsCount;
                        if (!(nextItem >= this.skipFromSlide)) return [3 /*break*/ , 4];
                        nextItem = skipToSlide;
                        return [4 /*yield*/ , this.props.actions.scrollToItem(nextItem)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        this.onScrollToItemOrGroup(nextItem, isContinuousScrolling);
                        if (ignoreScrollPosition) {
                            this.props.getMoreItemsIfNeeded(this.props.galleryStructure.galleryItems[nextItem].offset.left);
                            this.props.setGotFirstScrollIfNeeded();
                        }
                        return [3 /*break*/ , 6];
                    case 5:
                        e_1 = _b.sent();
                        this.onThrowScrollError('Cannot proceed to the next Item', e_1);
                        return [3 /*break*/ , 6];
                    case 6:
                        return [2 /*return*/ ];
                }
            });
        });
    };
    SlideshowView.prototype.nextGroup = function(_a) {
        var direction = _a.direction,
            scrollDuration = _a.scrollDuration,
            _b = _a.isContinuousScrolling,
            isContinuousScrolling = _b === void 0 ? false : _b,
            scrollingUpTheGallery = _a.scrollingUpTheGallery;
        return __awaiter(this, void 0, void 0, function() {
            var nextGroup, nextItem, e_2;
            return __generator(this, function(_c) {
                switch (_c.label) {
                    case 0:
                        if (this.isSliding) {
                            return [2 /*return*/ ];
                        }
                        nextGroup = this.getNextItemOrGroupToScrollTo('nextGroup', direction);
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/ , this.scrollToItemOrGroup(this.props.actions.scrollToGroup, nextGroup, isContinuousScrolling, scrollDuration, scrollingUpTheGallery)];
                    case 2:
                        _c.sent();
                        nextItem = this.getCenteredItemOrGroupIdxByScroll('galleryItems') + direction;
                        this.onScrollToItemOrGroup(nextItem, isContinuousScrolling);
                        return [3 /*break*/ , 4];
                    case 3:
                        e_2 = _c.sent();
                        this.onThrowScrollError('Cannot proceed to the next Group', e_2);
                        return [3 /*break*/ , 4];
                    case 4:
                        return [2 /*return*/ ];
                }
            });
        });
    };
    SlideshowView.prototype.scrollToItemOrGroup = function(func, indexToScroll, isContinuousScrolling, scrollDuration, scrollingUpTheGallery) {
        return __awaiter(this, void 0, void 0, function() {
            var shouldAllowScroll, _a, scrollMarginCorrection, _scrollDuration, _b;
            return __generator(this, function(_c) {
                switch (_c.label) {
                    case 0:
                        shouldAllowScroll = !this.shouldNotAllowScroll({
                            scrollingUpTheGallery: scrollingUpTheGallery
                        });
                        _a = this.getScrollParameters(scrollDuration), scrollMarginCorrection = _a.scrollMarginCorrection, _scrollDuration = _a._scrollDuration;
                        _b = shouldAllowScroll;
                        if (!_b) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , func(indexToScroll, false, true, _scrollDuration, scrollMarginCorrection, isContinuousScrolling)];
                    case 1:
                        _b = (_c.sent());
                        _c.label = 2;
                    case 2:
                        _b;
                        return [2 /*return*/ ];
                }
            });
        });
    };
    SlideshowView.prototype.onThrowScrollError = function(massage, e) {
        console.error(massage, e);
        this.clearAutoSlideshowInterval();
    };
    SlideshowView.prototype.onScrollToItemOrGroup = function(nextItem, isContinuousScrolling) {
        var _this = this;
        utils.setStateAndLog(this, 'Next Item', {
            activeIndex: nextItem,
        }, function() {
            _this.onCurrentItemChanged();
            _this.isSliding = false;
            if (isContinuousScrolling) {
                _this.startAutoSlideshowIfNeeded(_this.props.options);
            }
        });
    };
    SlideshowView.prototype.getScrollParameters = function(scrollDuration) {
        return {
            scrollMarginCorrection: this.getStyles().margin || 0,
            _scrollDuration: scrollDuration || this.props.options.scrollDuration || 400,
        };
    };
    SlideshowView.prototype.onCurrentItemChanged = function() {
        if (this.lastCurrentItem !== this.state.activeIndex) {
            this.lastCurrentItem = this.state.activeIndex;
            //this.props.actions.onCurrentItemChanged(this.state.currentIdx);
            var currentGalleryItem = this.props.galleryStructure.galleryItems[this.state.activeIndex];
            var item = this.props.items[this.state.activeIndex];
            if (item) {
                item.idx = this.state.activeIndex;
                item.resizedImageSrc = currentGalleryItem.createUrl(GALLERY_CONSTS.urlSizes.RESIZED, GALLERY_CONSTS.urlTypes.HIGH_RES);
                this.props.actions.eventsListener(GALLERY_CONSTS.events.CURRENT_ITEM_CHANGED, item);
            }
        }
        this.removeArrowsIfNeeded();
    };
    SlideshowView.prototype.clearAutoSlideshowInterval = function() {
        clearInterval(this.autoSlideshowInterval);
    };
    SlideshowView.prototype.canStartAutoSlideshow = function(options) {
        return (options.isAutoSlideshow &&
            !this.state.shouldBlockAutoSlideshow);
    };
    SlideshowView.prototype.startAutoSlideshowIfNeeded = function(options) {
        this.clearAutoSlideshowInterval();
        if (this.canStartAutoSlideshow(options)) {
            if (options.autoSlideshowType ===
                GALLERY_CONSTS.autoSlideshowTypes.CONTINUOUS &&
                options.autoSlideshowContinuousSpeed > 0) {
                this.autoScrollToNextItem();
            } else if (options.autoSlideshowType ===
                GALLERY_CONSTS.autoSlideshowTypes.INTERVAL &&
                options.autoSlideshowInterval > 0) {
                this.autoSlideshowInterval = setInterval(this.autoScrollToNextItem, options.autoSlideshowInterval * 1000);
            }
        }
    };
    SlideshowView.prototype.scrollToThumbnail = function(itemIdx, scrollDuration) {
        //not to confuse with this.props.actions.scrollToItem. this is used to replace it only for thumbnail items
        this.props.actions.eventsListener(GALLERY_CONSTS.events.THUMBNAIL_CLICKED, this.props);
        this.props.setGotFirstScrollIfNeeded(); //load all the images in the thumbnails bar
        this.next({
            direction: itemIdx - this.state.activeIndex,
            isAutoTrigger: false,
            scrollDuration: scrollDuration,
            isKeyboardNavigation: false,
        });
    };
    SlideshowView.prototype.handleSlideshowKeyPress = function(e) {
        e.stopPropagation();
        var relevantKeys = [32, 33, 34, 37, 38, 39, 40, 27];
        // key code -> 32=space, 37=left, 38=up, 39=right, 40=down, 27=esc
        // charCode -> , 33=page up, 34=page down
        var code = e.charCode || e.keyCode;
        if (relevantKeys.includes(code) === false)
            return true;
        e.preventDefault();
        var activeItemIdx = window.document.activeElement.getAttribute('data-idx');
        var shouldFocusOutOfViewComponent = activeItemIdx &&
            this.props.totalItemsCount - 1 === Number(activeItemIdx) &&
            Number(activeItemIdx) === this.state.activeIndex;
        if ((code === 40 && shouldFocusOutOfViewComponent) || code === 27) {
            var elementToFocus = {
                27: this.props.galleryContainerRef,
                40: this.props.outOfViewComponent,
            }[code];
            utils.focusGalleryElement(elementToFocus);
        } else {
            this._next({
                direction: getDirection(code),
                isKeyboardNavigation: true
            });
        }
        return false;
    };
    SlideshowView.prototype.createThumbnails = function(thumbnailPosition) {
        var _this = this;
        var _a;
        var items = this.props.items;
        var activeIndex = this.state.activeIndex;
        if (this.props.options.slideshowLoop) {
            if (!this.ItemsForSlideshowLoopThumbnails) {
                this.createNewItemsForSlideshowLoopThumbnails();
            }
            activeIndex += this.numOfThumbnails;
            items = this.ItemsForSlideshowLoopThumbnails;
        }
        if (utils.isVerbose()) {
            console.log('creating thumbnails for idx', activeIndex);
        }
        var width = this.props.options.thumbnailSize;
        var height = this.props.options.thumbnailSize;
        var horizontalThumbnails;
        var numOfThumbnails;
        var numOfWholeThumbnails;
        switch (thumbnailPosition) {
            case 'top':
            case 'bottom':
                width =
                    this.props.container.galleryWidth +
                    this.props.options.thumbnailSpacings;
                height =
                    this.props.options.thumbnailSize +
                    this.props.options.thumbnailSpacings;
                horizontalThumbnails = true;
                numOfThumbnails = Math.ceil(width / this.props.options.thumbnailSize);
                numOfWholeThumbnails = Math.floor((width + this.props.options.thumbnailSpacings) /
                    (this.props.options.thumbnailSize +
                        this.props.options.thumbnailSpacings * 2));
                break;
            case 'left':
            case 'right':
                height =
                    this.props.container.galleryHeight +
                    2 * this.props.options.thumbnailSpacings;
                width =
                    this.props.options.thumbnailSize +
                    2 * this.props.options.thumbnailSpacings;
                horizontalThumbnails = false;
                numOfThumbnails = Math.ceil(height / this.props.options.thumbnailSize);
                numOfWholeThumbnails = Math.floor(height /
                    (this.props.options.thumbnailSize +
                        this.props.options.thumbnailSpacings * 2));
                break;
        }
        this.firstItemIdx = activeIndex - Math.floor(numOfThumbnails / 2) - 1;
        this.lastItemIdx = this.firstItemIdx + numOfThumbnails;
        if (this.firstItemIdx < 0) {
            this.lastItemIdx -= this.firstItemIdx;
            this.firstItemIdx = 0;
        }
        if (this.lastItemIdx > items.length - 1) {
            this.firstItemIdx -= this.lastItemIdx - (items.length - 1);
            if (this.firstItemIdx < 0) {
                this.firstItemIdx = 0;
            }
            this.lastItemIdx = items.length - 1;
        }
        numOfThumbnails = this.lastItemIdx - this.firstItemIdx + 1;
        if (numOfThumbnails % 2 === 0 &&
            items.length > numOfThumbnails &&
            this.lastItemIdx < items.length - 1) {
            // keep an odd number of thumbnails if there are more thumbnails than items and if the thumbnails haven't reach the last item yet
            numOfThumbnails += 1;
            this.lastItemIdx += 1;
        }
        var thumbnailsContainerSize = numOfThumbnails * this.props.options.thumbnailSize +
            ((numOfThumbnails - 1) * 2 + 1) *
            this.props.options.thumbnailSpacings;
        var thumbnailsStyle = {
            width: width,
            height: height
        };
        if (items.length <= numOfWholeThumbnails ||
            activeIndex < numOfThumbnails / 2 - 1) {
            //there are less thumbnails than available thumbnails spots || one of the first thumbnails
            switch (thumbnailPosition) {
                case 'top':
                case 'bottom':
                    thumbnailsStyle.width = thumbnailsContainerSize + 'px';
                    thumbnailsStyle.left = 0;
                    break;
                case 'left':
                case 'right':
                    thumbnailsStyle.height = thumbnailsContainerSize + 'px';
                    thumbnailsStyle.marginTop = 0;
                    break;
            }
        } else if (activeIndex > numOfThumbnails / 2 - 1 &&
            activeIndex < items.length - numOfThumbnails / 2) {
            //set selected to center only if neeeded
            switch (thumbnailPosition) {
                case 'top':
                case 'bottom':
                    thumbnailsStyle.width = thumbnailsContainerSize + 'px';
                    thumbnailsStyle.left = (width - thumbnailsContainerSize) / 2 + 'px';
                    break;
                case 'left':
                case 'right':
                    thumbnailsStyle.height = thumbnailsContainerSize + 'px';
                    thumbnailsStyle.marginTop =
                        (height - thumbnailsContainerSize) / 2 + 'px';
                    break;
            }
        } else if (activeIndex >= items.length - numOfThumbnails / 2) {
            //one of the last thumbnails
            switch (thumbnailPosition) {
                case 'top':
                case 'bottom':
                    thumbnailsStyle.left = width - thumbnailsContainerSize + 'px';
                    thumbnailsStyle.overflow = 'visible';
                    break;
                case 'left':
                case 'right':
                    thumbnailsStyle.top = height - thumbnailsContainerSize + 'px';
                    thumbnailsStyle.overflow = 'visible';
                    break;
            }
        }
        if (this.props.options.isRTL) {
            thumbnailsStyle.right = thumbnailsStyle.left;
            delete thumbnailsStyle.left;
        }
        var thumbnailsMargin;
        var thumbnailSpacings = this.props.options.thumbnailSpacings;
        switch (this.props.options.galleryThumbnailsAlignment) {
            case 'bottom':
                thumbnailsMargin = thumbnailSpacings + "px -" + thumbnailSpacings + "px 0 -" + thumbnailSpacings + "px";
                break;
            case 'left':
                thumbnailsMargin = "-" + thumbnailSpacings + "px " + thumbnailSpacings + "px -" + thumbnailSpacings + "px 0";
                break;
            case 'top':
                thumbnailsMargin = "0 -" + thumbnailSpacings + "px " + thumbnailSpacings + "px -" + thumbnailSpacings + "px";
                break;
            case 'right':
                thumbnailsMargin = "-" + thumbnailSpacings + "px 0 -" + thumbnailSpacings + "px " + thumbnailSpacings + "px";
                break;
        }
        var getThumbnailItemForSlideshowLoop = function(itemId) {
            return _this.props.galleryStructure.galleryItems.find(function(item) {
                return item.id === itemId;
            });
        };
        var highlighledIdxForSlideshowLoop = Math.floor(numOfThumbnails / 2);
        var thumbnailItems;
        if (this.props.options.slideshowLoop) {
            thumbnailItems = items.slice(this.firstItemIdx, this.lastItemIdx + 1);
        } else {
            thumbnailItems = this.props.galleryStructure.galleryItems.slice(this.firstItemIdx, this.lastItemIdx + 1);
        }
        var thumbnailSize = this.props.options.thumbnailSize;
        return (React.createElement("div", {
                className: 'pro-gallery inline-styles thumbnails-gallery ' +
                    (horizontalThumbnails ? ' one-row hide-scrollbars ' : '') +
                    (this.props.options.isRTL ? ' rtl ' : ' ltr ') +
                    (((_a = this.props.settings) === null || _a === void 0 ? void 0 : _a.isAccessible) ? ' accessible ' : ''),
                style: {
                    width: width,
                    height: height,
                    margin: thumbnailsMargin,
                },
                "data-hook": "gallery-thumbnails"
            },
            React.createElement("div", {
                "data-hook": "gallery-thumbnails-column",
                className: 'galleryColumn',
                key: 'thumbnails-column',
                style: Object.assign(thumbnailsStyle, {
                    width: width,
                    height: height
                })
            }, thumbnailItems.map(function(item, idx) {
                var _a;
                var thumbnailItem = _this.props.options.slideshowLoop ?
                    getThumbnailItemForSlideshowLoop(item.itemId || item.photoId) :
                    item;
                var highlighted = _this.props.options.slideshowLoop ?
                    idx === highlighledIdxForSlideshowLoop :
                    thumbnailItem.idx === activeIndex;
                var itemStyle = {
                    width: thumbnailSize,
                    height: thumbnailSize,
                    marginLeft: thumbnailSpacings,
                    marginTop: thumbnailSpacings,
                    overflow: 'hidden',
                    backgroundImage: "url(" + thumbnailItem.createUrl(GALLERY_CONSTS.urlSizes.THUMBNAIL, GALLERY_CONSTS.urlTypes.HIGH_RES) + ")",
                };
                var thumbnailOffset = horizontalThumbnails ?
                    (_a = {},
                        _a[_this.props.options.isRTL ? 'right' : 'left'] = thumbnailSize * idx + 2 * idx * thumbnailSpacings,
                        _a) : {
                        top: thumbnailSize * idx + 2 * idx * thumbnailSpacings
                    };
                Object.assign(itemStyle, thumbnailOffset);
                return (React.createElement("div", {
                    key: 'thumbnail-' +
                        thumbnailItem.id +
                        (Number.isInteger(item.loopIndex) ? '-' + item.loopIndex : ''),
                    className: 'thumbnailItem' +
                        (highlighted ?
                            ' pro-gallery-thumbnails-highlighted highlight' +
                            (utils.isMobile() ? ' pro-gallery-mobile-indicator' : '') :
                            ''),
                    "data-key": thumbnailItem.id,
                    style: itemStyle,
                    onClick: function() {
                        return _this.scrollToThumbnail(thumbnailItem.idx);
                    }
                }, item.type === 'text' ? (React.createElement(TextItem, __assign({}, _this.props, thumbnailItem.renderProps(), {
                    options: __assign(__assign({}, _this.props.options), {
                        cubeType: 'fill',
                        cubeImages: true
                    }),
                    actions: {},
                    imageDimensions: __assign(__assign({}, itemStyle), {
                        marginTop: 0,
                        marginLeft: 0
                    }),
                    style: __assign(__assign({}, thumbnailItem.renderProps().style), itemStyle)
                }))) : null));
            }))));
    };
    SlideshowView.prototype.getCenteredItemOrGroupIdxByScroll = function(key) {
        var itemsOrGroups = this.props.galleryStructure[key];
        var centeredItemOrGroupIdx;
        var scrollPositionAtTheMiddleOfTheGallery = this.scrollPositionAtTheMiddleOfTheGallery();
        if (scrollPositionAtTheMiddleOfTheGallery === 0) {
            centeredItemOrGroupIdx = 0;
        } else {
            for (var itemOrGroup = void 0, i = 0;
                (itemOrGroup = itemsOrGroups[i]); i++) {
                var itemOrGroupLeft = key === 'galleryItems' ?
                    itemOrGroup.offset.left : itemOrGroup.left;
                if (itemOrGroupLeft > scrollPositionAtTheMiddleOfTheGallery) {
                    centeredItemOrGroupIdx = i - 1;
                    break;
                }
            }
        }
        if (!(centeredItemOrGroupIdx >= 0)) {
            centeredItemOrGroupIdx = itemsOrGroups.length - 1;
        }
        return centeredItemOrGroupIdx;
    };
    SlideshowView.prototype.setCurrentItemByScroll = function() {
        var _this = this;
        if (utils.isVerbose()) {
            console.log('Setting current Idx by scroll', this.isAutoScrolling);
        }
        if (this.isAutoScrolling) {
            //avoid this function if the scroll was originated by us (arrows or thumbnails)
            this.isAutoScrolling = false;
            return;
        }
        var isScrolling = (this.scrollElement && this.scrollElement.getAttribute('data-scrolling')) ===
            'true';
        if (isScrolling) {
            this.clearAutoSlideshowInterval();
            //while the scroll is animating, prevent the reaction to this event
            return;
        }
        this.startAutoSlideshowIfNeeded(this.props.options);
        var activeIndex = this.getCenteredItemOrGroupIdxByScroll('galleryItems');
        if (!utils.isUndefined(activeIndex)) {
            utils.setStateAndLog(this, 'Set Current Item', {
                activeIndex: activeIndex,
            }, function() {
                _this.onCurrentItemChanged();
            });
        }
        return activeIndex;
    };
    SlideshowView.prototype.createDebugMsg = function() {
        return React.createElement(GalleryDebugMessage, __assign({}, this.props.debug));
    };
    SlideshowView.prototype.createNavArrows = function() {
        var _a;
        var _this = this;
        var _b = this.props.options,
            isRTL = _b.isRTL,
            scrollDirection = _b.scrollDirection,
            slideshowInfoSize = _b.slideshowInfoSize,
            imageMargin = _b.imageMargin,
            arrowsPadding = _b.arrowsPadding,
            arrowsPosition = _b.arrowsPosition,
            arrowsVerticalPosition = _b.arrowsVerticalPosition,
            titlePlacement = _b.titlePlacement,
            textBoxHeight = _b.textBoxHeight;
        var isSlideshow = GALLERY_CONSTS.isLayout('SLIDESHOW')(this.props.options);
        var _c = this.state,
            hideLeftArrow = _c.hideLeftArrow,
            hideRightArrow = _c.hideRightArrow;
        var _d = getArrowsRenderData({
                customNavArrowsRenderer: this.props.customComponents.customNavArrowsRenderer,
                arrowsColor: this.props.options.arrowsColor,
                arrowsSize: this.props.options.arrowsSize,
            }),
            arrowRenderer = _d.arrowRenderer,
            navArrowsContainerWidth = _d.navArrowsContainerWidth,
            navArrowsContainerHeight = _d.navArrowsContainerHeight;
        var galleryHeight = this.props.container.galleryHeight;
        var infoHeight = isSlideshow ? slideshowInfoSize : textBoxHeight;
        var imageHeight = isSlideshow ?
            galleryHeight :
            galleryHeight - infoHeight;
        // the nav arrows parent container top edge is imageMargin/2 ABOVE the actual view, that calculates the middle point of gallery
        var galleryVerticalCenter = "50% + " + imageMargin / 4 + "px";
        // Determines the direction fix, the direction in which we move the nav arrows 'vertical position fix' pixels 
        var directionFix;
        if (GALLERY_CONSTS.hasExternalAbovePlacement(titlePlacement)) {
            directionFix = -1;
        } else if (isSlideshow || GALLERY_CONSTS.hasExternalBelowPlacement(titlePlacement)) {
            directionFix = 1;
        } else {
            // if we got here, we should be ITEM_CENTER, taken care of in layoutHelper.js
        }
        var verticalPositionFix = (_a = {},
            _a[GALLERY_CONSTS.arrowsVerticalPosition.ITEM_CENTER] = 0,
            _a[GALLERY_CONSTS.arrowsVerticalPosition.IMAGE_CENTER] = infoHeight * directionFix,
            _a[GALLERY_CONSTS.arrowsVerticalPosition.INFO_CENTER] = -imageHeight * directionFix,
            _a)[arrowsVerticalPosition];
        var containerStyle = {
            width: navArrowsContainerWidth + "px",
            height: navArrowsContainerHeight + "px",
            padding: 0,
            top: "calc(" + galleryVerticalCenter + " - " + navArrowsContainerHeight / 2 + "px - \n        " + verticalPositionFix / 2 + "px)",
        };
        var arrowsPos = scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL &&
            arrowsPosition === GALLERY_CONSTS.arrowsPosition.OUTSIDE_GALLERY ?
            "-" + (20 + navArrowsContainerWidth) + "px" :
            imageMargin / 2 + (arrowsPadding ? arrowsPadding : 0) + "px";
        // imageMargin effect the margin of the main div ('pro-gallery-parent-container') that SlideshowView is rendering, so the arrows should be places accordingly
        // arrowsPadding relevant only for arrowsPosition.ON_GALLERY
        var prevContainerStyle = {
            left: arrowsPos,
        };
        var nextContainerStyle = {
            right: arrowsPos,
        };
        return [
            hideLeftArrow ? null : (React.createElement("button", {
                className: 'nav-arrows-container' +
                    (utils.isMobile() ? ' pro-gallery-mobile-indicator' : ''),
                onClick: function() {
                    return _this._next({
                        direction: -1
                    });
                },
                "aria-label": (isRTL ? 'Next' : 'Previous') + " Item",
                tabIndex: utils.getTabIndex('slideshowPrev'),
                key: "nav-arrow-back",
                "data-hook": "nav-arrow-back",
                style: __assign(__assign({}, containerStyle), prevContainerStyle)
            }, arrowRenderer('left'))),
            hideRightArrow ? null : (React.createElement("button", {
                className: 'nav-arrows-container',
                onClick: function() {
                    return _this._next({
                        direction: 1
                    });
                },
                "aria-label": (!isRTL ? 'Next' : 'Previous') + " Item",
                tabIndex: utils.getTabIndex('slideshowNext'),
                key: "nav-arrow-next",
                "data-hook": "nav-arrow-next",
                style: __assign(__assign({}, containerStyle), nextContainerStyle)
            }, arrowRenderer('right'))),
        ];
    };
    SlideshowView.prototype.createLayout = function() {
        var _this = this;
        var _a = this.props,
            getVisibleItems = _a.getVisibleItems,
            galleryStructure = _a.galleryStructure,
            container = _a.container;
        var galleryConfig = {
            scrollingElement: this.props.scrollingElement,
            totalItemsCount: this.props.totalItemsCount,
            scroll: this.props.scroll,
            options: this.props.options,
            container: this.props.container,
            settings: this.props.settings,
            activeIndex: this.state.activeIndex,
            customComponents: this.props.customComponents,
            noFollowForSEO: this.props.noFollowForSEO,
            galleryId: this.props.id,
            gotFirstScrollEvent: this.props.gotFirstScrollEvent,
            playingVideoIdx: this.props.playingVideoIdx,
            isPrerenderMode: this.props.isPrerenderMode,
            totalWidth: this.props.galleryStructure.width,
            firstUserInteractionExecuted: this.props.firstUserInteractionExecuted,
            enableExperimentalFeatures: this.props.enableExperimentalFeatures,
            actions: {
                eventsListener: this.props.actions.eventsListener,
            },
        };
        var renderGroups = function(column) {
            var layoutGroupView = !!column.galleryGroups.length &&
                getVisibleItems(column.galleryGroups, container);
            return (layoutGroupView &&
                layoutGroupView.map(function(group) {
                    return group.rendered ?
                        React.createElement(GroupView, __assign(__assign({
                            allowLoop: _this.props.options.slideshowLoop &&
                                _this.props.galleryStructure.width >
                                _this.props.container.width
                        }, group.renderProps(galleryConfig)), {
                            ariaHidden: group.idx > _this.skipFromSlide
                        })) :
                        false;
                }));
        };
        var isSlideshow = GALLERY_CONSTS.isLayout('SLIDESHOW')(this.props.options);
        return galleryStructure.columns.map(function(column, c) {
            var columnStyle = {
                width: _this.props.isPrerenderMode ? '100%' : column.width,
                height: container.galleryHeight,
            };
            if (isSlideshow) {
                Object.assign(columnStyle, {
                    paddingBottom: _this.props.options.slideshowInfoSize,
                });
            }
            return (React.createElement("div", {
                    "data-hook": "gallery-column",
                    id: "gallery-horizontal-scroll",
                    className: "gallery-horizontal-scroll gallery-column hide-scrollbars " + (_this.props.options.isRTL ? ' rtl ' : ' ltr ') + " " + (_this.props.options.scrollSnap ? ' scroll-snap ' : '') + " ",
                    key: 'column' + c,
                    style: columnStyle
                },
                React.createElement("div", {
                    className: "gallery-horizontal-scroll-inner"
                }, renderGroups(column))));
        });
    };
    SlideshowView.prototype.createGallery = function() {
        var _a;
        // When arrows are set outside of the gallery, gallery is resized (in dimensionsHelper -> getGalleryWidth) and needs to be positioned accordingly
        var galleryStyleForExternalArrows = this.props.options.scrollDirection ===
            GALLERY_CONSTS.scrollDirection.HORIZONTAL &&
            this.props.options.arrowsPosition ===
            GALLERY_CONSTS.arrowsPosition.OUTSIDE_GALLERY ?
            {
                overflow: 'visible',
                left: this.props.options.arrowsSize +
                    40 +
                    this.props.options.imageMargin / 2,
            } :
            {};
        var galleryDimensions = this.props.isPrerenderMode ?
            {
                width: '100%',
                height: this.props.container.galleryHeight,
            } :
            {
                height: this.props.container.galleryHeight,
                width: this.props.container.galleryWidth,
            };
        var galleryStyle = __assign(__assign({}, galleryDimensions), galleryStyleForExternalArrows);
        var isSlideshow = GALLERY_CONSTS.isLayout('SLIDESHOW')(this.props.options);
        if (isSlideshow) {
            Object.assign(galleryStyle, {
                paddingBottom: this.props.options.slideshowInfoSize,
            });
        }
        return (React.createElement("div", {
                id: this.props.galleryContainerId,
                className: 'pro-gallery inline-styles one-row hide-scrollbars ' +
                    (this.props.options.enableScroll ? ' slider ' : '') +
                    (((_a = this.props.settings) === null || _a === void 0 ? void 0 : _a.isAccessible) ? ' accessible ' : '') +
                    (this.props.options.isRTL ? ' rtl ' : ' ltr '),
                style: galleryStyle
            },
            this.createDebugMsg(),
            shouldRenderNavArrows({
                options: this.props.options,
                container: this.props.container,
                isPrerenderMode: this.props.isPrerenderMode,
                galleryStructure: this.props.galleryStructure,
                customNavArrowsRenderer: this.props.customComponents.customNavArrowsRenderer,
            }) && this.createNavArrows(),
            this.createLayout(),
            this.createAutoSlideShowPlayButton(),
            this.createSlideShowNumbers()));
    };
    SlideshowView.prototype.onAutoSlideShowButtonClick = function() {
        var _this = this;
        this.setState({
            pauseAutoSlideshowClicked: !this.state.pauseAutoSlideshowClicked
        }, function() {
            _this.blockAutoSlideshowIfNeeded(_this.props);
        });
    };
    SlideshowView.prototype.isFullWidthGallery = function() {
        return this.props.container.galleryWidth >= utils.getWindowWidth() - 10;
    };
    SlideshowView.prototype.onAutoSlideshowAutoPlayKeyPress = function(e) {
        switch (e.keyCode || e.charCode) {
            case 32: //space
            case 13: //enter
                e.preventDefault();
                e.stopPropagation();
                this.onAutoSlideShowButtonClick();
                return false;
            default:
                return true;
        }
    };
    SlideshowView.prototype.calcSlideshowCounterWidth = function() {
        var totalItemsCount = this.props.totalItemsCount;
        if (totalItemsCount < 10) {
            // x/x
            return 26;
        } else if (totalItemsCount < 100) {
            // xx/xx
            return 43;
        } else if (totalItemsCount < 1000) {
            // xxx/xxx
            return 60;
        } else {
            // xxxx/xxxx or more
            return 76;
        }
    };
    SlideshowView.prototype.createAutoSlideShowPlayButton = function() {
        var _this = this;
        if (!this.shouldCreateSlideShowPlayButton) {
            return false;
        }
        var _a = this.props.options,
            galleryTextAlign = _a.galleryTextAlign,
            slideshowInfoSize = _a.slideshowInfoSize;
        var imageMargin = this.props.options.imageMargin / 2 +
            (this.isFullWidthGallery() ? 50 : 0);
        var side = galleryTextAlign === 'right' ?
            {
                left: imageMargin / 2 + "px"
            } :
            {
                right: imageMargin / 2 +
                    (this.props.options.allowSlideshowCounter ?
                        this.calcSlideshowCounterWidth() :
                        0) + "px",
            };
        return (React.createElement("button", {
            className: 'auto-slideshow-button',
            onClick: function() {
                _this.onAutoSlideShowButtonClick();
            },
            onKeyDown: this.onAutoSlideshowAutoPlayKeyPress,
            "data-hook": "auto-slideshow-button",
            title: 'slideshow auto play',
            "aria-pressed": this.state.pauseAutoSlideshowClicked,
            tabIndex: 0,
            style: __assign({
                top: "calc(100% - " + slideshowInfoSize + "px + 3px)"
            }, side)
        }, this.state.pauseAutoSlideshowClicked ? (React.createElement(PlayIcon, {
            width: "10px",
            height: "100%"
        })) : (React.createElement(PauseIcon, {
            width: "10px",
            height: "100%"
        }))));
    };
    SlideshowView.prototype.createSlideShowNumbers = function() {
        if (!this.props.options.allowSlideshowCounter) {
            return false;
        }
        var _a = this.props,
            totalItemsCount = _a.totalItemsCount,
            _b = _a.options,
            galleryTextAlign = _b.galleryTextAlign,
            slideshowInfoSize = _b.slideshowInfoSize;
        var imageMargin = this.props.options.imageMargin / 2 +
            (this.isFullWidthGallery() ? 50 : 0);
        var leftMargin = this.shouldCreateSlideShowPlayButton ?
            imageMargin / 2 + 25 :
            imageMargin / 2;
        var side = galleryTextAlign === 'right' ?
            {
                left: leftMargin + "px"
            } :
            {
                right: imageMargin / 2 + "px"
            };
        return (React.createElement("div", {
                className: 'auto-slideshow-counter',
                "data-hook": "auto-slideshow-counter",
                style: __assign({
                    top: "calc(100% - " + slideshowInfoSize + "px + 3px)"
                }, side)
            },
            React.createElement("div", null, (this.state.activeIndex % totalItemsCount) +
                1 +
                '/' +
                totalItemsCount)));
    };
    SlideshowView.prototype.getThumbnails = function() {
        var hasThumbnails = this.props.options.hasThumbnails;
        var thumbnailsPosition = this.props.options.galleryThumbnailsAlignment;
        var thumbnailsGallery = hasThumbnails ?
            this.createThumbnails(thumbnailsPosition) :
            false;
        var thumbnails = [];
        switch (thumbnailsPosition) {
            case 'top':
            case 'left':
                thumbnails[0] = thumbnailsGallery;
                thumbnails[1] = false;
                break;
            case 'right':
            case 'bottom':
                thumbnails[0] = false;
                thumbnails[1] = thumbnailsGallery;
                break;
        }
        return thumbnails;
    };
    SlideshowView.prototype.getClassNames = function() {
        GALLERY_CONSTS.isLayout('SLIDESHOW')(this.props.options);
        var classNames = 'pro-gallery-parent-container';
        if (GALLERY_CONSTS.isLayout('SLIDESHOW')(this.props.options)) {
            classNames += ' gallery-slideshow';
        } else if (GALLERY_CONSTS.isLayout('SLIDER')(this.props.options)) {
            classNames += ' gallery-slider';
        } else if (this.props.options.hasThumbnails) {
            classNames += ' gallery-thumbnails';
        } else if (GALLERY_CONSTS.isLayout('COLUMN')(this.props.options)) {
            classNames += ' gallery-columns';
        }
        if (this.isFullWidthGallery()) {
            classNames += ' streched';
        }
        return classNames;
    };
    SlideshowView.prototype.getStyles = function() {
        return {
            margin: -1 *
                (this.props.options.imageMargin / 2 -
                    this.props.options.layoutParams.gallerySpacing),
        };
    };
    SlideshowView.prototype.getScrollPosition = function() {
        return this.scrollElement ?
            this.scrollPosition() :
            0;
    };
    SlideshowView.prototype.scrollPositionAtTheMiddleOfTheGallery = function() {
        return this.getScrollPosition() + this.props.container.galleryWidth / 2;
    };
    SlideshowView.prototype.scrollPositionAtTheAndOfTheGallery = function() {
        return this.getScrollPosition() + this.props.container.galleryWidth;
    };
    SlideshowView.prototype.scrollPosition = function() {
        return (this.props.options.isRTL ? -1 : 1) * this.scrollElement.scrollLeft;
    };
    //-----------------------------------------| REACT |--------------------------------------------//
    SlideshowView.prototype.blockAutoSlideshowIfNeeded = function(props) {
        var _this = this;
        if (props === void 0) {
            props = this.props;
        }
        var isGalleryInHover = props.isGalleryInHover,
            options = props.options,
            settings = props.settings;
        var _a = this.state,
            pauseAutoSlideshowClicked = _a.pauseAutoSlideshowClicked,
            shouldBlockAutoSlideshow = _a.shouldBlockAutoSlideshow,
            isInView = _a.isInView,
            isInFocus = _a.isInFocus;
        var should = false;
        if (!isInView || pauseAutoSlideshowClicked) {
            should = true;
        } else if (isGalleryInHover &&
            options.pauseAutoSlideshowOnHover) {
            should = true;
        } else if (isInFocus && (settings === null || settings === void 0 ? void 0 : settings.isAccessible)) {
            should = true;
        }
        if (shouldBlockAutoSlideshow !== should) {
            this.setState({
                shouldBlockAutoSlideshow: should
            }, function() {
                _this.startAutoSlideshowIfNeeded(options);
            });
        } else {
            return;
        }
    };
    SlideshowView.prototype.onFocus = function() {
        var _this = this;
        this.setState({
            isInFocus: true
        }, function() {
            _this.blockAutoSlideshowIfNeeded(_this.props);
        });
    };
    SlideshowView.prototype.onBlur = function() {
        var _this = this;
        this.setState({
            isInFocus: false
        }, function() {
            _this.blockAutoSlideshowIfNeeded(_this.props);
        });
    };
    SlideshowView.prototype.UNSAFE_componentWillReceiveProps = function(props) {
        var _this = this;
        if (props.items) {
            this.ItemsForSlideshowLoopThumbnails = false;
        }
        if (this.props.isInDisplay !== props.isInDisplay) {
            this.setState({
                isInView: props.isInDisplay
            }, function() {
                return _this.blockAutoSlideshowIfNeeded(props);
            });
        }
        if (this.props.isGalleryInHover !== props.isGalleryInHover) {
            this.blockAutoSlideshowIfNeeded(props);
        }
        if (this.props.activeIndex !== props.activeIndex) {
            utils.setStateAndLog(this, 'Next Item', {
                activeIndex: props.activeIndex,
            }, function() {
                _this.onCurrentItemChanged();
            });
        }
        if (this.props.totalItemsCount !== props.totalItemsCount) {
            this.removeArrowsIfNeeded();
        }
        if (isEditMode() || isPreviewMode()) {
            if (
                //check that the change is related to the slideshow settings
                this.props.options.isAutoSlideshow !==
                props.options.isAutoSlideshow ||
                this.props.options.autoSlideshowInterval !==
                props.options.autoSlideshowInterval) {
                this.startAutoSlideshowIfNeeded(props.options);
            }
        }
        this.shouldCreateSlideShowPlayButton =
            props.options.isAutoSlideshow && props.options.playButtonForAutoSlideShow;
    };
    SlideshowView.prototype.removeArrowsIfNeeded = function() {
        var isRTL = this.props.options.isRTL;
        var _a = this.state,
            hideLeftArrow = _a.hideLeftArrow,
            hideRightArrow = _a.hideRightArrow;
        var isScrollStart = this.isScrollStart();
        var isFirstItem = this.isFirstItem();
        var isScrollEnd = this.isScrollEnd();
        var isLastItem = this.isLastItem();
        var atStart = isScrollStart || isFirstItem;
        var atEnd = isScrollEnd || isLastItem;
        var nextHideLeft = (!isRTL && atStart) || (isRTL && atEnd);
        var nextHideRight = (isRTL && atStart) || (!isRTL && atEnd);
        var shouldUpdateArrowsState = !!nextHideLeft !== !!hideLeftArrow ||
            !!nextHideRight !== !!hideRightArrow;
        if (shouldUpdateArrowsState) {
            this.setState({
                hideLeftArrow: !!nextHideLeft,
                hideRightArrow: !!nextHideRight,
            });
        }
    };
    SlideshowView.prototype.navigationOutHandler = function() {
        //TODO remove after full refactor release
        utils.setStateAndLog(this, 'Next Item', {
            isInView: false,
        });
        this.clearAutoSlideshowInterval();
    };
    SlideshowView.prototype.navigationInHandler = function() {
        //TODO remove after full refactor release
        utils.setStateAndLog(this, 'Next Item', {
            isInView: true,
        });
        this.startAutoSlideshowIfNeeded(this.props.options);
    };
    SlideshowView.prototype.componentDidMount = function() {
        window.addEventListener('gallery_navigation_out', this.navigationOutHandler);
        window.addEventListener('gallery_navigation_in', this.navigationInHandler);
        this.scrollElement = window.document.querySelector("#pro-gallery-" + this.props.id + " #gallery-horizontal-scroll");
        if (this.scrollElement) {
            this.scrollElement.addEventListener('scroll', this._setCurrentItemByScroll);
        }
        if (this.state.activeIndex > 0) {
            this.props.actions.scrollToItem(this.state.activeIndex);
            this.onCurrentItemChanged();
        } else {
            this.setCurrentItemByScroll();
        }
        this.startAutoSlideshowIfNeeded(this.props.options);
    };
    SlideshowView.prototype.componentWillUnmount = function() {
        window.removeEventListener('gallery_navigation_out', this.navigationOutHandler);
        window.removeEventListener('gallery_navigation_in', this.navigationInHandler);
        if (this.scrollElement) {
            this.scrollElement.removeEventListener('scroll', this._setCurrentItemByScroll);
        }
    };
    //-----------------------------------------| RENDER |--------------------------------------------//
    SlideshowView.prototype.render = function() {
        if (utils.isVerbose()) {
            console.count('galleryView render');
            console.count('Rendering Gallery count');
            console.time('Rendering Gallery took ');
        }
        var gallery = this.createGallery();
        var thumbnails = this.getThumbnails();
        if (utils.isVerbose()) {
            console.timeEnd('Rendering Gallery took ');
        }
        return (React.createElement("div", __assign({
                className: this.getClassNames(),
                style: this.getStyles(),
                onKeyDown: this.handleSlideshowKeyPress
            }, utils.getAriaAttributes({
                proGalleryRole: this.props.proGalleryRole,
                proGalleryRegionLabel: this.props.proGalleryRegionLabel
            }), {
                onFocus: this.onFocus,
                onBlur: this.onBlur
            }),
            thumbnails[0],
            gallery,
            thumbnails[1]));
    };
    return SlideshowView;
}(React.Component));
export default SlideshowView;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=slideshowView.js.map