import {
    utils
} from 'pro-gallery-lib';
import {
    GALLERY_CONSTS
} from 'pro-gallery-lib';
export function scrollToItemImp(scrollParams) {
    var to, from;
    var _a = scrollParams.scrollMarginCorrection,
        scrollMarginCorrection = _a === void 0 ? 0 : _a,
        durationInMS = scrollParams.durationInMS,
        horizontalElement = scrollParams.horizontalElement,
        scrollingElement = scrollParams.scrollingElement,
        isRTL = scrollParams.isRTL,
        scrollDirection = scrollParams.scrollDirection,
        galleryWidth = scrollParams.galleryWidth,
        galleryHeight = scrollParams.galleryHeight,
        totalWidth = scrollParams.totalWidth,
        top = scrollParams.top,
        items = scrollParams.items,
        itemIdx = scrollParams.itemIdx,
        fixedScroll = scrollParams.fixedScroll,
        slideTransition = scrollParams.slideTransition,
        isContinuousScrolling = scrollParams.isContinuousScrolling,
        autoSlideshowContinuousSpeed = scrollParams.autoSlideshowContinuousSpeed,
        imageMargin = scrollParams.imageMargin;
    var rtlFix = isRTL ? -1 : 1;
    //default = scroll by half the container size
    if (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL) {
        from = horizontalElement.scrollLeft * rtlFix;
        to = from + (itemIdx * galleryWidth) / 2;
    } else {
        from = top;
        to = top + (itemIdx * galleryHeight) / 2;
    }
    if (fixedScroll !== true) {
        //scroll to specific item
        if (utils.isVerbose()) {
            console.log('Scrolling to items #' + itemIdx);
        }
        var item = items.find(function(itm) {
            return itm.idx === itemIdx;
        });
        to =
            scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL ?
            utils.get(item, 'offset.left') :
            utils.get(item, 'offset.top');
        if (utils.isVerbose()) {
            console.log('Scrolling to position ' + to, item);
        }
        if (!(to >= 0)) {
            utils.isVerbose() && console.warn('Position not found, not scrolling');
            return new Promise(function(res) {
                return res();
            });
        }
        if (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL) {
            //set scroll to place the item in the middle of the component
            var diff = (galleryWidth - item.width - imageMargin) / 2;
            to -= diff;
            to = Math.max(0, to);
            to = Math.min(to, totalWidth - galleryWidth + scrollMarginCorrection);
            to *= rtlFix;
            from *= rtlFix;
            if (utils.isVerbose()) {
                console.log('Scrolling to new position ' + to, this);
            }
        }
    }
    if (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL) {
        return horizontalCssScrollTo({
            scroller: horizontalElement,
            from: Math.round(from),
            to: Math.round(to),
            duration: durationInMS,
            isRTL: isRTL,
            slideTransition: slideTransition,
            isContinuousScrolling: isContinuousScrolling,
            autoSlideshowContinuousSpeed: autoSlideshowContinuousSpeed,
        });
    } else {
        return new Promise(function(resolve) {
            scrollingElement.vertical().scrollTo(0, to);
            resolve(to);
        });
    }
}
export function scrollToGroupImp(scrollParams) {
    var to, from;
    var _a = scrollParams.scrollMarginCorrection,
        scrollMarginCorrection = _a === void 0 ? 0 : _a,
        durationInMS = scrollParams.durationInMS,
        horizontalElement = scrollParams.horizontalElement,
        scrollingElement = scrollParams.scrollingElement,
        isRTL = scrollParams.isRTL,
        scrollDirection = scrollParams.scrollDirection,
        galleryWidth = scrollParams.galleryWidth,
        galleryHeight = scrollParams.galleryHeight,
        totalWidth = scrollParams.totalWidth,
        top = scrollParams.top,
        groups = scrollParams.groups,
        groupIdx = scrollParams.groupIdx,
        fixedScroll = scrollParams.fixedScroll,
        slideTransition = scrollParams.slideTransition,
        isContinuousScrolling = scrollParams.isContinuousScrolling,
        autoSlideshowContinuousSpeed = scrollParams.autoSlideshowContinuousSpeed,
        imageMargin = scrollParams.imageMargin;
    var rtlFix = isRTL ? -1 : 1;
    //default = scroll by half the container size
    if (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL) {
        from = horizontalElement.scrollLeft;
        to = from + (groupIdx * galleryWidth) / 2;
        // console.log('[RTL SCROLL] scrollTogroupImp: ', from, to);
    } else {
        from = top;
        to = top + (groupIdx * galleryHeight) / 2;
    }
    if (fixedScroll !== true) {
        //scroll to specific group
        if (utils.isVerbose()) {
            console.log('Scrolling to groups #' + groupIdx);
        }
        var group = groups.find(function(grp) {
            return grp.idx === groupIdx;
        });
        to =
            scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL ?
            utils.get(group, 'left') :
            utils.get(group, 'top');
        if (utils.isVerbose()) {
            console.log('Scrolling to position ' + to, group);
        }
        if (!(to >= 0)) {
            utils.isVerbose() && console.warn('Position not found, not scrolling');
            return new Promise(function(res) {
                return res();
            });
        }
        if (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL) {
            //set scroll to place the group in the middle of the component
            var diff = (galleryWidth - group.width - imageMargin) / 2;
            to -= diff;
            to = Math.max(0, to);
            to = Math.min(to, totalWidth - galleryWidth + scrollMarginCorrection);
            to *= rtlFix;
            if (utils.isVerbose()) {
                console.log('Scrolling to new position ' + to, this);
            }
        }
    }
    if (scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL) {
        return horizontalCssScrollTo({
            scroller: horizontalElement,
            from: Math.round(from),
            to: Math.round(to),
            duration: durationInMS,
            isRTL: isRTL,
            slideTransition: slideTransition,
            isContinuousScrolling: isContinuousScrolling,
            autoSlideshowContinuousSpeed: autoSlideshowContinuousSpeed,
        });
    } else {
        return new Promise(function(resolve) {
            scrollingElement.vertical().scrollTo(0, to);
            resolve(to);
        });
    }
}
// ----- rendererd / visible ----- //
function getDistanceFromScreen(_a) {
    var offset = _a.offset,
        scroll = _a.scroll,
        itemStart = _a.itemStart,
        itemEnd = _a.itemEnd,
        screenSize = _a.screenSize;
    var before = scroll - offset - itemEnd;
    var after = offset + itemStart - screenSize - scroll;
    return {
        before: before,
        after: after
    };
}

function isWithinPaddingVertically(_a) {
    var target = _a.target,
        scrollBase = _a.scrollBase,
        top = _a.top,
        bottom = _a.bottom,
        screenHeight = _a.screenHeight,
        padding = _a.padding;
    var res = getDistanceFromScreen({
        offset: scrollBase || 0,
        scroll: target.scrollY,
        itemStart: top,
        itemEnd: bottom,
        screenSize: screenHeight,
    });
    return res.before < padding && res.after < padding;
}

function isWithinPaddingHorizontally(_a) {
    var target = _a.target,
        left = _a.left,
        right = _a.right,
        screenWidth = _a.screenWidth,
        padding = _a.padding;
    var res = getDistanceFromScreen({
        offset: 0,
        scroll: target.scrollLeft,
        itemStart: left,
        itemEnd: right,
        screenSize: screenWidth,
    });
    return res.before < padding && res.after < padding;
}

function horizontalCssScrollTo(_a) {
    var scroller = _a.scroller,
        from = _a.from,
        to = _a.to,
        duration = _a.duration,
        isRTL = _a.isRTL,
        slideTransition = _a.slideTransition,
        isContinuousScrolling = _a.isContinuousScrolling,
        autoSlideshowContinuousSpeed = _a.autoSlideshowContinuousSpeed;
    var change = to - from;
    if (change === 0) {
        return new Promise(function(resolve) {
            return resolve(to);
        });
    }
    if (isContinuousScrolling) {
        duration = (Math.abs(change) / autoSlideshowContinuousSpeed) * 1000;
    }
    var scrollerInner = scroller.firstChild;
    scroller.setAttribute('data-scrolling', 'true');
    Object.assign(scroller.style, {
        'scroll-snap-type': 'none',
    });
    Object.assign(scrollerInner.style, {
            transition: "margin " + duration + "ms " + slideTransition,
            '-webkit-transition': "margin " + duration + "ms " + slideTransition,
        }, isRTL ?
        {
            marginRight: change + "px",
        } :
        {
            marginLeft: -1 * change + "px",
        });
    var intervals = 10;
    var scrollTransitionEvent = new CustomEvent('scrollTransition', {
        detail: change / intervals,
    });
    var scrollTransitionInterval = setInterval(function() {
        scroller.dispatchEvent(scrollTransitionEvent);
    }, Math.round(duration / intervals));
    return new Promise(function(resolve) {
        setTimeout(function() {
            clearInterval(scrollTransitionInterval);
            Object.assign(scrollerInner.style, {
                    transition: "none",
                    '-webkit-transition': "none",
                }, isRTL ?
                {
                    marginRight: 0,
                } :
                {
                    marginLeft: 0,
                });
            scroller.style.removeProperty('scroll-snap-type');
            scroller.scrollLeft = to;
            scroller.setAttribute('data-scrolling', '');
            resolve(to);
        }, duration);
    });
}
export {
    isWithinPaddingHorizontally,
    isWithinPaddingVertically
};
//# sourceMappingURL=scrollHelper.js.map